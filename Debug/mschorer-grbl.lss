
mschorer-grbl.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  00007962  000079f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007962  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068a  00800106  00800106  000079fc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000079fc  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000580  00000000  00000000  00007a2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00008519  00000000  00000000  00007fac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000020da  00000000  00000000  000104c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000028ec  00000000  00000000  0001259f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00001214  00000000  00000000  00014e8c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001636  00000000  00000000  000160a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000059f8  00000000  00000000  000176d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000558  00000000  00000000  0001d0ce  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f2 04 	jmp	0x9e4	; 0x9e4 <__ctors_end>
       4:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
       8:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
       c:	0c 94 44 2b 	jmp	0x5688	; 0x5688 <__vector_3>
      10:	0c 94 2e 35 	jmp	0x6a5c	; 0x6a5c <__vector_4>
      14:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      18:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      1c:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      20:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      24:	0c 94 11 37 	jmp	0x6e22	; 0x6e22 <__vector_9>
      28:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      2c:	0c 94 06 18 	jmp	0x300c	; 0x300c <__vector_11>
      30:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      34:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      38:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      3c:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      40:	0c 94 1c 1a 	jmp	0x3438	; 0x3438 <__vector_16>
      44:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      48:	0c 94 eb 15 	jmp	0x2bd6	; 0x2bd6 <__vector_18>
      4c:	0c 94 ad 15 	jmp	0x2b5a	; 0x2b5a <__vector_19>
      50:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      54:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      58:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      5c:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      60:	0c 94 bb 37 	jmp	0x6f76	; 0x6f76 <__vector_24>
      64:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <__bad_interrupt>
      68:	49 0b       	sbc	r20, r25
      6a:	49 0b       	sbc	r20, r25
      6c:	49 0b       	sbc	r20, r25
      6e:	49 0b       	sbc	r20, r25
      70:	eb 0a       	sbc	r14, r27
      72:	96 14       	cp	r9, r6
      74:	96 14       	cp	r9, r6
      76:	96 14       	cp	r9, r6
      78:	96 14       	cp	r9, r6
      7a:	96 14       	cp	r9, r6
      7c:	e3 0a       	sbc	r14, r19
      7e:	96 14       	cp	r9, r6
      80:	96 14       	cp	r9, r6
      82:	96 14       	cp	r9, r6
      84:	96 14       	cp	r9, r6
      86:	96 14       	cp	r9, r6
      88:	96 14       	cp	r9, r6
      8a:	8a 0b       	sbc	r24, r26
      8c:	8a 0b       	sbc	r24, r26
      8e:	8a 0b       	sbc	r24, r26
      90:	bf 0b       	sbc	r27, r31
      92:	bf 0b       	sbc	r27, r31
      94:	96 14       	cp	r9, r6
      96:	96 14       	cp	r9, r6
      98:	96 14       	cp	r9, r6
      9a:	96 14       	cp	r9, r6
      9c:	96 14       	cp	r9, r6
      9e:	96 14       	cp	r9, r6
      a0:	e3 0a       	sbc	r14, r19
      a2:	96 14       	cp	r9, r6
      a4:	e3 0a       	sbc	r14, r19
      a6:	96 14       	cp	r9, r6
      a8:	96 14       	cp	r9, r6
      aa:	96 14       	cp	r9, r6
      ac:	96 14       	cp	r9, r6
      ae:	96 14       	cp	r9, r6
      b0:	96 14       	cp	r9, r6
      b2:	96 14       	cp	r9, r6
      b4:	49 0b       	sbc	r20, r25
      b6:	96 14       	cp	r9, r6
      b8:	96 14       	cp	r9, r6
      ba:	96 14       	cp	r9, r6
      bc:	96 14       	cp	r9, r6
      be:	cd 0b       	sbc	r28, r29
      c0:	96 14       	cp	r9, r6
      c2:	96 14       	cp	r9, r6
      c4:	96 14       	cp	r9, r6
      c6:	96 14       	cp	r9, r6
      c8:	96 14       	cp	r9, r6
      ca:	cd 0b       	sbc	r28, r29
      cc:	96 14       	cp	r9, r6
      ce:	96 14       	cp	r9, r6
      d0:	96 14       	cp	r9, r6
      d2:	eb 0a       	sbc	r14, r27
      d4:	e1 0b       	sbc	r30, r17
      d6:	e1 0b       	sbc	r30, r17
      d8:	e1 0b       	sbc	r30, r17
      da:	e1 0b       	sbc	r30, r17
      dc:	e1 0b       	sbc	r30, r17
      de:	e1 0b       	sbc	r30, r17
      e0:	96 14       	cp	r9, r6
      e2:	96 14       	cp	r9, r6
      e4:	96 14       	cp	r9, r6
      e6:	96 14       	cp	r9, r6
      e8:	96 14       	cp	r9, r6
      ea:	96 14       	cp	r9, r6
      ec:	96 14       	cp	r9, r6
      ee:	96 14       	cp	r9, r6
      f0:	96 14       	cp	r9, r6
      f2:	96 14       	cp	r9, r6
      f4:	96 14       	cp	r9, r6
      f6:	96 14       	cp	r9, r6
      f8:	96 14       	cp	r9, r6
      fa:	96 14       	cp	r9, r6
      fc:	96 14       	cp	r9, r6
      fe:	96 14       	cp	r9, r6
     100:	96 14       	cp	r9, r6
     102:	96 14       	cp	r9, r6
     104:	96 14       	cp	r9, r6
     106:	96 14       	cp	r9, r6
     108:	4f 0b       	sbc	r20, r31
     10a:	96 14       	cp	r9, r6
     10c:	96 14       	cp	r9, r6
     10e:	96 14       	cp	r9, r6
     110:	96 14       	cp	r9, r6
     112:	96 14       	cp	r9, r6
     114:	96 14       	cp	r9, r6
     116:	96 14       	cp	r9, r6
     118:	96 14       	cp	r9, r6
     11a:	96 14       	cp	r9, r6
     11c:	a3 0b       	sbc	r26, r19
     11e:	a3 0b       	sbc	r26, r19
     120:	e3 0a       	sbc	r14, r19
     122:	b1 0b       	sbc	r27, r17
     124:	b1 0b       	sbc	r27, r17
     126:	0f 0c       	add	r0, r15
     128:	0f 0c       	add	r0, r15
     12a:	0f 0c       	add	r0, r15
     12c:	27 0c       	add	r2, r7
     12e:	27 0c       	add	r2, r7
     130:	27 0c       	add	r2, r7
     132:	21 0c       	add	r2, r1
     134:	3e 0c       	add	r3, r14
     136:	3e 0c       	add	r3, r14
     138:	3e 0c       	add	r3, r14
     13a:	ac 14       	cp	r10, r12
     13c:	ac 14       	cp	r10, r12
     13e:	ac 14       	cp	r10, r12
     140:	ac 14       	cp	r10, r12
     142:	ac 14       	cp	r10, r12
     144:	ac 14       	cp	r10, r12
     146:	ac 14       	cp	r10, r12
     148:	ac 14       	cp	r10, r12
     14a:	ac 14       	cp	r10, r12
     14c:	ac 14       	cp	r10, r12
     14e:	ac 14       	cp	r10, r12
     150:	ac 14       	cp	r10, r12
     152:	ac 14       	cp	r10, r12
     154:	ac 14       	cp	r10, r12
     156:	ac 14       	cp	r10, r12
     158:	ac 14       	cp	r10, r12
     15a:	ac 14       	cp	r10, r12
     15c:	ac 14       	cp	r10, r12
     15e:	ac 14       	cp	r10, r12
     160:	ac 14       	cp	r10, r12
     162:	0f 0c       	add	r0, r15
     164:	78 0c       	add	r7, r8
     166:	b0 14       	cp	r11, r0
     168:	82 0c       	add	r8, r2
     16a:	87 0c       	add	r8, r7
     16c:	94 0c       	add	r9, r4
     16e:	a1 0c       	add	r10, r1
     170:	ae 0c       	add	r10, r14
     172:	b0 14       	cp	r11, r0
     174:	b2 0c       	add	r11, r2
     176:	b0 14       	cp	r11, r0
     178:	c0 0c       	add	r12, r0
     17a:	b0 14       	cp	r11, r0
     17c:	ca 0c       	add	r12, r10
     17e:	d4 0c       	add	r13, r4
     180:	de 0c       	add	r13, r14
     182:	b0 14       	cp	r11, r0
     184:	b0 14       	cp	r11, r0
     186:	b0 14       	cp	r11, r0
     188:	e2 0c       	add	r14, r2
     18a:	ef 0c       	add	r14, r15
     18c:	fc 0c       	add	r15, r12
     18e:	82 13       	cpse	r24, r18
     190:	d6 13       	cpse	r29, r22
     192:	f5 13       	cpse	r31, r21
     194:	d6 13       	cpse	r29, r22
     196:	fb 13       	cpse	r31, r27
     198:	12 14       	cp	r1, r2
     19a:	01 14       	cp	r0, r1
     19c:	0b 14       	cp	r0, r11
     19e:	fd 23       	and	r31, r29
     1a0:	03 24       	eor	r0, r3
     1a2:	06 24       	eor	r0, r6
     1a4:	09 24       	eor	r0, r9
     1a6:	0c 24       	eor	r0, r12
     1a8:	1a 24       	eor	r1, r10
     1aa:	28 24       	eor	r2, r8
     1ac:	c0 24       	eor	r12, r0
     1ae:	c0 24       	eor	r12, r0
     1b0:	c0 24       	eor	r12, r0
     1b2:	36 24       	eor	r3, r6
     1b4:	38 24       	eor	r3, r8
     1b6:	41 24       	eor	r4, r1
     1b8:	4a 24       	eor	r4, r10
     1ba:	58 24       	eor	r5, r8
     1bc:	c0 24       	eor	r12, r0
     1be:	c0 24       	eor	r12, r0
     1c0:	c0 24       	eor	r12, r0
     1c2:	c0 24       	eor	r12, r0
     1c4:	c0 24       	eor	r12, r0
     1c6:	66 24       	eor	r6, r6
     1c8:	76 24       	eor	r7, r6
     1ca:	86 24       	eor	r8, r6
     1cc:	94 24       	eor	r9, r4
     1ce:	97 24       	eor	r9, r7
     1d0:	a0 24       	eor	r10, r0
     1d2:	a9 24       	eor	r10, r9
     1d4:	b0 24       	eor	r11, r0
     1d6:	c6 2f       	mov	r28, r22
     1d8:	cb 2f       	mov	r28, r27
     1da:	d0 2f       	mov	r29, r16
     1dc:	d5 2f       	mov	r29, r21
     1de:	da 2f       	mov	r29, r26
     1e0:	df 2f       	mov	r29, r31
     1e2:	e4 2f       	mov	r30, r20
     1e4:	e9 2f       	mov	r30, r25
     1e6:	ee 2f       	mov	r30, r30
     1e8:	f3 2f       	mov	r31, r19
     1ea:	f8 2f       	mov	r31, r24
     1ec:	0c 30       	cpi	r16, 0x0C	; 12
     1ee:	0c 30       	cpi	r16, 0x0C	; 12
     1f0:	0c 30       	cpi	r16, 0x0C	; 12
     1f2:	0c 30       	cpi	r16, 0x0C	; 12
     1f4:	0c 30       	cpi	r16, 0x0C	; 12
     1f6:	0c 30       	cpi	r16, 0x0C	; 12
     1f8:	0c 30       	cpi	r16, 0x0C	; 12
     1fa:	0c 30       	cpi	r16, 0x0C	; 12
     1fc:	02 30       	cpi	r16, 0x02	; 2
     1fe:	fd 2f       	mov	r31, r29
     200:	07 30       	cpi	r16, 0x07	; 7
     202:	3b 34       	cpi	r19, 0x4B	; 75
     204:	54 34       	cpi	r21, 0x44	; 68
     206:	59 34       	cpi	r21, 0x49	; 73
     208:	5d 34       	cpi	r21, 0x4D	; 77
     20a:	4f 34       	cpi	r20, 0x4F	; 79
     20c:	5d 34       	cpi	r21, 0x4D	; 77
     20e:	5d 34       	cpi	r21, 0x4D	; 77
     210:	5d 34       	cpi	r21, 0x4D	; 77
     212:	40 34       	cpi	r20, 0x40	; 64
     214:	5d 34       	cpi	r21, 0x4D	; 77
     216:	5d 34       	cpi	r21, 0x4D	; 77
     218:	5d 34       	cpi	r21, 0x4D	; 77
     21a:	5d 34       	cpi	r21, 0x4D	; 77
     21c:	5d 34       	cpi	r21, 0x4D	; 77
     21e:	5d 34       	cpi	r21, 0x4D	; 77
     220:	5d 34       	cpi	r21, 0x4D	; 77
     222:	45 34       	cpi	r20, 0x45	; 69
     224:	5d 34       	cpi	r21, 0x4D	; 77
     226:	5d 34       	cpi	r21, 0x4D	; 77
     228:	5d 34       	cpi	r21, 0x4D	; 77
     22a:	5d 34       	cpi	r21, 0x4D	; 77
     22c:	5d 34       	cpi	r21, 0x4D	; 77
     22e:	5d 34       	cpi	r21, 0x4D	; 77
     230:	5d 34       	cpi	r21, 0x4D	; 77
     232:	5d 34       	cpi	r21, 0x4D	; 77
     234:	5d 34       	cpi	r21, 0x4D	; 77
     236:	5d 34       	cpi	r21, 0x4D	; 77
     238:	5d 34       	cpi	r21, 0x4D	; 77
     23a:	5d 34       	cpi	r21, 0x4D	; 77
     23c:	5d 34       	cpi	r21, 0x4D	; 77
     23e:	5d 34       	cpi	r21, 0x4D	; 77
     240:	5d 34       	cpi	r21, 0x4D	; 77
     242:	4a 34       	cpi	r20, 0x4A	; 74
     244:	34 37       	cpi	r19, 0x74	; 116
     246:	48 37       	cpi	r20, 0x78	; 120
     248:	4c 37       	cpi	r20, 0x7C	; 124
     24a:	50 37       	cpi	r21, 0x70	; 112
     24c:	44 37       	cpi	r20, 0x74	; 116
     24e:	50 37       	cpi	r21, 0x70	; 112
     250:	50 37       	cpi	r21, 0x70	; 112
     252:	50 37       	cpi	r21, 0x70	; 112
     254:	38 37       	cpi	r19, 0x78	; 120
     256:	50 37       	cpi	r21, 0x70	; 112
     258:	50 37       	cpi	r21, 0x70	; 112
     25a:	50 37       	cpi	r21, 0x70	; 112
     25c:	50 37       	cpi	r21, 0x70	; 112
     25e:	50 37       	cpi	r21, 0x70	; 112
     260:	50 37       	cpi	r21, 0x70	; 112
     262:	50 37       	cpi	r21, 0x70	; 112
     264:	40 37       	cpi	r20, 0x70	; 112
     266:	50 37       	cpi	r21, 0x70	; 112
     268:	50 37       	cpi	r21, 0x70	; 112
     26a:	50 37       	cpi	r21, 0x70	; 112
     26c:	50 37       	cpi	r21, 0x70	; 112
     26e:	50 37       	cpi	r21, 0x70	; 112
     270:	50 37       	cpi	r21, 0x70	; 112
     272:	50 37       	cpi	r21, 0x70	; 112
     274:	50 37       	cpi	r21, 0x70	; 112
     276:	50 37       	cpi	r21, 0x70	; 112
     278:	50 37       	cpi	r21, 0x70	; 112
     27a:	50 37       	cpi	r21, 0x70	; 112
     27c:	50 37       	cpi	r21, 0x70	; 112
     27e:	50 37       	cpi	r21, 0x70	; 112
     280:	50 37       	cpi	r21, 0x70	; 112
     282:	50 37       	cpi	r21, 0x70	; 112
     284:	3c 37       	cpi	r19, 0x7C	; 124
     286:	62 37       	cpi	r22, 0x72	; 114
     288:	76 37       	cpi	r23, 0x76	; 118
     28a:	7a 37       	cpi	r23, 0x7A	; 122
     28c:	7e 37       	cpi	r23, 0x7E	; 126
     28e:	72 37       	cpi	r23, 0x72	; 114
     290:	7e 37       	cpi	r23, 0x7E	; 126
     292:	7e 37       	cpi	r23, 0x7E	; 126
     294:	7e 37       	cpi	r23, 0x7E	; 126
     296:	66 37       	cpi	r22, 0x76	; 118
     298:	7e 37       	cpi	r23, 0x7E	; 126
     29a:	7e 37       	cpi	r23, 0x7E	; 126
     29c:	7e 37       	cpi	r23, 0x7E	; 126
     29e:	7e 37       	cpi	r23, 0x7E	; 126
     2a0:	7e 37       	cpi	r23, 0x7E	; 126
     2a2:	7e 37       	cpi	r23, 0x7E	; 126
     2a4:	7e 37       	cpi	r23, 0x7E	; 126
     2a6:	6e 37       	cpi	r22, 0x7E	; 126
     2a8:	7e 37       	cpi	r23, 0x7E	; 126
     2aa:	7e 37       	cpi	r23, 0x7E	; 126
     2ac:	7e 37       	cpi	r23, 0x7E	; 126
     2ae:	7e 37       	cpi	r23, 0x7E	; 126
     2b0:	7e 37       	cpi	r23, 0x7E	; 126
     2b2:	7e 37       	cpi	r23, 0x7E	; 126
     2b4:	7e 37       	cpi	r23, 0x7E	; 126
     2b6:	7e 37       	cpi	r23, 0x7E	; 126
     2b8:	7e 37       	cpi	r23, 0x7E	; 126
     2ba:	7e 37       	cpi	r23, 0x7E	; 126
     2bc:	7e 37       	cpi	r23, 0x7E	; 126
     2be:	7e 37       	cpi	r23, 0x7E	; 126
     2c0:	7e 37       	cpi	r23, 0x7E	; 126
     2c2:	7e 37       	cpi	r23, 0x7E	; 126
     2c4:	7e 37       	cpi	r23, 0x7E	; 126
     2c6:	6a 37       	cpi	r22, 0x7A	; 122
     2c8:	08 4a       	sbci	r16, 0xA8	; 168
     2ca:	d7 3b       	cpi	r29, 0xB7	; 183
     2cc:	3b ce       	rjmp	.-906    	; 0xffffff44 <__eeprom_end+0xff7eff44>
     2ce:	01 6e       	ori	r16, 0xE1	; 225
     2d0:	84 bc       	out	0x24, r8	; 36
     2d2:	bf fd       	.word	0xfdbf	; ????
     2d4:	c1 2f       	mov	r28, r17
     2d6:	3d 6c       	ori	r19, 0xCD	; 205
     2d8:	74 31       	cpi	r23, 0x14	; 20
     2da:	9a bd       	out	0x2a, r25	; 42
     2dc:	56 83       	std	Z+6, r21	; 0x06
     2de:	3d da       	rcall	.-2950   	; 0xfffff75a <__eeprom_end+0xff7ef75a>
     2e0:	3d 00       	.word	0x003d	; ????
     2e2:	c7 7f       	andi	r28, 0xF7	; 247
     2e4:	11 be       	out	0x31, r1	; 49
     2e6:	d9 e4       	ldi	r29, 0x49	; 73
     2e8:	bb 4c       	sbci	r27, 0xCB	; 203
     2ea:	3e 91       	ld	r19, -X
     2ec:	6b aa       	std	Y+51, r6	; 0x33
     2ee:	aa be       	out	0x3a, r10	; 58
     2f0:	00 00       	nop
     2f2:	00 80       	ld	r0, Z
     2f4:	3f 05       	cpc	r19, r15
     2f6:	a8 4c       	sbci	r26, 0xC8	; 200
     2f8:	cd b2       	in	r12, 0x1d	; 29
     2fa:	d4 4e       	sbci	r29, 0xE4	; 228
     2fc:	b9 38       	cpi	r27, 0x89	; 137
     2fe:	36 a9       	ldd	r19, Z+54	; 0x36
     300:	02 0c       	add	r0, r2
     302:	50 b9       	out	0x00, r21	; 0
     304:	91 86       	std	Z+9, r9	; 0x09
     306:	88 08       	sbc	r8, r8
     308:	3c a6       	std	Y+44, r3	; 0x2c
     30a:	aa aa       	std	Y+50, r10	; 0x32
     30c:	2a be       	out	0x3a, r2	; 58
     30e:	00 00       	nop
     310:	00 80       	ld	r0, Z
     312:	3f 00       	.word	0x003f	; ????

00000314 <__trampolines_end>:
     314:	3e 0d       	add	r19, r14
     316:	0a 00       	.word	0x000a	; ????

00000318 <__c.2649>:
     318:	2c 52 58 3a 00                                      ,RX:.

0000031d <__c.2647>:
     31d:	2c 42 75 66 3a 00                                   ,Buf:.

00000323 <__c.2642>:
     323:	2c 00                                               ,.

00000325 <__c.2640>:
     325:	2c 57 50 6f 73 3a 00                                ,WPos:.

0000032c <__c.2635>:
     32c:	2c 00                                               ,.

0000032e <__c.2633>:
     32e:	2c 4d 50 6f 73 3a 00                                ,MPos:.

00000335 <__c.2631>:
     335:	3c 43 68 65 63 6b 00                                <Check.

0000033c <__c.2628>:
     33c:	3c 41 6c 61 72 6d 00                                <Alarm.

00000343 <__c.2625>:
     343:	3c 48 6f 6d 65 00                                   <Home.

00000349 <__c.2622>:
     349:	3c 48 6f 6c 64 00                                   <Hold.

0000034f <__c.2619>:
     34f:	3c 52 75 6e 00                                      <Run.

00000354 <__c.2616>:
     354:	3c 51 75 65 75 65 00                                <Queue.

0000035b <__c.2612>:
     35b:	3c 49 64 6c 65 00                                   <Idle.

00000361 <__c.2604>:
     361:	5d 0d 0a 00                                         ]...

00000365 <__c.2602>:
     365:	3a 00                                               :.

00000367 <__c.2600>:
     367:	5b 30 2e 39 67 2e 32 30 31 34 30 38 30 35 2e 30     [0.9g.20140805.0
     377:	2d 00                                               -.

00000379 <__c.2595>:
     379:	0d 0a 00                                            ...

0000037c <__c.2593>:
     37c:	3d 00                                               =.

0000037e <__c.2591>:
     37e:	24 4e 00                                            $N.

00000381 <__c.2585>:
     381:	5d 0d 0a 00                                         ]...

00000385 <__c.2583>:
     385:	20 46 00                                             F.

00000388 <__c.2581>:
     388:	20 48 00                                             H.

0000038b <__c.2579>:
     38b:	20 54 00                                             T.

0000038e <__c.2577>:
     38e:	20 4d 37 00                                          M7.

00000392 <__c.2574>:
     392:	20 4d 38 00                                          M8.

00000396 <__c.2570>:
     396:	20 4d 39 00                                          M9.

0000039a <__c.2567>:
     39a:	20 4d 35 00                                          M5.

0000039e <__c.2564>:
     39e:	20 4d 34 00                                          M4.

000003a2 <__c.2560>:
     3a2:	20 4d 33 00                                          M3.

000003a6 <__c.2557>:
     3a6:	20 4d 32 00                                          M2.

000003aa <__c.2554>:
     3aa:	20 4d 31 00                                          M1.

000003ae <__c.2550>:
     3ae:	20 4d 30 00                                          M0.

000003b2 <__c.2547>:
     3b2:	20 47 39 34 00                                       G94.

000003b7 <__c.2545>:
     3b7:	20 47 39 33 00                                       G93.

000003bc <__c.2543>:
     3bc:	20 47 39 31 00                                       G91.

000003c1 <__c.2541>:
     3c1:	20 47 39 30 00                                       G90.

000003c6 <__c.2539>:
     3c6:	20 47 32 30 00                                       G20.

000003cb <__c.2537>:
     3cb:	20 47 32 31 00                                       G21.

000003d0 <__c.2535>:
     3d0:	20 47 31 39 00                                       G19.

000003d5 <__c.2532>:
     3d5:	20 47 31 38 00                                       G18.

000003da <__c.2528>:
     3da:	20 47 31 37 00                                       G17.

000003df <__c.2525>:
     3df:	20 47 00                                             G.

000003e2 <__c.2523>:
     3e2:	5b 47 38 30 00                                      [G80.

000003e7 <__c.2520>:
     3e7:	5b 47 33 00                                         [G3.

000003eb <__c.2517>:
     3eb:	5b 47 32 00                                         [G2.

000003ef <__c.2514>:
     3ef:	5b 47 31 00                                         [G1.

000003f3 <__c.2510>:
     3f3:	5b 47 30 00                                         [G0.

000003f7 <__c.2502>:
     3f7:	5d 0d 0a 00                                         ]...

000003fb <__c.2497>:
     3fb:	2c 00                                               ,.

000003fd <__c.2495>:
     3fd:	20 58 59 5a 20 00                                    XYZ .

00000403 <__c.2493>:
     403:	20 52 00                                             R.

00000406 <__c.2491>:
     406:	5b 54 00                                            [T.

00000409 <__c.2486>:
     409:	5d 0d 0a 00                                         ]...

0000040d <__c.2484>:
     40d:	2c 00                                               ,.

0000040f <__c.2482>:
     40f:	5b 47 39 32 3a 00                                   [G92:.

00000415 <__c.2474>:
     415:	5d 0d 0a 00                                         ]...

00000419 <__c.2472>:
     419:	2c 00                                               ,.

0000041b <__c.2470>:
     41b:	3a 00                                               :.

0000041d <__c.2467>:
     41d:	33 30 00                                            30.

00000420 <__c.2463>:
     420:	32 38 00                                            28.

00000423 <__c.2460>:
     423:	5b 47 00                                            [G.

00000426 <__c.2453>:
     426:	5d 0d 0a 00                                         ]...

0000042a <__c.2448>:
     42a:	2c 00                                               ,.

0000042c <__c.2446>:
     42c:	5b 50 52 42 3a 00                                   [PRB:.

00000432 <__c.2434>:
     432:	29 0d 0a 00                                         )...

00000436 <__c.2432>:
     436:	20 6d 61 78 20 74 72 61 76 65 6c 2c 20 6d 6d 00      max travel, mm.

00000446 <__c.2429>:
     446:	20 61 63 63 65 6c 2c 20 6d 6d 2f 73 65 63 5e 32      accel, mm/sec^2
	...

00000457 <__c.2426>:
     457:	20 6d 61 78 20 72 61 74 65 2c 20 6d 6d 2f 6d 69      max rate, mm/mi
     467:	6e 00                                               n.

00000469 <__c.2422>:
     469:	2c 20 73 74 65 70 2f 6d 6d 00                       , step/mm.

00000473 <__c.2419>:
     473:	7a 00                                               z.

00000475 <__c.2416>:
     475:	79 00                                               y.

00000477 <__c.2412>:
     477:	78 00                                               x.

00000479 <__c.2409>:
     479:	20 28 00                                             (.

0000047c <__c.2402>:
     47c:	3d 00                                               =.

0000047e <__c.2400>:
     47e:	24 00                                               $.

00000480 <__c.2395>:
     480:	20 28 68 6f 6d 69 6e 67 20 70 75 6c 6c 2d 6f 66      (homing pull-of
     490:	66 2c 20 6d 6d 29 0d 0a 00                          f, mm)...

00000499 <__c.2393>:
     499:	20 28 68 6f 6d 69 6e 67 20 64 65 62 6f 75 6e 63      (homing debounc
     4a9:	65 2c 20 6d 73 65 63 29 0d 0a 24 32 37 3d 00        e, msec)..$27=.

000004b8 <__c.2391>:
     4b8:	20 28 68 6f 6d 69 6e 67 20 73 65 65 6b 2c 20 6d      (homing seek, m
     4c8:	6d 2f 6d 69 6e 29 0d 0a 24 32 36 3d 00              m/min)..$26=.

000004d5 <__c.2389>:
     4d5:	20 28 68 6f 6d 69 6e 67 20 66 65 65 64 2c 20 6d      (homing feed, m
     4e5:	6d 2f 6d 69 6e 29 0d 0a 24 32 35 3d 00              m/min)..$25=.

000004f2 <__c.2387>:
     4f2:	29 0d 0a 24 32 34 3d 00                             )..$24=.

000004fa <__c.2385>:
     4fa:	20 28 68 6f 6d 69 6e 67 20 64 69 72 20 69 6e 76      (homing dir inv
     50a:	65 72 74 20 6d 61 73 6b 3a 00                       ert mask:.

00000514 <__c.2383>:
     514:	20 28 68 6f 6d 69 6e 67 20 63 79 63 6c 65 2c 20      (homing cycle, 
     524:	62 6f 6f 6c 29 0d 0a 24 32 33 3d 00                 bool)..$23=.

00000530 <__c.2381>:
     530:	20 28 68 61 72 64 20 6c 69 6d 69 74 73 2c 20 62      (hard limits, b
     540:	6f 6f 6c 29 0d 0a 24 32 32 3d 00                    ool)..$22=.

0000054b <__c.2379>:
     54b:	20 28 73 6f 66 74 20 6c 69 6d 69 74 73 2c 20 62      (soft limits, b
     55b:	6f 6f 6c 29 0d 0a 24 32 31 3d 00                    ool)..$21=.

00000566 <__c.2377>:
     566:	20 28 61 75 74 6f 20 73 74 61 72 74 2c 20 62 6f      (auto start, bo
     576:	6f 6c 29 0d 0a 24 32 30 3d 00                       ol)..$20=.

00000580 <__c.2375>:
     580:	20 28 72 65 70 6f 72 74 20 69 6e 63 68 65 73 2c      (report inches,
     590:	20 62 6f 6f 6c 29 0d 0a 24 31 34 3d 00               bool)..$14=.

0000059d <__c.2373>:
     59d:	20 28 61 72 63 20 74 6f 6c 65 72 61 6e 63 65 2c      (arc tolerance,
     5ad:	20 6d 6d 29 0d 0a 24 31 33 3d 00                     mm)..$13=.

000005b8 <__c.2371>:
     5b8:	20 28 6a 75 6e 63 74 69 6f 6e 20 64 65 76 69 61      (junction devia
     5c8:	74 69 6f 6e 2c 20 6d 6d 29 0d 0a 24 31 32 3d 00     tion, mm)..$12=.

000005d8 <__c.2369>:
     5d8:	29 0d 0a 24 31 31 3d 00                             )..$11=.

000005e0 <__c.2367>:
     5e0:	20 28 73 74 61 74 75 73 20 72 65 70 6f 72 74 20      (status report 
     5f0:	6d 61 73 6b 3a 00                                   mask:.

000005f6 <__c.2365>:
     5f6:	20 28 70 72 6f 62 65 20 70 69 6e 20 69 6e 76 65      (probe pin inve
     606:	72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 31 30 3d 00     rt, bool)..$10=.

00000616 <__c.2363>:
     616:	20 28 6c 69 6d 69 74 20 70 69 6e 73 20 69 6e 76      (limit pins inv
     626:	65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 36 3d 00     ert, bool)..$6=.

00000636 <__c.2361>:
     636:	20 28 73 74 65 70 20 65 6e 61 62 6c 65 20 69 6e      (step enable in
     646:	76 65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 35 3d     vert, bool)..$5=
	...

00000657 <__c.2359>:
     657:	29 0d 0a 24 34 3d 00                                )..$4=.

0000065e <__c.2357>:
     65e:	20 28 64 69 72 20 70 6f 72 74 20 69 6e 76 65 72      (dir port inver
     66e:	74 20 6d 61 73 6b 3a 00                             t mask:.

00000676 <__c.2355>:
     676:	29 0d 0a 24 33 3d 00                                )..$3=.

0000067d <__c.2353>:
     67d:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     68d:	72 74 20 6d 61 73 6b 3a 00                          rt mask:.

00000696 <__c.2351>:
     696:	20 28 73 74 65 70 20 69 64 6c 65 20 64 65 6c 61      (step idle dela
     6a6:	79 2c 20 6d 73 65 63 29 0d 0a 24 32 3d 00           y, msec)..$2=.

000006b4 <__c.2349>:
     6b4:	20 28 73 74 65 70 20 70 75 6c 73 65 2c 20 75 73      (step pulse, us
     6c4:	65 63 29 0d 0a 24 31 3d 00                          ec)..$1=.

000006cd <__c.2347>:
     6cd:	24 30 3d 00                                         $0=.

000006d1 <__c.2343>:
     6d1:	24 24 20 28 76 69 65 77 20 47 72 62 6c 20 73 65     $$ (view Grbl se
     6e1:	74 74 69 6e 67 73 29 0d 0a 24 23 20 28 76 69 65     ttings)..$# (vie
     6f1:	77 20 23 20 70 61 72 61 6d 65 74 65 72 73 29 0d     w # parameters).
     701:	0a 24 47 20 28 76 69 65 77 20 70 61 72 73 65 72     .$G (view parser
     711:	20 73 74 61 74 65 29 0d 0a 24 49 20 28 76 69 65      state)..$I (vie
     721:	77 20 62 75 69 6c 64 20 69 6e 66 6f 29 0d 0a 24     w build info)..$
     731:	4e 20 28 76 69 65 77 20 73 74 61 72 74 75 70 20     N (view startup 
     741:	62 6c 6f 63 6b 73 29 0d 0a 24 78 3d 76 61 6c 75     blocks)..$x=valu
     751:	65 20 28 73 61 76 65 20 47 72 62 6c 20 73 65 74     e (save Grbl set
     761:	74 69 6e 67 29 0d 0a 24 4e 78 3d 6c 69 6e 65 20     ting)..$Nx=line 
     771:	28 73 61 76 65 20 73 74 61 72 74 75 70 20 62 6c     (save startup bl
     781:	6f 63 6b 29 0d 0a 24 43 20 28 63 68 65 63 6b 20     ock)..$C (check 
     791:	67 63 6f 64 65 20 6d 6f 64 65 29 0d 0a 24 58 20     gcode mode)..$X 
     7a1:	28 6b 69 6c 6c 20 61 6c 61 72 6d 20 6c 6f 63 6b     (kill alarm lock
     7b1:	29 0d 0a 24 48 20 28 72 75 6e 20 68 6f 6d 69 6e     )..$H (run homin
     7c1:	67 20 63 79 63 6c 65 29 0d 0a 7e 20 28 63 79 63     g cycle)..~ (cyc
     7d1:	6c 65 20 73 74 61 72 74 29 0d 0a 21 20 28 66 65     le start)..! (fe
     7e1:	65 64 20 68 6f 6c 64 29 0d 0a 3f 20 28 63 75 72     ed hold)..? (cur
     7f1:	72 65 6e 74 20 73 74 61 74 75 73 29 0d 0a 63 74     rent status)..ct
     801:	72 6c 2d 78 20 28 72 65 73 65 74 20 47 72 62 6c     rl-x (reset Grbl
     811:	29 0d 0a 00                                         )...

00000815 <__c.2339>:
     815:	0d 0a 47 72 62 6c 20 30 2e 39 67 20 5b 32 30 31     ..Grbl 0.9g [201
     825:	34 30 38 30 35 2e 30 5d 20 5b 27 24 27 20 66 6f     40805.0] ['$' fo
     835:	72 20 68 65 6c 70 5d 0d 0a 00                       r help]...

0000083f <__c.2335>:
     83f:	5d 0d 0a 00                                         ]...

00000843 <__c.2333>:
     843:	44 69 73 61 62 6c 65 64 00                          Disabled.

0000084c <__c.2330>:
     84c:	45 6e 61 62 6c 65 64 00                             Enabled.

00000854 <__c.2327>:
     854:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     864:	64 00                                               d.

00000866 <__c.2324>:
     866:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     876:	6f 63 6b 00                                         ock.

0000087a <__c.2320>:
     87a:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     88a:	65 00                                               e.

0000088c <__c.2317>:
     88c:	5b 00                                               [.

0000088e <__c.2312>:
     88e:	0d 0a 00                                            ...

00000891 <__c.2310>:
     891:	50 72 6f 62 65 20 66 61 69 6c 00                    Probe fail.

0000089c <__c.2307>:
     89c:	41 62 6f 72 74 20 64 75 72 69 6e 67 20 63 79 63     Abort during cyc
     8ac:	6c 65 00                                            le.

000008af <__c.2303>:
     8af:	48 61 72 64 2f 73 6f 66 74 20 6c 69 6d 69 74 00     Hard/soft limit.

000008bf <__c.2300>:
     8bf:	41 4c 41 52 4d 3a 20 00                             ALARM: .

000008c7 <__c.2295>:
     8c7:	0d 0a 00                                            ...

000008ca <__c.2293>:
     8ca:	49 6e 76 61 6c 69 64 20 67 63 6f 64 65 20 49 44     Invalid gcode ID
     8da:	3a 00                                               :.

000008dc <__c.2290>:
     8dc:	55 6e 64 65 66 69 6e 65 64 20 66 65 65 64 20 72     Undefined feed r
     8ec:	61 74 65 00                                         ate.

000008f0 <__c.2287>:
     8f0:	55 6e 73 75 70 70 6f 72 74 65 64 20 63 6f 6d 6d     Unsupported comm
     900:	61 6e 64 00                                         and.

00000904 <__c.2284>:
     904:	4d 6f 64 61 6c 20 67 72 6f 75 70 20 76 69 6f 6c     Modal group viol
     914:	61 74 69 6f 6e 00                                   ation.

0000091a <__c.2281>:
     91a:	4c 69 6e 65 20 6f 76 65 72 66 6c 6f 77 00           Line overflow.

00000928 <__c.2278>:
     928:	48 6f 6d 69 6e 67 20 6e 6f 74 20 65 6e 61 62 6c     Homing not enabl
     938:	65 64 00                                            ed.

0000093b <__c.2275>:
     93b:	41 6c 61 72 6d 20 6c 6f 63 6b 00                    Alarm lock.

00000946 <__c.2272>:
     946:	4e 6f 74 20 69 64 6c 65 00                          Not idle.

0000094f <__c.2269>:
     94f:	45 45 50 52 4f 4d 20 72 65 61 64 20 66 61 69 6c     EEPROM read fail
     95f:	2e 20 55 73 69 6e 67 20 64 65 66 61 75 6c 74 73     . Using defaults
	...

00000970 <__c.2266>:
     970:	56 61 6c 75 65 20 3c 20 33 20 75 73 65 63 00        Value < 3 usec.

0000097f <__c.2263>:
     97f:	53 65 74 74 69 6e 67 20 64 69 73 61 62 6c 65 64     Setting disabled
	...

00000990 <__c.2260>:
     990:	56 61 6c 75 65 20 3c 20 30 00                       Value < 0.

0000099a <__c.2257>:
     99a:	49 6e 76 61 6c 69 64 20 73 74 61 74 65 6d 65 6e     Invalid statemen
     9aa:	74 00                                               t.

000009ac <__c.2254>:
     9ac:	42 61 64 20 6e 75 6d 62 65 72 20 66 6f 72 6d 61     Bad number forma
     9bc:	74 00                                               t.

000009be <__c.2250>:
     9be:	45 78 70 65 63 74 65 64 20 63 6f 6d 6d 61 6e 64     Expected command
     9ce:	20 6c 65 74 74 65 72 00                              letter.

000009d6 <__c.2247>:
     9d6:	65 72 72 6f 72 3a 20 00                             error: .

000009de <__c.2245>:
     9de:	6f 6b 0d 0a 00 00                                   ok....

000009e4 <__ctors_end>:
     9e4:	11 24       	eor	r1, r1
     9e6:	1f be       	out	0x3f, r1	; 63
     9e8:	cf ef       	ldi	r28, 0xFF	; 255
     9ea:	d8 e0       	ldi	r29, 0x08	; 8
     9ec:	de bf       	out	0x3e, r29	; 62
     9ee:	cd bf       	out	0x3d, r28	; 61

000009f0 <__do_copy_data>:
     9f0:	11 e0       	ldi	r17, 0x01	; 1
     9f2:	a0 e0       	ldi	r26, 0x00	; 0
     9f4:	b1 e0       	ldi	r27, 0x01	; 1
     9f6:	e2 e6       	ldi	r30, 0x62	; 98
     9f8:	f9 e7       	ldi	r31, 0x79	; 121
     9fa:	02 c0       	rjmp	.+4      	; 0xa00 <__do_copy_data+0x10>
     9fc:	05 90       	lpm	r0, Z+
     9fe:	0d 92       	st	X+, r0
     a00:	a6 30       	cpi	r26, 0x06	; 6
     a02:	b1 07       	cpc	r27, r17
     a04:	d9 f7       	brne	.-10     	; 0x9fc <__do_copy_data+0xc>

00000a06 <__do_clear_bss>:
     a06:	27 e0       	ldi	r18, 0x07	; 7
     a08:	a6 e0       	ldi	r26, 0x06	; 6
     a0a:	b1 e0       	ldi	r27, 0x01	; 1
     a0c:	01 c0       	rjmp	.+2      	; 0xa10 <.do_clear_bss_start>

00000a0e <.do_clear_bss_loop>:
     a0e:	1d 92       	st	X+, r1

00000a10 <.do_clear_bss_start>:
     a10:	a0 39       	cpi	r26, 0x90	; 144
     a12:	b2 07       	cpc	r27, r18
     a14:	e1 f7       	brne	.-8      	; 0xa0e <.do_clear_bss_loop>
     a16:	0e 94 11 05 	call	0xa22	; 0xa22 <main>
     a1a:	0c 94 af 3c 	jmp	0x795e	; 0x795e <_exit>

00000a1e <__bad_interrupt>:
     a1e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000a22 <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
     a22:	0e 94 78 15 	call	0x2af0	; 0x2af0 <serial_init>
  settings_init(); // Load grbl settings from EEPROM
     a26:	0e 94 19 25 	call	0x4a32	; 0x4a32 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
     a2a:	0e 94 a5 1a 	call	0x354a	; 0x354a <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
     a2e:	0e 94 1d 35 	call	0x6a3a	; 0x6a3a <system_init>

  status_init();
     a32:	0e 94 fd 36 	call	0x6dfa	; 0x6dfa <status_init>
  TWI_init();
     a36:	0e 94 94 37 	call	0x6f28	; 0x6f28 <TWI_init>
  
  memset(&sys, 0, sizeof(sys));  // Clear all system variables
     a3a:	e3 e8       	ldi	r30, 0x83	; 131
     a3c:	f5 e0       	ldi	r31, 0x05	; 5
     a3e:	8e e1       	ldi	r24, 0x1E	; 30
     a40:	df 01       	movw	r26, r30
     a42:	1d 92       	st	X+, r1
     a44:	8a 95       	dec	r24
     a46:	e9 f7       	brne	.-6      	; 0xa42 <main+0x20>
  sys.abort = true;   // Set abort to complete initialization
     a48:	81 e0       	ldi	r24, 0x01	; 1
     a4a:	80 83       	st	Z, r24
  sei(); // Enable interrupts
     a4c:	78 94       	sei
  // cycle '$H' or kill alarm locks '$X' will disable the alarm.
  // NOTE: The startup script will run after successful completion of the homing cycle, but
  // not after disabling the alarm locks. Prevents motion startup blocks from crashing into
  // things uncontrollably. Very bad.
  #ifdef HOMING_INIT_LOCK
    if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { sys.state = STATE_ALARM; }
     a4e:	80 91 7d 07 	lds	r24, 0x077D
     a52:	84 ff       	sbrs	r24, 4
     a54:	03 c0       	rjmp	.+6      	; 0xa5c <main+0x3a>
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	80 93 84 05 	sts	0x0584, r24
    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    gc_sync_position();

    // Reset system variables.
    sys.abort = false;
     a5c:	0f 2e       	mov	r0, r31
     a5e:	f3 e8       	ldi	r31, 0x83	; 131
     a60:	cf 2e       	mov	r12, r31
     a62:	f5 e0       	ldi	r31, 0x05	; 5
     a64:	df 2e       	mov	r13, r31
     a66:	f0 2d       	mov	r31, r0
    sys.execute = 0;
     a68:	0f 2e       	mov	r0, r31
     a6a:	f5 e8       	ldi	r31, 0x85	; 133
     a6c:	ef 2e       	mov	r14, r31
     a6e:	f5 e0       	ldi	r31, 0x05	; 5
     a70:	ff 2e       	mov	r15, r31
     a72:	f0 2d       	mov	r31, r0
    if (bit_istrue(settings.flags,BITFLAG_AUTO_START)) { sys.auto_start = true; }
     a74:	0d e7       	ldi	r16, 0x7D	; 125
     a76:	17 e0       	ldi	r17, 0x07	; 7
    else { sys.auto_start = false; }
     a78:	c3 e9       	ldi	r28, 0x93	; 147
     a7a:	d5 e0       	ldi	r29, 0x05	; 5
    gc_sync_position();

    // Reset system variables.
    sys.abort = false;
    sys.execute = 0;
    if (bit_istrue(settings.flags,BITFLAG_AUTO_START)) { sys.auto_start = true; }
     a7c:	bb 24       	eor	r11, r11
     a7e:	b3 94       	inc	r11

    // TODO: Separate configure task that require interrupts to be disabled, especially upon
    // a system abort and ensuring any active interrupts are cleanly reset.
  
    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
     a80:	0e 94 49 16 	call	0x2c92	; 0x2c92 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
     a84:	0e 94 f5 09 	call	0x13ea	; 0x13ea <gc_init>
    spindle_init();
     a88:	0e 94 29 15 	call	0x2a52	; 0x2a52 <spindle_init>
    coolant_init();
     a8c:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <coolant_init>
    limits_init(); 
     a90:	0e 94 24 2b 	call	0x5648	; 0x5648 <limits_init>
    probe_init();
     a94:	0e 94 80 2f 	call	0x5f00	; 0x5f00 <probe_init>
    plan_reset(); // Clear block buffer and planner variables
     a98:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
     a9c:	0e 94 32 1a 	call	0x3464	; 0x3464 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
     aa0:	0e 94 d5 29 	call	0x53aa	; 0x53aa <plan_sync_position>
    gc_sync_position();
     aa4:	0e 94 1b 0a 	call	0x1436	; 0x1436 <gc_sync_position>

    // Reset system variables.
    sys.abort = false;
     aa8:	f6 01       	movw	r30, r12
     aaa:	10 82       	st	Z, r1
    sys.execute = 0;
     aac:	d7 01       	movw	r26, r14
     aae:	1c 92       	st	X, r1
    if (bit_istrue(settings.flags,BITFLAG_AUTO_START)) { sys.auto_start = true; }
     ab0:	f8 01       	movw	r30, r16
     ab2:	80 81       	ld	r24, Z
     ab4:	81 ff       	sbrs	r24, 1
     ab6:	02 c0       	rjmp	.+4      	; 0xabc <main+0x9a>
     ab8:	b8 82       	st	Y, r11
     aba:	01 c0       	rjmp	.+2      	; 0xabe <main+0x9c>
    else { sys.auto_start = false; }
     abc:	18 82       	st	Y, r1
          
    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
     abe:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <protocol_main_loop>
    
  }
     ac2:	de cf       	rjmp	.-68     	; 0xa80 <main+0x5e>

00000ac4 <mc_line>:
#ifdef USE_LINE_NUMBERS
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{
     ac4:	bf 92       	push	r11
     ac6:	cf 92       	push	r12
     ac8:	df 92       	push	r13
     aca:	ef 92       	push	r14
     acc:	ff 92       	push	r15
     ace:	0f 93       	push	r16
     ad0:	1f 93       	push	r17
     ad2:	cf 93       	push	r28
     ad4:	df 93       	push	r29
     ad6:	8c 01       	movw	r16, r24
     ad8:	6a 01       	movw	r12, r20
     ada:	7b 01       	movw	r14, r22
     adc:	b2 2e       	mov	r11, r18
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) { limits_soft_check(target); }    
     ade:	80 91 7d 07 	lds	r24, 0x077D
     ae2:	85 ff       	sbrs	r24, 5
     ae4:	03 c0       	rjmp	.+6      	; 0xaec <mc_line+0x28>
     ae6:	c8 01       	movw	r24, r16
     ae8:	0e 94 ae 2d 	call	0x5b5c	; 0x5b5c <limits_soft_check>
      
  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
     aec:	80 91 84 05 	lds	r24, 0x0584
     af0:	82 30       	cpi	r24, 0x02	; 2
     af2:	d9 f0       	breq	.+54     	; 0xb2a <mc_line+0x66>

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_runtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
     af4:	c3 e8       	ldi	r28, 0x83	; 131
     af6:	d5 e0       	ldi	r29, 0x05	; 5
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_runtime(); // Check for any run-time commands
     af8:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
    if (sys.abort) { return; } // Bail, if system abort.
     afc:	88 81       	ld	r24, Y
     afe:	81 11       	cpse	r24, r1
     b00:	14 c0       	rjmp	.+40     	; 0xb2a <mc_line+0x66>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
     b02:	0e 94 ec 26 	call	0x4dd8	; 0x4dd8 <plan_check_full_buffer>
     b06:	88 23       	and	r24, r24
     b08:	19 f0       	breq	.+6      	; 0xb10 <mc_line+0x4c>
     b0a:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <protocol_auto_cycle_start>
    else { break; }
  } while (1);
     b0e:	f4 cf       	rjmp	.-24     	; 0xaf8 <mc_line+0x34>

  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    plan_buffer_line(target, feed_rate, invert_feed_rate);
     b10:	2b 2d       	mov	r18, r11
     b12:	b7 01       	movw	r22, r14
     b14:	a6 01       	movw	r20, r12
     b16:	c8 01       	movw	r24, r16
     b18:	0e 94 f4 26 	call	0x4de8	; 0x4de8 <plan_buffer_line>
  #endif
  
  // If idle, indicate to the system there is now a planned block in the buffer ready to cycle 
  // start. Otherwise ignore and continue on.
  if (!sys.state) { sys.state = STATE_QUEUED; }
     b1c:	80 91 84 05 	lds	r24, 0x0584
     b20:	81 11       	cpse	r24, r1
     b22:	03 c0       	rjmp	.+6      	; 0xb2a <mc_line+0x66>
     b24:	88 e0       	ldi	r24, 0x08	; 8
     b26:	80 93 84 05 	sts	0x0584, r24
}
     b2a:	df 91       	pop	r29
     b2c:	cf 91       	pop	r28
     b2e:	1f 91       	pop	r17
     b30:	0f 91       	pop	r16
     b32:	ff 90       	pop	r15
     b34:	ef 90       	pop	r14
     b36:	df 90       	pop	r13
     b38:	cf 90       	pop	r12
     b3a:	bf 90       	pop	r11
     b3c:	08 95       	ret

00000b3e <mc_arc>:
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, int32_t line_number)
#else
  void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate,
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear)
#endif
{
     b3e:	2f 92       	push	r2
     b40:	3f 92       	push	r3
     b42:	4f 92       	push	r4
     b44:	5f 92       	push	r5
     b46:	6f 92       	push	r6
     b48:	7f 92       	push	r7
     b4a:	8f 92       	push	r8
     b4c:	9f 92       	push	r9
     b4e:	af 92       	push	r10
     b50:	bf 92       	push	r11
     b52:	cf 92       	push	r12
     b54:	df 92       	push	r13
     b56:	ef 92       	push	r14
     b58:	ff 92       	push	r15
     b5a:	0f 93       	push	r16
     b5c:	1f 93       	push	r17
     b5e:	cf 93       	push	r28
     b60:	df 93       	push	r29
     b62:	cd b7       	in	r28, 0x3d	; 61
     b64:	de b7       	in	r29, 0x3e	; 62
     b66:	e9 97       	sbiw	r28, 0x39	; 57
     b68:	0f b6       	in	r0, 0x3f	; 63
     b6a:	f8 94       	cli
     b6c:	de bf       	out	0x3e, r29	; 62
     b6e:	0f be       	out	0x3f, r0	; 63
     b70:	cd bf       	out	0x3d, r28	; 61
     b72:	9a 8b       	std	Y+18, r25	; 0x12
     b74:	89 8b       	std	Y+17, r24	; 0x11
     b76:	79 af       	std	Y+57, r23	; 0x39
     b78:	68 af       	std	Y+56, r22	; 0x38
     b7a:	3a 01       	movw	r6, r20
     b7c:	09 87       	std	Y+9, r16	; 0x09
     b7e:	1a 87       	std	Y+10, r17	; 0x0a
     b80:	2b 87       	std	Y+11, r18	; 0x0b
     b82:	3c 87       	std	Y+12, r19	; 0x0c
     b84:	ab 8a       	std	Y+19, r10	; 0x13
  float center_axis0 = position[axis_0] + offset[axis_0];
     b86:	48 2c       	mov	r4, r8
     b88:	51 2c       	mov	r5, r1
     b8a:	12 01       	movw	r2, r4
     b8c:	22 0c       	add	r2, r2
     b8e:	33 1c       	adc	r3, r3
     b90:	22 0c       	add	r2, r2
     b92:	33 1c       	adc	r3, r3
     b94:	82 0d       	add	r24, r2
     b96:	93 1d       	adc	r25, r3
     b98:	9d 8b       	std	Y+21, r25	; 0x15
     b9a:	8c 8b       	std	Y+20, r24	; 0x14
     b9c:	9a 01       	movw	r18, r20
     b9e:	22 0d       	add	r18, r2
     ba0:	33 1d       	adc	r19, r3
     ba2:	3d ab       	std	Y+53, r19	; 0x35
     ba4:	2c ab       	std	Y+52, r18	; 0x34
     ba6:	d9 01       	movw	r26, r18
     ba8:	8d 90       	ld	r8, X+
     baa:	9d 90       	ld	r9, X+
     bac:	ad 90       	ld	r10, X+
     bae:	bc 90       	ld	r11, X
     bb0:	fc 01       	movw	r30, r24
     bb2:	20 81       	ld	r18, Z
     bb4:	31 81       	ldd	r19, Z+1	; 0x01
     bb6:	42 81       	ldd	r20, Z+2	; 0x02
     bb8:	53 81       	ldd	r21, Z+3	; 0x03
     bba:	c5 01       	movw	r24, r10
     bbc:	b4 01       	movw	r22, r8
     bbe:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
     bc2:	6e 8b       	std	Y+22, r22	; 0x16
     bc4:	7f 8b       	std	Y+23, r23	; 0x17
     bc6:	88 8f       	std	Y+24, r24	; 0x18
     bc8:	99 8f       	std	Y+25, r25	; 0x19
  float center_axis1 = position[axis_1] + offset[axis_1];
     bca:	2f 96       	adiw	r28, 0x0f	; 15
     bcc:	0f ad       	ldd	r16, Y+63	; 0x3f
     bce:	2f 97       	sbiw	r28, 0x0f	; 15
     bd0:	10 e0       	ldi	r17, 0x00	; 0
     bd2:	00 0f       	add	r16, r16
     bd4:	11 1f       	adc	r17, r17
     bd6:	00 0f       	add	r16, r16
     bd8:	11 1f       	adc	r17, r17
     bda:	29 89       	ldd	r18, Y+17	; 0x11
     bdc:	3a 89       	ldd	r19, Y+18	; 0x12
     bde:	20 0f       	add	r18, r16
     be0:	31 1f       	adc	r19, r17
     be2:	3b 8f       	std	Y+27, r19	; 0x1b
     be4:	2a 8f       	std	Y+26, r18	; 0x1a
     be6:	a3 01       	movw	r20, r6
     be8:	40 0f       	add	r20, r16
     bea:	51 1f       	adc	r21, r17
     bec:	5f ab       	std	Y+55, r21	; 0x37
     bee:	4e ab       	std	Y+54, r20	; 0x36
     bf0:	da 01       	movw	r26, r20
     bf2:	8d 91       	ld	r24, X+
     bf4:	9d 91       	ld	r25, X+
     bf6:	0d 90       	ld	r0, X+
     bf8:	bc 91       	ld	r27, X
     bfa:	a0 2d       	mov	r26, r0
     bfc:	89 83       	std	Y+1, r24	; 0x01
     bfe:	9a 83       	std	Y+2, r25	; 0x02
     c00:	ab 83       	std	Y+3, r26	; 0x03
     c02:	bc 83       	std	Y+4, r27	; 0x04
     c04:	f9 01       	movw	r30, r18
     c06:	20 81       	ld	r18, Z
     c08:	31 81       	ldd	r19, Z+1	; 0x01
     c0a:	42 81       	ldd	r20, Z+2	; 0x02
     c0c:	53 81       	ldd	r21, Z+3	; 0x03
     c0e:	bc 01       	movw	r22, r24
     c10:	cd 01       	movw	r24, r26
     c12:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
     c16:	6c 8f       	std	Y+28, r22	; 0x1c
     c18:	7d 8f       	std	Y+29, r23	; 0x1d
     c1a:	8e 8f       	std	Y+30, r24	; 0x1e
     c1c:	9f 8f       	std	Y+31, r25	; 0x1f
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
     c1e:	24 01       	movw	r4, r8
     c20:	35 01       	movw	r6, r10
     c22:	77 fa       	bst	r7, 7
     c24:	70 94       	com	r7
     c26:	77 f8       	bld	r7, 7
     c28:	70 94       	com	r7
  float r_axis1 = -offset[axis_1];
     c2a:	89 80       	ldd	r8, Y+1	; 0x01
     c2c:	9a 80       	ldd	r9, Y+2	; 0x02
     c2e:	ab 80       	ldd	r10, Y+3	; 0x03
     c30:	bc 80       	ldd	r11, Y+4	; 0x04
     c32:	b7 fa       	bst	r11, 7
     c34:	b0 94       	com	r11
     c36:	b7 f8       	bld	r11, 7
     c38:	b0 94       	com	r11
  float rt_axis0 = target[axis_0] - center_axis0;
     c3a:	e8 ad       	ldd	r30, Y+56	; 0x38
     c3c:	f9 ad       	ldd	r31, Y+57	; 0x39
     c3e:	e2 0d       	add	r30, r2
     c40:	f3 1d       	adc	r31, r3
     c42:	2e 89       	ldd	r18, Y+22	; 0x16
     c44:	3f 89       	ldd	r19, Y+23	; 0x17
     c46:	48 8d       	ldd	r20, Y+24	; 0x18
     c48:	59 8d       	ldd	r21, Y+25	; 0x19
     c4a:	60 81       	ld	r22, Z
     c4c:	71 81       	ldd	r23, Z+1	; 0x01
     c4e:	82 81       	ldd	r24, Z+2	; 0x02
     c50:	93 81       	ldd	r25, Z+3	; 0x03
     c52:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
     c56:	69 83       	std	Y+1, r22	; 0x01
     c58:	7a 83       	std	Y+2, r23	; 0x02
     c5a:	8b 83       	std	Y+3, r24	; 0x03
     c5c:	9c 83       	std	Y+4, r25	; 0x04
  float rt_axis1 = target[axis_1] - center_axis1;
     c5e:	e8 ad       	ldd	r30, Y+56	; 0x38
     c60:	f9 ad       	ldd	r31, Y+57	; 0x39
     c62:	e0 0f       	add	r30, r16
     c64:	f1 1f       	adc	r31, r17
     c66:	2c 8d       	ldd	r18, Y+28	; 0x1c
     c68:	3d 8d       	ldd	r19, Y+29	; 0x1d
     c6a:	4e 8d       	ldd	r20, Y+30	; 0x1e
     c6c:	5f 8d       	ldd	r21, Y+31	; 0x1f
     c6e:	60 81       	ld	r22, Z
     c70:	71 81       	ldd	r23, Z+1	; 0x01
     c72:	82 81       	ldd	r24, Z+2	; 0x02
     c74:	93 81       	ldd	r25, Z+3	; 0x03
     c76:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
     c7a:	6d 83       	std	Y+5, r22	; 0x05
     c7c:	7e 83       	std	Y+6, r23	; 0x06
     c7e:	8f 83       	std	Y+7, r24	; 0x07
     c80:	98 87       	std	Y+8, r25	; 0x08
  
  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
     c82:	29 81       	ldd	r18, Y+1	; 0x01
     c84:	3a 81       	ldd	r19, Y+2	; 0x02
     c86:	4b 81       	ldd	r20, Y+3	; 0x03
     c88:	5c 81       	ldd	r21, Y+4	; 0x04
     c8a:	c3 01       	movw	r24, r6
     c8c:	b2 01       	movw	r22, r4
     c8e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     c92:	6d 87       	std	Y+13, r22	; 0x0d
     c94:	7e 87       	std	Y+14, r23	; 0x0e
     c96:	8f 87       	std	Y+15, r24	; 0x0f
     c98:	98 8b       	std	Y+16, r25	; 0x10
     c9a:	2d 81       	ldd	r18, Y+5	; 0x05
     c9c:	3e 81       	ldd	r19, Y+6	; 0x06
     c9e:	4f 81       	ldd	r20, Y+7	; 0x07
     ca0:	58 85       	ldd	r21, Y+8	; 0x08
     ca2:	c5 01       	movw	r24, r10
     ca4:	b4 01       	movw	r22, r8
     ca6:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     caa:	9b 01       	movw	r18, r22
     cac:	ac 01       	movw	r20, r24
     cae:	6d 85       	ldd	r22, Y+13	; 0x0d
     cb0:	7e 85       	ldd	r23, Y+14	; 0x0e
     cb2:	8f 85       	ldd	r24, Y+15	; 0x0f
     cb4:	98 89       	ldd	r25, Y+16	; 0x10
     cb6:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
     cba:	6d 87       	std	Y+13, r22	; 0x0d
     cbc:	7e 87       	std	Y+14, r23	; 0x0e
     cbe:	8f 87       	std	Y+15, r24	; 0x0f
     cc0:	98 8b       	std	Y+16, r25	; 0x10
     cc2:	2d 81       	ldd	r18, Y+5	; 0x05
     cc4:	3e 81       	ldd	r19, Y+6	; 0x06
     cc6:	4f 81       	ldd	r20, Y+7	; 0x07
     cc8:	58 85       	ldd	r21, Y+8	; 0x08
     cca:	c3 01       	movw	r24, r6
     ccc:	b2 01       	movw	r22, r4
     cce:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     cd2:	6d 83       	std	Y+5, r22	; 0x05
     cd4:	7e 83       	std	Y+6, r23	; 0x06
     cd6:	8f 83       	std	Y+7, r24	; 0x07
     cd8:	98 87       	std	Y+8, r25	; 0x08
     cda:	29 81       	ldd	r18, Y+1	; 0x01
     cdc:	3a 81       	ldd	r19, Y+2	; 0x02
     cde:	4b 81       	ldd	r20, Y+3	; 0x03
     ce0:	5c 81       	ldd	r21, Y+4	; 0x04
     ce2:	c5 01       	movw	r24, r10
     ce4:	b4 01       	movw	r22, r8
     ce6:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     cea:	9b 01       	movw	r18, r22
     cec:	ac 01       	movw	r20, r24
     cee:	6d 81       	ldd	r22, Y+5	; 0x05
     cf0:	7e 81       	ldd	r23, Y+6	; 0x06
     cf2:	8f 81       	ldd	r24, Y+7	; 0x07
     cf4:	98 85       	ldd	r25, Y+8	; 0x08
     cf6:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
     cfa:	2d 85       	ldd	r18, Y+13	; 0x0d
     cfc:	3e 85       	ldd	r19, Y+14	; 0x0e
     cfe:	4f 85       	ldd	r20, Y+15	; 0x0f
     d00:	58 89       	ldd	r21, Y+16	; 0x10
     d02:	0e 94 f6 38 	call	0x71ec	; 0x71ec <atan2>
     d06:	69 83       	std	Y+1, r22	; 0x01
     d08:	7a 83       	std	Y+2, r23	; 0x02
     d0a:	8b 83       	std	Y+3, r24	; 0x03
     d0c:	9c 83       	std	Y+4, r25	; 0x04
  if (gc_state.modal.motion == MOTION_MODE_CW_ARC) { // Correct atan2 output per direction
     d0e:	80 91 bd 05 	lds	r24, 0x05BD
     d12:	82 30       	cpi	r24, 0x02	; 2
     d14:	d1 f4       	brne	.+52     	; 0xd4a <mc_arc+0x20c>
    if (angular_travel >= 0) { angular_travel -= 2*M_PI; }
     d16:	20 e0       	ldi	r18, 0x00	; 0
     d18:	30 e0       	ldi	r19, 0x00	; 0
     d1a:	a9 01       	movw	r20, r18
     d1c:	69 81       	ldd	r22, Y+1	; 0x01
     d1e:	7a 81       	ldd	r23, Y+2	; 0x02
     d20:	8b 81       	ldd	r24, Y+3	; 0x03
     d22:	9c 81       	ldd	r25, Y+4	; 0x04
     d24:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
     d28:	88 23       	and	r24, r24
     d2a:	44 f1       	brlt	.+80     	; 0xd7c <mc_arc+0x23e>
     d2c:	2b ed       	ldi	r18, 0xDB	; 219
     d2e:	3f e0       	ldi	r19, 0x0F	; 15
     d30:	49 ec       	ldi	r20, 0xC9	; 201
     d32:	50 e4       	ldi	r21, 0x40	; 64
     d34:	69 81       	ldd	r22, Y+1	; 0x01
     d36:	7a 81       	ldd	r23, Y+2	; 0x02
     d38:	8b 81       	ldd	r24, Y+3	; 0x03
     d3a:	9c 81       	ldd	r25, Y+4	; 0x04
     d3c:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
     d40:	69 83       	std	Y+1, r22	; 0x01
     d42:	7a 83       	std	Y+2, r23	; 0x02
     d44:	8b 83       	std	Y+3, r24	; 0x03
     d46:	9c 83       	std	Y+4, r25	; 0x04
     d48:	19 c0       	rjmp	.+50     	; 0xd7c <mc_arc+0x23e>
  } else {
    if (angular_travel <= 0) { angular_travel += 2*M_PI; }
     d4a:	20 e0       	ldi	r18, 0x00	; 0
     d4c:	30 e0       	ldi	r19, 0x00	; 0
     d4e:	a9 01       	movw	r20, r18
     d50:	69 81       	ldd	r22, Y+1	; 0x01
     d52:	7a 81       	ldd	r23, Y+2	; 0x02
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
     d5c:	18 16       	cp	r1, r24
     d5e:	74 f0       	brlt	.+28     	; 0xd7c <mc_arc+0x23e>
     d60:	2b ed       	ldi	r18, 0xDB	; 219
     d62:	3f e0       	ldi	r19, 0x0F	; 15
     d64:	49 ec       	ldi	r20, 0xC9	; 201
     d66:	50 e4       	ldi	r21, 0x40	; 64
     d68:	69 81       	ldd	r22, Y+1	; 0x01
     d6a:	7a 81       	ldd	r23, Y+2	; 0x02
     d6c:	8b 81       	ldd	r24, Y+3	; 0x03
     d6e:	9c 81       	ldd	r25, Y+4	; 0x04
     d70:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
     d74:	69 83       	std	Y+1, r22	; 0x01
     d76:	7a 83       	std	Y+2, r23	; 0x02
     d78:	8b 83       	std	Y+3, r24	; 0x03
     d7a:	9c 83       	std	Y+4, r25	; 0x04
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
     d7c:	20 91 79 07 	lds	r18, 0x0779
     d80:	30 91 7a 07 	lds	r19, 0x077A
     d84:	40 91 7b 07 	lds	r20, 0x077B
     d88:	50 91 7c 07 	lds	r21, 0x077C
     d8c:	2d 83       	std	Y+5, r18	; 0x05
     d8e:	3e 83       	std	Y+6, r19	; 0x06
     d90:	4f 83       	std	Y+7, r20	; 0x07
     d92:	58 87       	std	Y+8, r21	; 0x08
     d94:	29 85       	ldd	r18, Y+9	; 0x09
     d96:	3a 85       	ldd	r19, Y+10	; 0x0a
     d98:	4b 85       	ldd	r20, Y+11	; 0x0b
     d9a:	5c 85       	ldd	r21, Y+12	; 0x0c
     d9c:	ca 01       	movw	r24, r20
     d9e:	b9 01       	movw	r22, r18
     da0:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
     da4:	2d 81       	ldd	r18, Y+5	; 0x05
     da6:	3e 81       	ldd	r19, Y+6	; 0x06
     da8:	4f 81       	ldd	r20, Y+7	; 0x07
     daa:	58 85       	ldd	r21, Y+8	; 0x08
     dac:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
     db0:	9b 01       	movw	r18, r22
     db2:	ac 01       	movw	r20, r24
     db4:	6d 81       	ldd	r22, Y+5	; 0x05
     db6:	7e 81       	ldd	r23, Y+6	; 0x06
     db8:	8f 81       	ldd	r24, Y+7	; 0x07
     dba:	98 85       	ldd	r25, Y+8	; 0x08
     dbc:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     dc0:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
     dc4:	6d 83       	std	Y+5, r22	; 0x05
     dc6:	7e 83       	std	Y+6, r23	; 0x06
     dc8:	8f 83       	std	Y+7, r24	; 0x07
     dca:	98 87       	std	Y+8, r25	; 0x08

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
     dcc:	20 e0       	ldi	r18, 0x00	; 0
     dce:	30 e0       	ldi	r19, 0x00	; 0
     dd0:	40 e0       	ldi	r20, 0x00	; 0
     dd2:	5f e3       	ldi	r21, 0x3F	; 63
     dd4:	69 81       	ldd	r22, Y+1	; 0x01
     dd6:	7a 81       	ldd	r23, Y+2	; 0x02
     dd8:	8b 81       	ldd	r24, Y+3	; 0x03
     dda:	9c 81       	ldd	r25, Y+4	; 0x04
     ddc:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     de0:	29 85       	ldd	r18, Y+9	; 0x09
     de2:	3a 85       	ldd	r19, Y+10	; 0x0a
     de4:	4b 85       	ldd	r20, Y+11	; 0x0b
     de6:	5c 85       	ldd	r21, Y+12	; 0x0c
     de8:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     dec:	9f 77       	andi	r25, 0x7F	; 127
     dee:	2d 81       	ldd	r18, Y+5	; 0x05
     df0:	3e 81       	ldd	r19, Y+6	; 0x06
     df2:	4f 81       	ldd	r20, Y+7	; 0x07
     df4:	58 85       	ldd	r21, Y+8	; 0x08
     df6:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
     dfa:	0e 94 39 3a 	call	0x7472	; 0x7472 <floor>
     dfe:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
     e02:	69 87       	std	Y+9, r22	; 0x09
     e04:	7a 87       	std	Y+10, r23	; 0x0a
     e06:	8b 87       	std	Y+11, r24	; 0x0b
     e08:	9c 87       	std	Y+12, r25	; 0x0c
     e0a:	49 85       	ldd	r20, Y+9	; 0x09
     e0c:	5a 85       	ldd	r21, Y+10	; 0x0a
     e0e:	5e 87       	std	Y+14, r21	; 0x0e
     e10:	4d 87       	std	Y+13, r20	; 0x0d
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
  
  if (segments) { 
     e12:	45 2b       	or	r20, r21
     e14:	09 f4       	brne	.+2      	; 0xe18 <mc_arc+0x2da>
     e16:	8e c1       	rjmp	.+796    	; 0x1134 <mc_arc+0x5f6>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of 
    // all segments.
    if (invert_feed_rate) { feed_rate *= segments; }
     e18:	5b 89       	ldd	r21, Y+19	; 0x13
     e1a:	55 23       	and	r21, r21
     e1c:	79 f0       	breq	.+30     	; 0xe3c <mc_arc+0x2fe>
     e1e:	a9 85       	ldd	r26, Y+9	; 0x09
     e20:	ba 85       	ldd	r27, Y+10	; 0x0a
     e22:	bd 01       	movw	r22, r26
     e24:	80 e0       	ldi	r24, 0x00	; 0
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	0e 94 fc 39 	call	0x73f8	; 0x73f8 <__floatunsisf>
     e2c:	9b 01       	movw	r18, r22
     e2e:	ac 01       	movw	r20, r24
     e30:	c7 01       	movw	r24, r14
     e32:	b6 01       	movw	r22, r12
     e34:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     e38:	6b 01       	movw	r12, r22
     e3a:	7c 01       	movw	r14, r24
   
    float theta_per_segment = angular_travel/segments;
     e3c:	e9 85       	ldd	r30, Y+9	; 0x09
     e3e:	fa 85       	ldd	r31, Y+10	; 0x0a
     e40:	bf 01       	movw	r22, r30
     e42:	80 e0       	ldi	r24, 0x00	; 0
     e44:	90 e0       	ldi	r25, 0x00	; 0
     e46:	0e 94 fc 39 	call	0x73f8	; 0x73f8 <__floatunsisf>
     e4a:	69 87       	std	Y+9, r22	; 0x09
     e4c:	7a 87       	std	Y+10, r23	; 0x0a
     e4e:	8b 87       	std	Y+11, r24	; 0x0b
     e50:	9c 87       	std	Y+12, r25	; 0x0c
     e52:	9b 01       	movw	r18, r22
     e54:	ac 01       	movw	r20, r24
     e56:	69 81       	ldd	r22, Y+1	; 0x01
     e58:	7a 81       	ldd	r23, Y+2	; 0x02
     e5a:	8b 81       	ldd	r24, Y+3	; 0x03
     e5c:	9c 81       	ldd	r25, Y+4	; 0x04
     e5e:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
     e62:	68 ab       	std	Y+48, r22	; 0x30
     e64:	79 ab       	std	Y+49, r23	; 0x31
     e66:	8a ab       	std	Y+50, r24	; 0x32
     e68:	9b ab       	std	Y+51, r25	; 0x33
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
     e6a:	60 96       	adiw	r28, 0x10	; 16
     e6c:	8f ad       	ldd	r24, Y+63	; 0x3f
     e6e:	60 97       	sbiw	r28, 0x10	; 16
     e70:	90 e0       	ldi	r25, 0x00	; 0
     e72:	88 0f       	add	r24, r24
     e74:	99 1f       	adc	r25, r25
     e76:	88 0f       	add	r24, r24
     e78:	99 1f       	adc	r25, r25
     e7a:	29 89       	ldd	r18, Y+17	; 0x11
     e7c:	3a 89       	ldd	r19, Y+18	; 0x12
     e7e:	28 0f       	add	r18, r24
     e80:	39 1f       	adc	r19, r25
     e82:	3a 83       	std	Y+2, r19	; 0x02
     e84:	29 83       	std	Y+1, r18	; 0x01
     e86:	e8 ad       	ldd	r30, Y+56	; 0x38
     e88:	f9 ad       	ldd	r31, Y+57	; 0x39
     e8a:	e8 0f       	add	r30, r24
     e8c:	f9 1f       	adc	r31, r25
     e8e:	d9 01       	movw	r26, r18
     e90:	2d 91       	ld	r18, X+
     e92:	3d 91       	ld	r19, X+
     e94:	4d 91       	ld	r20, X+
     e96:	5c 91       	ld	r21, X
     e98:	60 81       	ld	r22, Z
     e9a:	71 81       	ldd	r23, Z+1	; 0x01
     e9c:	82 81       	ldd	r24, Z+2	; 0x02
     e9e:	93 81       	ldd	r25, Z+3	; 0x03
     ea0:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
     ea4:	29 85       	ldd	r18, Y+9	; 0x09
     ea6:	3a 85       	ldd	r19, Y+10	; 0x0a
     ea8:	4b 85       	ldd	r20, Y+11	; 0x0b
     eaa:	5c 85       	ldd	r21, Y+12	; 0x0c
     eac:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
     eb0:	6c a3       	std	Y+36, r22	; 0x24
     eb2:	7d a3       	std	Y+37, r23	; 0x25
     eb4:	8e a3       	std	Y+38, r24	; 0x26
     eb6:	9f a3       	std	Y+39, r25	; 0x27
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. 
       This is important when there are successive arc motions. 
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
     eb8:	28 a9       	ldd	r18, Y+48	; 0x30
     eba:	39 a9       	ldd	r19, Y+49	; 0x31
     ebc:	4a a9       	ldd	r20, Y+50	; 0x32
     ebe:	5b a9       	ldd	r21, Y+51	; 0x33
     ec0:	ca 01       	movw	r24, r20
     ec2:	b9 01       	movw	r22, r18
     ec4:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     ec8:	9b 01       	movw	r18, r22
     eca:	ac 01       	movw	r20, r24
     ecc:	60 e0       	ldi	r22, 0x00	; 0
     ece:	70 e0       	ldi	r23, 0x00	; 0
     ed0:	80 e0       	ldi	r24, 0x00	; 0
     ed2:	90 e4       	ldi	r25, 0x40	; 64
     ed4:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
     ed8:	69 87       	std	Y+9, r22	; 0x09
     eda:	7a 87       	std	Y+10, r23	; 0x0a
     edc:	8b 87       	std	Y+11, r24	; 0x0b
     ede:	9c 87       	std	Y+12, r25	; 0x0c
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
     ee0:	2b ea       	ldi	r18, 0xAB	; 171
     ee2:	3a ea       	ldi	r19, 0xAA	; 170
     ee4:	4a e2       	ldi	r20, 0x2A	; 42
     ee6:	5e e3       	ldi	r21, 0x3E	; 62
     ee8:	68 a9       	ldd	r22, Y+48	; 0x30
     eea:	79 a9       	ldd	r23, Y+49	; 0x31
     eec:	8a a9       	ldd	r24, Y+50	; 0x32
     eee:	9b a9       	ldd	r25, Y+51	; 0x33
     ef0:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     ef4:	6d 83       	std	Y+5, r22	; 0x05
     ef6:	7e 83       	std	Y+6, r23	; 0x06
     ef8:	8f 83       	std	Y+7, r24	; 0x07
     efa:	98 87       	std	Y+8, r25	; 0x08
     efc:	20 e0       	ldi	r18, 0x00	; 0
     efe:	30 e0       	ldi	r19, 0x00	; 0
     f00:	40 e8       	ldi	r20, 0x80	; 128
     f02:	50 e4       	ldi	r21, 0x40	; 64
     f04:	69 85       	ldd	r22, Y+9	; 0x09
     f06:	7a 85       	ldd	r23, Y+10	; 0x0a
     f08:	8b 85       	ldd	r24, Y+11	; 0x0b
     f0a:	9c 85       	ldd	r25, Y+12	; 0x0c
     f0c:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
     f10:	9b 01       	movw	r18, r22
     f12:	ac 01       	movw	r20, r24
     f14:	6d 81       	ldd	r22, Y+5	; 0x05
     f16:	7e 81       	ldd	r23, Y+6	; 0x06
     f18:	8f 81       	ldd	r24, Y+7	; 0x07
     f1a:	98 85       	ldd	r25, Y+8	; 0x08
     f1c:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     f20:	68 a7       	std	Y+40, r22	; 0x28
     f22:	79 a7       	std	Y+41, r23	; 0x29
     f24:	8a a7       	std	Y+42, r24	; 0x2a
     f26:	9b a7       	std	Y+43, r25	; 0x2b
    cos_T *= 0.5;
     f28:	20 e0       	ldi	r18, 0x00	; 0
     f2a:	30 e0       	ldi	r19, 0x00	; 0
     f2c:	40 e0       	ldi	r20, 0x00	; 0
     f2e:	5f e3       	ldi	r21, 0x3F	; 63
     f30:	69 85       	ldd	r22, Y+9	; 0x09
     f32:	7a 85       	ldd	r23, Y+10	; 0x0a
     f34:	8b 85       	ldd	r24, Y+11	; 0x0b
     f36:	9c 85       	ldd	r25, Y+12	; 0x0c
     f38:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     f3c:	6c a7       	std	Y+44, r22	; 0x2c
     f3e:	7d a7       	std	Y+45, r23	; 0x2d
     f40:	8e a7       	std	Y+46, r24	; 0x2e
     f42:	9f a7       	std	Y+47, r25	; 0x2f
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
     f44:	ed 85       	ldd	r30, Y+13	; 0x0d
     f46:	fe 85       	ldd	r31, Y+14	; 0x0e
     f48:	32 97       	sbiw	r30, 0x02	; 2
     f4a:	08 f4       	brcc	.+2      	; 0xf4e <mc_arc+0x410>
     f4c:	f3 c0       	rjmp	.+486    	; 0x1134 <mc_arc+0x5f6>

    float sin_Ti;
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
     f4e:	10 e0       	ldi	r17, 0x00	; 0
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
     f50:	22 24       	eor	r2, r2
     f52:	23 94       	inc	r2
     f54:	31 2c       	mov	r3, r1
      #else
        mc_line(position, feed_rate, invert_feed_rate);
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
     f56:	c8 a2       	std	Y+32, r12	; 0x20
     f58:	d9 a2       	std	Y+33, r13	; 0x21
     f5a:	ea a2       	std	Y+34, r14	; 0x22
     f5c:	fb a2       	std	Y+35, r15	; 0x23
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
      
      if (count < N_ARC_CORRECTION) {
     f5e:	1c 30       	cpi	r17, 0x0C	; 12
     f60:	d0 f5       	brcc	.+116    	; 0xfd6 <mc_arc+0x498>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
     f62:	2c a5       	ldd	r18, Y+44	; 0x2c
     f64:	3d a5       	ldd	r19, Y+45	; 0x2d
     f66:	4e a5       	ldd	r20, Y+46	; 0x2e
     f68:	5f a5       	ldd	r21, Y+47	; 0x2f
     f6a:	c5 01       	movw	r24, r10
     f6c:	b4 01       	movw	r22, r8
     f6e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     f72:	6b 01       	movw	r12, r22
     f74:	7c 01       	movw	r14, r24
     f76:	28 a5       	ldd	r18, Y+40	; 0x28
     f78:	39 a5       	ldd	r19, Y+41	; 0x29
     f7a:	4a a5       	ldd	r20, Y+42	; 0x2a
     f7c:	5b a5       	ldd	r21, Y+43	; 0x2b
     f7e:	c3 01       	movw	r24, r6
     f80:	b2 01       	movw	r22, r4
     f82:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     f86:	a7 01       	movw	r20, r14
     f88:	96 01       	movw	r18, r12
     f8a:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
     f8e:	d6 2e       	mov	r13, r22
     f90:	e7 2e       	mov	r14, r23
     f92:	f8 2e       	mov	r15, r24
     f94:	09 2f       	mov	r16, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
     f96:	2c a5       	ldd	r18, Y+44	; 0x2c
     f98:	3d a5       	ldd	r19, Y+45	; 0x2d
     f9a:	4e a5       	ldd	r20, Y+46	; 0x2e
     f9c:	5f a5       	ldd	r21, Y+47	; 0x2f
     f9e:	c3 01       	movw	r24, r6
     fa0:	b2 01       	movw	r22, r4
     fa2:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     fa6:	2b 01       	movw	r4, r22
     fa8:	3c 01       	movw	r6, r24
     faa:	28 a5       	ldd	r18, Y+40	; 0x28
     fac:	39 a5       	ldd	r19, Y+41	; 0x29
     fae:	4a a5       	ldd	r20, Y+42	; 0x2a
     fb0:	5b a5       	ldd	r21, Y+43	; 0x2b
     fb2:	c5 01       	movw	r24, r10
     fb4:	b4 01       	movw	r22, r8
     fb6:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     fba:	9b 01       	movw	r18, r22
     fbc:	ac 01       	movw	r20, r24
     fbe:	c3 01       	movw	r24, r6
     fc0:	b2 01       	movw	r22, r4
     fc2:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
     fc6:	2b 01       	movw	r4, r22
     fc8:	3c 01       	movw	r6, r24
        r_axis1 = r_axisi;
        count++;
     fca:	1f 5f       	subi	r17, 0xFF	; 255
      
      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
     fcc:	8d 2c       	mov	r8, r13
     fce:	9e 2c       	mov	r9, r14
     fd0:	af 2c       	mov	r10, r15
     fd2:	b0 2e       	mov	r11, r16
     fd4:	64 c0       	rjmp	.+200    	; 0x109e <mc_arc+0x560>
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
     fd6:	b1 01       	movw	r22, r2
     fd8:	80 e0       	ldi	r24, 0x00	; 0
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	0e 94 fc 39 	call	0x73f8	; 0x73f8 <__floatunsisf>
     fe0:	28 a9       	ldd	r18, Y+48	; 0x30
     fe2:	39 a9       	ldd	r19, Y+49	; 0x31
     fe4:	4a a9       	ldd	r20, Y+50	; 0x32
     fe6:	5b a9       	ldd	r21, Y+51	; 0x33
     fe8:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
     fec:	4b 01       	movw	r8, r22
     fee:	5c 01       	movw	r10, r24
     ff0:	0e 94 60 39 	call	0x72c0	; 0x72c0 <cos>
     ff4:	6b 01       	movw	r12, r22
     ff6:	7c 01       	movw	r14, r24
        sin_Ti = sin(i*theta_per_segment);
     ff8:	c5 01       	movw	r24, r10
     ffa:	b4 01       	movw	r22, r8
     ffc:	0e 94 1d 3c 	call	0x783a	; 0x783a <sin>
    1000:	4b 01       	movw	r8, r22
    1002:	5c 01       	movw	r10, r24
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
    1004:	ec a9       	ldd	r30, Y+52	; 0x34
    1006:	fd a9       	ldd	r31, Y+53	; 0x35
    1008:	80 81       	ld	r24, Z
    100a:	91 81       	ldd	r25, Z+1	; 0x01
    100c:	a2 81       	ldd	r26, Z+2	; 0x02
    100e:	b3 81       	ldd	r27, Z+3	; 0x03
    1010:	9c 01       	movw	r18, r24
    1012:	ad 01       	movw	r20, r26
    1014:	50 58       	subi	r21, 0x80	; 128
    1016:	29 87       	std	Y+9, r18	; 0x09
    1018:	3a 87       	std	Y+10, r19	; 0x0a
    101a:	4b 87       	std	Y+11, r20	; 0x0b
    101c:	5c 87       	std	Y+12, r21	; 0x0c
    101e:	ae a9       	ldd	r26, Y+54	; 0x36
    1020:	bf a9       	ldd	r27, Y+55	; 0x37
    1022:	8d 91       	ld	r24, X+
    1024:	9d 91       	ld	r25, X+
    1026:	0d 90       	ld	r0, X+
    1028:	bc 91       	ld	r27, X
    102a:	a0 2d       	mov	r26, r0
    102c:	8d 83       	std	Y+5, r24	; 0x05
    102e:	9e 83       	std	Y+6, r25	; 0x06
    1030:	af 83       	std	Y+7, r26	; 0x07
    1032:	b8 87       	std	Y+8, r27	; 0x08
    1034:	a7 01       	movw	r20, r14
    1036:	96 01       	movw	r18, r12
    1038:	69 85       	ldd	r22, Y+9	; 0x09
    103a:	7a 85       	ldd	r23, Y+10	; 0x0a
    103c:	8b 85       	ldd	r24, Y+11	; 0x0b
    103e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1040:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    1044:	2b 01       	movw	r4, r22
    1046:	3c 01       	movw	r6, r24
    1048:	a5 01       	movw	r20, r10
    104a:	94 01       	movw	r18, r8
    104c:	6d 81       	ldd	r22, Y+5	; 0x05
    104e:	7e 81       	ldd	r23, Y+6	; 0x06
    1050:	8f 81       	ldd	r24, Y+7	; 0x07
    1052:	98 85       	ldd	r25, Y+8	; 0x08
    1054:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    1058:	9b 01       	movw	r18, r22
    105a:	ac 01       	movw	r20, r24
    105c:	c3 01       	movw	r24, r6
    105e:	b2 01       	movw	r22, r4
    1060:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    1064:	2b 01       	movw	r4, r22
    1066:	3c 01       	movw	r6, r24
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
    1068:	29 85       	ldd	r18, Y+9	; 0x09
    106a:	3a 85       	ldd	r19, Y+10	; 0x0a
    106c:	4b 85       	ldd	r20, Y+11	; 0x0b
    106e:	5c 85       	ldd	r21, Y+12	; 0x0c
    1070:	c5 01       	movw	r24, r10
    1072:	b4 01       	movw	r22, r8
    1074:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    1078:	4b 01       	movw	r8, r22
    107a:	5c 01       	movw	r10, r24
    107c:	2d 81       	ldd	r18, Y+5	; 0x05
    107e:	3e 81       	ldd	r19, Y+6	; 0x06
    1080:	4f 81       	ldd	r20, Y+7	; 0x07
    1082:	58 85       	ldd	r21, Y+8	; 0x08
    1084:	c7 01       	movw	r24, r14
    1086:	b6 01       	movw	r22, r12
    1088:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    108c:	9b 01       	movw	r18, r22
    108e:	ac 01       	movw	r20, r24
    1090:	c5 01       	movw	r24, r10
    1092:	b4 01       	movw	r22, r8
    1094:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    1098:	4b 01       	movw	r8, r22
    109a:	5c 01       	movw	r10, r24
        count = 0;
    109c:	10 e0       	ldi	r17, 0x00	; 0
      }
  
      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
    109e:	a3 01       	movw	r20, r6
    10a0:	92 01       	movw	r18, r4
    10a2:	6e 89       	ldd	r22, Y+22	; 0x16
    10a4:	7f 89       	ldd	r23, Y+23	; 0x17
    10a6:	88 8d       	ldd	r24, Y+24	; 0x18
    10a8:	99 8d       	ldd	r25, Y+25	; 0x19
    10aa:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    10ae:	ec 89       	ldd	r30, Y+20	; 0x14
    10b0:	fd 89       	ldd	r31, Y+21	; 0x15
    10b2:	60 83       	st	Z, r22
    10b4:	71 83       	std	Z+1, r23	; 0x01
    10b6:	82 83       	std	Z+2, r24	; 0x02
    10b8:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
    10ba:	a5 01       	movw	r20, r10
    10bc:	94 01       	movw	r18, r8
    10be:	6c 8d       	ldd	r22, Y+28	; 0x1c
    10c0:	7d 8d       	ldd	r23, Y+29	; 0x1d
    10c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10c4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    10c6:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    10ca:	aa 8d       	ldd	r26, Y+26	; 0x1a
    10cc:	bb 8d       	ldd	r27, Y+27	; 0x1b
    10ce:	6d 93       	st	X+, r22
    10d0:	7d 93       	st	X+, r23
    10d2:	8d 93       	st	X+, r24
    10d4:	9c 93       	st	X, r25
    10d6:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
    10d8:	2c a1       	ldd	r18, Y+36	; 0x24
    10da:	3d a1       	ldd	r19, Y+37	; 0x25
    10dc:	4e a1       	ldd	r20, Y+38	; 0x26
    10de:	5f a1       	ldd	r21, Y+39	; 0x27
    10e0:	e9 81       	ldd	r30, Y+1	; 0x01
    10e2:	fa 81       	ldd	r31, Y+2	; 0x02
    10e4:	60 81       	ld	r22, Z
    10e6:	71 81       	ldd	r23, Z+1	; 0x01
    10e8:	82 81       	ldd	r24, Z+2	; 0x02
    10ea:	93 81       	ldd	r25, Z+3	; 0x03
    10ec:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    10f0:	a9 81       	ldd	r26, Y+1	; 0x01
    10f2:	ba 81       	ldd	r27, Y+2	; 0x02
    10f4:	6d 93       	st	X+, r22
    10f6:	7d 93       	st	X+, r23
    10f8:	8d 93       	st	X+, r24
    10fa:	9c 93       	st	X, r25
    10fc:	13 97       	sbiw	r26, 0x03	; 3
      
      #ifdef USE_LINE_NUMBERS
        mc_line(position, feed_rate, invert_feed_rate, line_number);
      #else
        mc_line(position, feed_rate, invert_feed_rate);
    10fe:	2b 89       	ldd	r18, Y+19	; 0x13
    1100:	48 a1       	ldd	r20, Y+32	; 0x20
    1102:	59 a1       	ldd	r21, Y+33	; 0x21
    1104:	6a a1       	ldd	r22, Y+34	; 0x22
    1106:	7b a1       	ldd	r23, Y+35	; 0x23
    1108:	89 89       	ldd	r24, Y+17	; 0x11
    110a:	9a 89       	ldd	r25, Y+18	; 0x12
    110c:	0e 94 62 05 	call	0xac4	; 0xac4 <mc_line>
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    1110:	e3 e8       	ldi	r30, 0x83	; 131
    1112:	f5 e0       	ldi	r31, 0x05	; 5
    1114:	80 81       	ld	r24, Z
    1116:	81 11       	cpse	r24, r1
    1118:	14 c0       	rjmp	.+40     	; 0x1142 <mc_arc+0x604>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    111a:	ff ef       	ldi	r31, 0xFF	; 255
    111c:	2f 1a       	sub	r2, r31
    111e:	3f 0a       	sbc	r3, r31
    1120:	2d 85       	ldd	r18, Y+13	; 0x0d
    1122:	3e 85       	ldd	r19, Y+14	; 0x0e
    1124:	22 16       	cp	r2, r18
    1126:	33 06       	cpc	r3, r19
    1128:	09 f0       	breq	.+2      	; 0x112c <mc_arc+0x5ee>
    112a:	19 cf       	rjmp	.-462    	; 0xf5e <mc_arc+0x420>
    112c:	c8 a0       	ldd	r12, Y+32	; 0x20
    112e:	d9 a0       	ldd	r13, Y+33	; 0x21
    1130:	ea a0       	ldd	r14, Y+34	; 0x22
    1132:	fb a0       	ldd	r15, Y+35	; 0x23
  }
  // Ensure last segment arrives at target location.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    1134:	2b 89       	ldd	r18, Y+19	; 0x13
    1136:	b7 01       	movw	r22, r14
    1138:	a6 01       	movw	r20, r12
    113a:	88 ad       	ldd	r24, Y+56	; 0x38
    113c:	99 ad       	ldd	r25, Y+57	; 0x39
    113e:	0e 94 62 05 	call	0xac4	; 0xac4 <mc_line>
  #endif
}
    1142:	e9 96       	adiw	r28, 0x39	; 57
    1144:	0f b6       	in	r0, 0x3f	; 63
    1146:	f8 94       	cli
    1148:	de bf       	out	0x3e, r29	; 62
    114a:	0f be       	out	0x3f, r0	; 63
    114c:	cd bf       	out	0x3d, r28	; 61
    114e:	df 91       	pop	r29
    1150:	cf 91       	pop	r28
    1152:	1f 91       	pop	r17
    1154:	0f 91       	pop	r16
    1156:	ff 90       	pop	r15
    1158:	ef 90       	pop	r14
    115a:	df 90       	pop	r13
    115c:	cf 90       	pop	r12
    115e:	bf 90       	pop	r11
    1160:	af 90       	pop	r10
    1162:	9f 90       	pop	r9
    1164:	8f 90       	pop	r8
    1166:	7f 90       	pop	r7
    1168:	6f 90       	pop	r6
    116a:	5f 90       	pop	r5
    116c:	4f 90       	pop	r4
    116e:	3f 90       	pop	r3
    1170:	2f 90       	pop	r2
    1172:	08 95       	ret

00001174 <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
    1174:	8f 92       	push	r8
    1176:	9f 92       	push	r9
    1178:	af 92       	push	r10
    117a:	bf 92       	push	r11
    117c:	cf 92       	push	r12
    117e:	df 92       	push	r13
    1180:	ef 92       	push	r14
    1182:	ff 92       	push	r15
    1184:	cf 93       	push	r28
    1186:	df 93       	push	r29
    1188:	4b 01       	movw	r8, r22
    118a:	5c 01       	movw	r10, r24
   if (sys.state == STATE_CHECK_MODE) { return; }
    118c:	80 91 84 05 	lds	r24, 0x0584
    1190:	82 30       	cpi	r24, 0x02	; 2
    1192:	09 f4       	brne	.+2      	; 0x1196 <mc_dwell+0x22>
    1194:	4a c0       	rjmp	.+148    	; 0x122a <mc_dwell+0xb6>
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
    1196:	20 e0       	ldi	r18, 0x00	; 0
    1198:	30 e0       	ldi	r19, 0x00	; 0
    119a:	40 ea       	ldi	r20, 0xA0	; 160
    119c:	51 e4       	ldi	r21, 0x41	; 65
    119e:	c5 01       	movw	r24, r10
    11a0:	b4 01       	movw	r22, r8
    11a2:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    11a6:	0e 94 39 3a 	call	0x7472	; 0x7472 <floor>
    11aa:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    11ae:	6b 01       	movw	r12, r22
    11b0:	7c 01       	movw	r14, r24
    11b2:	eb 01       	movw	r28, r22
   protocol_buffer_synchronize();
    11b4:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
    11b8:	20 e0       	ldi	r18, 0x00	; 0
    11ba:	30 e0       	ldi	r19, 0x00	; 0
    11bc:	4a e7       	ldi	r20, 0x7A	; 122
    11be:	54 e4       	ldi	r21, 0x44	; 68
    11c0:	c5 01       	movw	r24, r10
    11c2:	b4 01       	movw	r22, r8
    11c4:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    11c8:	4b 01       	movw	r8, r22
    11ca:	5c 01       	movw	r10, r24
    11cc:	82 e3       	ldi	r24, 0x32	; 50
    11ce:	8c 9d       	mul	r24, r12
    11d0:	b0 01       	movw	r22, r0
    11d2:	8d 9d       	mul	r24, r13
    11d4:	70 0d       	add	r23, r0
    11d6:	11 24       	eor	r1, r1
    11d8:	80 e0       	ldi	r24, 0x00	; 0
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	0e 94 fc 39 	call	0x73f8	; 0x73f8 <__floatunsisf>
    11e0:	9b 01       	movw	r18, r22
    11e2:	ac 01       	movw	r20, r24
    11e4:	c5 01       	movw	r24, r10
    11e6:	b4 01       	movw	r22, r8
    11e8:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    11ec:	0e 94 39 3a 	call	0x7472	; 0x7472 <floor>
    11f0:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    11f4:	cb 01       	movw	r24, r22
    11f6:	0e 94 e6 2a 	call	0x55cc	; 0x55cc <delay_ms>
   while (i-- > 0) {
    11fa:	cd 2b       	or	r28, r29
    11fc:	b1 f0       	breq	.+44     	; 0x122a <mc_dwell+0xb6>
     // NOTE: Check and execute runtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_runtime();
     if (sys.abort) { return; }
    11fe:	c3 e8       	ldi	r28, 0x83	; 131
    1200:	d5 e0       	ldi	r29, 0x05	; 5
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
     // NOTE: Check and execute runtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_runtime();
    1202:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
     if (sys.abort) { return; }
    1206:	88 81       	ld	r24, Y
    1208:	81 11       	cpse	r24, r1
    120a:	0f c0       	rjmp	.+30     	; 0x122a <mc_dwell+0xb6>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    120c:	2f ef       	ldi	r18, 0xFF	; 255
    120e:	80 e7       	ldi	r24, 0x70	; 112
    1210:	92 e0       	ldi	r25, 0x02	; 2
    1212:	21 50       	subi	r18, 0x01	; 1
    1214:	80 40       	sbci	r24, 0x00	; 0
    1216:	90 40       	sbci	r25, 0x00	; 0
    1218:	e1 f7       	brne	.-8      	; 0x1212 <mc_dwell+0x9e>
    121a:	00 c0       	rjmp	.+0      	; 0x121c <mc_dwell+0xa8>
    121c:	00 00       	nop
    121e:	21 e0       	ldi	r18, 0x01	; 1
    1220:	c2 1a       	sub	r12, r18
    1222:	d1 08       	sbc	r13, r1
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
    1224:	c1 14       	cp	r12, r1
    1226:	d1 04       	cpc	r13, r1
    1228:	61 f7       	brne	.-40     	; 0x1202 <mc_dwell+0x8e>
     // NOTE: Check and execute runtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_runtime();
     if (sys.abort) { return; }
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   }
}
    122a:	df 91       	pop	r29
    122c:	cf 91       	pop	r28
    122e:	ff 90       	pop	r15
    1230:	ef 90       	pop	r14
    1232:	df 90       	pop	r13
    1234:	cf 90       	pop	r12
    1236:	bf 90       	pop	r11
    1238:	af 90       	pop	r10
    123a:	9f 90       	pop	r9
    123c:	8f 90       	pop	r8
    123e:	08 95       	ret

00001240 <mc_homing_cycle>:
// Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
// NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
// executing the homing cycle. This prevents incorrect buffered plans after homing.
void mc_homing_cycle()
{
  sys.state = STATE_HOMING; // Set system state variable
    1240:	84 e0       	ldi	r24, 0x04	; 4
    1242:	80 93 84 05 	sts	0x0584, r24
  limits_disable(); // Disable hard limits pin change register for cycle duration
    1246:	0e 94 19 2b 	call	0x5632	; 0x5632 <limits_disable>
    
  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  // Search to engage all axes limit switches at faster homing seek rate.
  limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    124a:	84 e0       	ldi	r24, 0x04	; 4
    124c:	0e 94 78 2b 	call	0x56f0	; 0x56f0 <limits_go_home>
  #ifdef HOMING_CYCLE_1
    limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
    1250:	83 e0       	ldi	r24, 0x03	; 3
    1252:	0e 94 78 2b 	call	0x56f0	; 0x56f0 <limits_go_home>
  #endif
  #ifdef HOMING_CYCLE_2
    limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
  #endif
    
  protocol_execute_runtime(); // Check for reset and set system abort.
    1256:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
    125a:	80 91 83 05 	lds	r24, 0x0583
    125e:	81 11       	cpse	r24, r1
    1260:	08 c0       	rjmp	.+16     	; 0x1272 <mc_homing_cycle+0x32>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Gcode parser position was circumvented by the limits_go_home() routine, so sync position now.
  gc_sync_position();
    1262:	0e 94 1b 0a 	call	0x1436	; 0x1436 <gc_sync_position>
  
  // Set idle state after homing completes and before returning to main program.  
  sys.state = STATE_IDLE;
    1266:	10 92 84 05 	sts	0x0584, r1
  st_go_idle(); // Set idle state after homing completes
    126a:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <st_go_idle>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
    126e:	0e 94 24 2b 	call	0x5648	; 0x5648 <limits_init>
    1272:	08 95       	ret

00001274 <mc_probe_cycle>:
#ifdef USE_LINE_NUMBERS
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{ 
    1274:	2f 92       	push	r2
    1276:	3f 92       	push	r3
    1278:	5f 92       	push	r5
    127a:	6f 92       	push	r6
    127c:	7f 92       	push	r7
    127e:	8f 92       	push	r8
    1280:	9f 92       	push	r9
    1282:	af 92       	push	r10
    1284:	bf 92       	push	r11
    1286:	cf 92       	push	r12
    1288:	df 92       	push	r13
    128a:	ef 92       	push	r14
    128c:	ff 92       	push	r15
    128e:	0f 93       	push	r16
    1290:	1f 93       	push	r17
    1292:	cf 93       	push	r28
    1294:	df 93       	push	r29
    1296:	68 2e       	mov	r6, r24
    1298:	79 2e       	mov	r7, r25
    129a:	6a 01       	movw	r12, r20
    129c:	7b 01       	movw	r14, r22
    129e:	52 2e       	mov	r5, r18
  protocol_buffer_synchronize(); // Finish all queued commands and empty planner buffer.
    12a0:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>
  if (sys.abort) { return; } // Return if system reset has been issued.
    12a4:	80 91 83 05 	lds	r24, 0x0583
    12a8:	81 11       	cpse	r24, r1
    12aa:	6e c0       	rjmp	.+220    	; 0x1388 <mc_probe_cycle+0x114>

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    12ac:	25 2d       	mov	r18, r5
    12ae:	b7 01       	movw	r22, r14
    12b0:	a6 01       	movw	r20, r12
    12b2:	86 2d       	mov	r24, r6
    12b4:	97 2d       	mov	r25, r7
    12b6:	0e 94 62 05 	call	0xac4	; 0xac4 <mc_line>
  #endif

  // Activate the probing monitor in the stepper module.
  // NOTE: Parser error-checking ensures the probe isn't already closed/triggered.
  sys.probe_state = PROBE_ACTIVE;
    12ba:	81 e0       	ldi	r24, 0x01	; 1
    12bc:	80 93 94 05 	sts	0x0594, r24
  
  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys.execute, EXEC_CYCLE_START);
    12c0:	8f b7       	in	r24, 0x3f	; 63
    12c2:	f8 94       	cli
    12c4:	e5 e8       	ldi	r30, 0x85	; 133
    12c6:	f5 e0       	ldi	r31, 0x05	; 5
    12c8:	90 81       	ld	r25, Z
    12ca:	92 60       	ori	r25, 0x02	; 2
    12cc:	90 83       	st	Z, r25
    12ce:	8f bf       	out	0x3f, r24	; 63
  do {
    protocol_execute_runtime(); 
    if (sys.abort) { return; } // Check for system abort
    12d0:	c3 e8       	ldi	r28, 0x83	; 131
    12d2:	d5 e0       	ldi	r29, 0x05	; 5
  } while ((sys.state != STATE_IDLE) && (sys.state != STATE_QUEUED));
    12d4:	04 e8       	ldi	r16, 0x84	; 132
    12d6:	15 e0       	ldi	r17, 0x05	; 5
  sys.probe_state = PROBE_ACTIVE;
  
  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys.execute, EXEC_CYCLE_START);
  do {
    protocol_execute_runtime(); 
    12d8:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
    if (sys.abort) { return; } // Check for system abort
    12dc:	88 81       	ld	r24, Y
    12de:	81 11       	cpse	r24, r1
    12e0:	53 c0       	rjmp	.+166    	; 0x1388 <mc_probe_cycle+0x114>
  } while ((sys.state != STATE_IDLE) && (sys.state != STATE_QUEUED));
    12e2:	f8 01       	movw	r30, r16
    12e4:	80 81       	ld	r24, Z
    12e6:	87 7f       	andi	r24, 0xF7	; 247
    12e8:	b9 f7       	brne	.-18     	; 0x12d8 <mc_probe_cycle+0x64>

  // If motion completes without probe triggering, error out.
  if (sys.probe_state == PROBE_ACTIVE) { bit_true_atomic(sys.execute, EXEC_CRIT_EVENT); }
    12ea:	80 91 94 05 	lds	r24, 0x0594
    12ee:	81 30       	cpi	r24, 0x01	; 1
    12f0:	41 f4       	brne	.+16     	; 0x1302 <mc_probe_cycle+0x8e>
    12f2:	8f b7       	in	r24, 0x3f	; 63
    12f4:	f8 94       	cli
    12f6:	e5 e8       	ldi	r30, 0x85	; 133
    12f8:	f5 e0       	ldi	r31, 0x05	; 5
    12fa:	90 81       	ld	r25, Z
    12fc:	90 64       	ori	r25, 0x40	; 64
    12fe:	90 83       	st	Z, r25
    1300:	8f bf       	out	0x3f, r24	; 63
  protocol_execute_runtime();   // Check and execute run-time commands
    1302:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
  if (sys.abort) { return; } // Check for system abort
    1306:	80 91 83 05 	lds	r24, 0x0583
    130a:	81 11       	cpse	r24, r1
    130c:	3d c0       	rjmp	.+122    	; 0x1388 <mc_probe_cycle+0x114>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reest step segment buffer.
    130e:	0e 94 32 1a 	call	0x3464	; 0x3464 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
    1312:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    1316:	0e 94 d5 29 	call	0x53aa	; 0x53aa <plan_sync_position>
    131a:	c5 e9       	ldi	r28, 0x95	; 149
    131c:	d5 e0       	ldi	r29, 0x05	; 5
    131e:	00 e4       	ldi	r16, 0x40	; 64
    1320:	17 e0       	ldi	r17, 0x07	; 7
    1322:	26 2c       	mov	r2, r6
    1324:	37 2c       	mov	r3, r7
  // Probing motion is complete, but we'll pull-off triggered probe to the trigger location since
  // we had to decelerate a little beyond it to stop the machine in a controlled manner.
  uint8_t idx;
  for(idx=0; idx<N_AXIS; idx++){
    // NOTE: The target[] variable updated here will be sent back and synced with the g-code parser.
    target[idx] = (float)sys.probe_position[idx]/settings.steps_per_mm[idx];
    1326:	69 91       	ld	r22, Y+
    1328:	79 91       	ld	r23, Y+
    132a:	89 91       	ld	r24, Y+
    132c:	99 91       	ld	r25, Y+
    132e:	f8 01       	movw	r30, r16
    1330:	81 90       	ld	r8, Z+
    1332:	91 90       	ld	r9, Z+
    1334:	a1 90       	ld	r10, Z+
    1336:	b1 90       	ld	r11, Z+
    1338:	8f 01       	movw	r16, r30
    133a:	0e 94 fe 39 	call	0x73fc	; 0x73fc <__floatsisf>
    133e:	a5 01       	movw	r20, r10
    1340:	94 01       	movw	r18, r8
    1342:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    1346:	f1 01       	movw	r30, r2
    1348:	61 93       	st	Z+, r22
    134a:	71 93       	st	Z+, r23
    134c:	81 93       	st	Z+, r24
    134e:	91 93       	st	Z+, r25
    1350:	1f 01       	movw	r2, r30
  plan_sync_position(); // Sync planner position to current machine position.

  // Probing motion is complete, but we'll pull-off triggered probe to the trigger location since
  // we had to decelerate a little beyond it to stop the machine in a controlled manner.
  uint8_t idx;
  for(idx=0; idx<N_AXIS; idx++){
    1352:	f5 e0       	ldi	r31, 0x05	; 5
    1354:	c1 3a       	cpi	r28, 0xA1	; 161
    1356:	df 07       	cpc	r29, r31
    1358:	31 f7       	brne	.-52     	; 0x1326 <mc_probe_cycle+0xb2>
    target[idx] = (float)sys.probe_position[idx]/settings.steps_per_mm[idx];
  }
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    135a:	25 2d       	mov	r18, r5
    135c:	b7 01       	movw	r22, r14
    135e:	a6 01       	movw	r20, r12
    1360:	86 2d       	mov	r24, r6
    1362:	97 2d       	mov	r25, r7
    1364:	0e 94 62 05 	call	0xac4	; 0xac4 <mc_line>
  #endif

  // Execute pull-off motion and wait until it completes.
  bit_true_atomic(sys.execute, EXEC_CYCLE_START);
    1368:	8f b7       	in	r24, 0x3f	; 63
    136a:	f8 94       	cli
    136c:	e5 e8       	ldi	r30, 0x85	; 133
    136e:	f5 e0       	ldi	r31, 0x05	; 5
    1370:	90 81       	ld	r25, Z
    1372:	92 60       	ori	r25, 0x02	; 2
    1374:	90 83       	st	Z, r25
    1376:	8f bf       	out	0x3f, r24	; 63
  protocol_buffer_synchronize(); 
    1378:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>
  if (sys.abort) { return; } // Return if system reset has been issued.
    137c:	80 91 83 05 	lds	r24, 0x0583
    1380:	81 11       	cpse	r24, r1
    1382:	02 c0       	rjmp	.+4      	; 0x1388 <mc_probe_cycle+0x114>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
    1384:	0e 94 06 32 	call	0x640c	; 0x640c <report_probe_parameters>
  #endif
}
    1388:	df 91       	pop	r29
    138a:	cf 91       	pop	r28
    138c:	1f 91       	pop	r17
    138e:	0f 91       	pop	r16
    1390:	ff 90       	pop	r15
    1392:	ef 90       	pop	r14
    1394:	df 90       	pop	r13
    1396:	cf 90       	pop	r12
    1398:	bf 90       	pop	r11
    139a:	af 90       	pop	r10
    139c:	9f 90       	pop	r9
    139e:	8f 90       	pop	r8
    13a0:	7f 90       	pop	r7
    13a2:	6f 90       	pop	r6
    13a4:	5f 90       	pop	r5
    13a6:	3f 90       	pop	r3
    13a8:	2f 90       	pop	r2
    13aa:	08 95       	ret

000013ac <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// runtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys.execute, EXEC_RESET)) {
    13ac:	80 91 85 05 	lds	r24, 0x0585
    13b0:	84 fd       	sbrc	r24, 4
    13b2:	1a c0       	rjmp	.+52     	; 0x13e8 <mc_reset+0x3c>
    bit_true_atomic(sys.execute, EXEC_RESET);
    13b4:	8f b7       	in	r24, 0x3f	; 63
    13b6:	f8 94       	cli
    13b8:	e5 e8       	ldi	r30, 0x85	; 133
    13ba:	f5 e0       	ldi	r31, 0x05	; 5
    13bc:	90 81       	ld	r25, Z
    13be:	90 61       	ori	r25, 0x10	; 16
    13c0:	90 83       	st	Z, r25
    13c2:	8f bf       	out	0x3f, r24	; 63

    // Kill spindle and coolant.   
    spindle_stop();
    13c4:	0e 94 21 15 	call	0x2a42	; 0x2a42 <spindle_stop>
    coolant_stop();
    13c8:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, feed hold, homing, or jogging
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_HOMING)) {
    13cc:	80 91 84 05 	lds	r24, 0x0584
    13d0:	84 73       	andi	r24, 0x34	; 52
    13d2:	51 f0       	breq	.+20     	; 0x13e8 <mc_reset+0x3c>
      bit_true_atomic(sys.execute, EXEC_ALARM); // Flag main program to execute alarm state.
    13d4:	8f b7       	in	r24, 0x3f	; 63
    13d6:	f8 94       	cli
    13d8:	e5 e8       	ldi	r30, 0x85	; 133
    13da:	f5 e0       	ldi	r31, 0x05	; 5
    13dc:	90 81       	ld	r25, Z
    13de:	90 62       	ori	r25, 0x20	; 32
    13e0:	90 83       	st	Z, r25
    13e2:	8f bf       	out	0x3f, r24	; 63
      st_go_idle(); // Force kill steppers. Position has likely been lost.
    13e4:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <st_go_idle>
    13e8:	08 95       	ret

000013ea <gc_init>:

#define FAIL(status) return(status);


void gc_init() 
{
    13ea:	1f 93       	push	r17
    13ec:	cf 93       	push	r28
    13ee:	df 93       	push	r29
  uint8_t tool;
  memset(&gc_state, 0, sizeof(gc_state));
    13f0:	88 e8       	ldi	r24, 0x88	; 136
    13f2:	ed eb       	ldi	r30, 0xBD	; 189
    13f4:	f5 e0       	ldi	r31, 0x05	; 5
    13f6:	df 01       	movw	r26, r30
    13f8:	1d 92       	st	X+, r1
    13fa:	8a 95       	dec	r24
    13fc:	e9 f7       	brne	.-6      	; 0x13f8 <gc_init+0xe>
  
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
    13fe:	6d e2       	ldi	r22, 0x2D	; 45
    1400:	76 e0       	ldi	r23, 0x06	; 6
    1402:	80 e0       	ldi	r24, 0x00	; 0
    1404:	0e 94 6d 23 	call	0x46da	; 0x46da <settings_read_coord_data>
    1408:	81 11       	cpse	r24, r1
    140a:	0d c0       	rjmp	.+26     	; 0x1426 <gc_init+0x3c>
    report_status_message(STATUS_SETTING_READ_FAIL); 
    140c:	87 e0       	ldi	r24, 0x07	; 7
    140e:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    1412:	09 c0       	rjmp	.+18     	; 0x1426 <gc_init+0x3c>
  }

  for( tool=1; tool < N_TOOL_TABLE; tool++) {
	  settings_read_tool_data( tool, &gc_state.tool_table[tool]);
    1414:	be 01       	movw	r22, r28
    1416:	81 2f       	mov	r24, r17
    1418:	0e 94 8e 23 	call	0x471c	; 0x471c <settings_read_tool_data>
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
    report_status_message(STATUS_SETTING_READ_FAIL); 
  }

  for( tool=1; tool < N_TOOL_TABLE; tool++) {
    141c:	1f 5f       	subi	r17, 0xFF	; 255
    141e:	60 96       	adiw	r28, 0x10	; 16
    1420:	15 30       	cpi	r17, 0x05	; 5
    1422:	c1 f7       	brne	.-16     	; 0x1414 <gc_init+0x2a>
    1424:	04 c0       	rjmp	.+8      	; 0x142e <gc_init+0x44>
    1426:	c1 ee       	ldi	r28, 0xE1	; 225
    1428:	d5 e0       	ldi	r29, 0x05	; 5

#define FAIL(status) return(status);


void gc_init() 
{
    142a:	11 e0       	ldi	r17, 0x01	; 1
    142c:	f3 cf       	rjmp	.-26     	; 0x1414 <gc_init+0x2a>
  }

  for( tool=1; tool < N_TOOL_TABLE; tool++) {
	  settings_read_tool_data( tool, &gc_state.tool_table[tool]);
  }
}
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	1f 91       	pop	r17
    1434:	08 95       	ret

00001436 <gc_sync_position>:


// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
    1436:	8f 92       	push	r8
    1438:	9f 92       	push	r9
    143a:	af 92       	push	r10
    143c:	bf 92       	push	r11
    143e:	cf 92       	push	r12
    1440:	df 92       	push	r13
    1442:	ef 92       	push	r14
    1444:	ff 92       	push	r15
    1446:	0f 93       	push	r16
    1448:	1f 93       	push	r17
    144a:	cf 93       	push	r28
    144c:	df 93       	push	r29
    144e:	c7 e8       	ldi	r28, 0x87	; 135
    1450:	d5 e0       	ldi	r29, 0x05	; 5
    1452:	0f 2e       	mov	r0, r31
    1454:	f0 e4       	ldi	r31, 0x40	; 64
    1456:	ef 2e       	mov	r14, r31
    1458:	f7 e0       	ldi	r31, 0x07	; 7
    145a:	ff 2e       	mov	r15, r31
    145c:	f0 2d       	mov	r31, r0
    145e:	01 e2       	ldi	r16, 0x21	; 33
    1460:	16 e0       	ldi	r17, 0x06	; 6
    1462:	0f 2e       	mov	r0, r31
    1464:	f3 e9       	ldi	r31, 0x93	; 147
    1466:	cf 2e       	mov	r12, r31
    1468:	f5 e0       	ldi	r31, 0x05	; 5
    146a:	df 2e       	mov	r13, r31
    146c:	f0 2d       	mov	r31, r0
  uint8_t i;
  for (i=0; i<N_AXIS; i++) {
    gc_state.position[i] = sys.position[i]/settings.steps_per_mm[i];
    146e:	69 91       	ld	r22, Y+
    1470:	79 91       	ld	r23, Y+
    1472:	89 91       	ld	r24, Y+
    1474:	99 91       	ld	r25, Y+
    1476:	f7 01       	movw	r30, r14
    1478:	81 90       	ld	r8, Z+
    147a:	91 90       	ld	r9, Z+
    147c:	a1 90       	ld	r10, Z+
    147e:	b1 90       	ld	r11, Z+
    1480:	7f 01       	movw	r14, r30
    1482:	0e 94 fe 39 	call	0x73fc	; 0x73fc <__floatsisf>
    1486:	a5 01       	movw	r20, r10
    1488:	94 01       	movw	r18, r8
    148a:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    148e:	f8 01       	movw	r30, r16
    1490:	61 93       	st	Z+, r22
    1492:	71 93       	st	Z+, r23
    1494:	81 93       	st	Z+, r24
    1496:	91 93       	st	Z+, r25
    1498:	8f 01       	movw	r16, r30
// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
  uint8_t i;
  for (i=0; i<N_AXIS; i++) {
    149a:	cc 15       	cp	r28, r12
    149c:	dd 05       	cpc	r29, r13
    149e:	39 f7       	brne	.-50     	; 0x146e <gc_sync_position+0x38>
    gc_state.position[i] = sys.position[i]/settings.steps_per_mm[i];
  }
}
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	1f 91       	pop	r17
    14a6:	0f 91       	pop	r16
    14a8:	ff 90       	pop	r15
    14aa:	ef 90       	pop	r14
    14ac:	df 90       	pop	r13
    14ae:	cf 90       	pop	r12
    14b0:	bf 90       	pop	r11
    14b2:	af 90       	pop	r10
    14b4:	9f 90       	pop	r9
    14b6:	8f 90       	pop	r8
    14b8:	08 95       	ret

000014ba <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and 
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine 
// coordinates, respectively.
uint8_t gc_execute_line(char *line) 
{
    14ba:	2f 92       	push	r2
    14bc:	3f 92       	push	r3
    14be:	4f 92       	push	r4
    14c0:	5f 92       	push	r5
    14c2:	6f 92       	push	r6
    14c4:	7f 92       	push	r7
    14c6:	8f 92       	push	r8
    14c8:	9f 92       	push	r9
    14ca:	af 92       	push	r10
    14cc:	bf 92       	push	r11
    14ce:	cf 92       	push	r12
    14d0:	df 92       	push	r13
    14d2:	ef 92       	push	r14
    14d4:	ff 92       	push	r15
    14d6:	0f 93       	push	r16
    14d8:	1f 93       	push	r17
    14da:	cf 93       	push	r28
    14dc:	df 93       	push	r29
    14de:	cd b7       	in	r28, 0x3d	; 61
    14e0:	de b7       	in	r29, 0x3e	; 62
    14e2:	aa 97       	sbiw	r28, 0x2a	; 42
    14e4:	0f b6       	in	r0, 0x3f	; 63
    14e6:	f8 94       	cli
    14e8:	de bf       	out	0x3e, r29	; 62
    14ea:	0f be       	out	0x3f, r0	; 63
    14ec:	cd bf       	out	0x3d, r28	; 61
    14ee:	7c 01       	movw	r14, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
    14f0:	8b e3       	ldi	r24, 0x3B	; 59
    14f2:	e5 e4       	ldi	r30, 0x45	; 69
    14f4:	f6 e0       	ldi	r31, 0x06	; 6
    14f6:	df 01       	movw	r26, r30
    14f8:	1d 92       	st	X+, r1
    14fa:	8a 95       	dec	r24
    14fc:	e9 f7       	brne	.-6      	; 0x14f8 <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
    14fe:	8b e0       	ldi	r24, 0x0B	; 11
    1500:	ed eb       	ldi	r30, 0xBD	; 189
    1502:	f5 e0       	ldi	r31, 0x05	; 5
    1504:	a6 e4       	ldi	r26, 0x46	; 70
    1506:	b6 e0       	ldi	r27, 0x06	; 6
    1508:	01 90       	ld	r0, Z+
    150a:	0d 92       	st	X+, r0
    150c:	8a 95       	dec	r24
    150e:	e1 f7       	brne	.-8      	; 0x1508 <gc_execute_line+0x4e>
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also, 
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */
     
  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter = 0;  
    1510:	19 8e       	std	Y+25, r1	; 0x19
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Value words. 
    1512:	21 2c       	mov	r2, r1
    1514:	31 2c       	mov	r3, r1
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
    1516:	00 e0       	ldi	r16, 0x00	; 0
    1518:	10 e0       	ldi	r17, 0x00	; 0
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 
    151a:	1a a2       	std	Y+34, r1	; 0x22
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
    151c:	1e 8e       	std	Y+30, r1	; 0x1e
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */
     
  memset(&gc_block, 0, sizeof(gc_block)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
    151e:	1b a2       	std	Y+35, r1	; 0x23
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1520:	cc 24       	eor	r12, r12
    1522:	c3 94       	inc	r12
    1524:	d1 2c       	mov	r13, r1
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1526:	0f 2e       	mov	r0, r31
    1528:	f1 ec       	ldi	r31, 0xC1	; 193
    152a:	8f 2e       	mov	r8, r31
    152c:	f6 e0       	ldi	r31, 0x06	; 6
    152e:	9f 2e       	mov	r9, r31
    1530:	f0 2d       	mov	r31, r0
  float value;
  uint8_t int_value = 0;
  uint8_t mantissa = 0; // NOTE: For mantissa values > 255, variable type must be changed to uint16_t.


  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1532:	8f c2       	rjmp	.+1310   	; 0x1a52 <gc_execute_line+0x598>
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    1534:	9f eb       	ldi	r25, 0xBF	; 191
    1536:	9b 0d       	add	r25, r11
    1538:	9a 31       	cpi	r25, 0x1A	; 26
    153a:	10 f0       	brcs	.+4      	; 0x1540 <gc_execute_line+0x86>
    153c:	0c 94 92 14 	jmp	0x2924	; 0x2924 <gc_execute_line+0x146a>
    char_counter++;
    1540:	8f 5f       	subi	r24, 0xFF	; 255
    1542:	89 8f       	std	Y+25, r24	; 0x19
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    1544:	ae 01       	movw	r20, r28
    1546:	46 5e       	subi	r20, 0xE6	; 230
    1548:	5f 4f       	sbci	r21, 0xFF	; 255
    154a:	be 01       	movw	r22, r28
    154c:	67 5e       	subi	r22, 0xE7	; 231
    154e:	7f 4f       	sbci	r23, 0xFF	; 255
    1550:	c7 01       	movw	r24, r14
    1552:	0e 94 1a 2a 	call	0x5434	; 0x5434 <read_float>
    1556:	88 23       	and	r24, r24
    1558:	11 f4       	brne	.+4      	; 0x155e <gc_execute_line+0xa4>
    155a:	0c 94 94 14 	jmp	0x2928	; 0x2928 <gc_execute_line+0x146e>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant, 
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later. 
    int_value = trunc(value);
    155e:	4a 8c       	ldd	r4, Y+26	; 0x1a
    1560:	5b 8c       	ldd	r5, Y+27	; 0x1b
    1562:	6c 8c       	ldd	r6, Y+28	; 0x1c
    1564:	7d 8c       	ldd	r7, Y+29	; 0x1d
    1566:	c3 01       	movw	r24, r6
    1568:	b2 01       	movw	r22, r4
    156a:	0e 94 68 3c 	call	0x78d0	; 0x78d0 <trunc>
    156e:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    1572:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
    1574:	70 e0       	ldi	r23, 0x00	; 0
    1576:	80 e0       	ldi	r24, 0x00	; 0
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	0e 94 fe 39 	call	0x73fc	; 0x73fc <__floatsisf>
    157e:	9b 01       	movw	r18, r22
    1580:	ac 01       	movw	r20, r24
    1582:	c3 01       	movw	r24, r6
    1584:	b2 01       	movw	r22, r4
    1586:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    158a:	20 e0       	ldi	r18, 0x00	; 0
    158c:	30 e0       	ldi	r19, 0x00	; 0
    158e:	48 ec       	ldi	r20, 0xC8	; 200
    1590:	52 e4       	ldi	r21, 0x42	; 66
    1592:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    1596:	0e 94 fd 3b 	call	0x77fa	; 0x77fa <round>
    159a:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
        // NOTE: Rounding must be used to catch small floating point errors. 

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
    159e:	b7 e4       	ldi	r27, 0x47	; 71
    15a0:	bb 16       	cp	r11, r27
    15a2:	29 f0       	breq	.+10     	; 0x15ae <gc_execute_line+0xf4>
    15a4:	ed e4       	ldi	r30, 0x4D	; 77
    15a6:	be 16       	cp	r11, r30
    15a8:	09 f4       	brne	.+2      	; 0x15ac <gc_execute_line+0xf2>
    15aa:	2a c1       	rjmp	.+596    	; 0x1800 <gc_execute_line+0x346>
    15ac:	93 c1       	rjmp	.+806    	; 0x18d4 <gc_execute_line+0x41a>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
         
      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
    15ae:	8a 2d       	mov	r24, r10
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	8f 35       	cpi	r24, 0x5F	; 95
    15b4:	91 05       	cpc	r25, r1
    15b6:	10 f0       	brcs	.+4      	; 0x15bc <gc_execute_line+0x102>
    15b8:	0c 94 96 14 	jmp	0x292c	; 0x292c <gc_execute_line+0x1472>
    15bc:	fc 01       	movw	r30, r24
    15be:	ec 5c       	subi	r30, 0xCC	; 204
    15c0:	ff 4f       	sbci	r31, 0xFF	; 255
    15c2:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
    15c6:	61 11       	cpse	r22, r1
    15c8:	06 c0       	rjmp	.+12     	; 0x15d6 <gc_execute_line+0x11c>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    15ca:	fb a1       	ldd	r31, Y+35	; 0x23
    15cc:	f1 11       	cpse	r31, r1
    15ce:	0c 94 98 14 	jmp	0x2930	; 0x2930 <gc_execute_line+0x1476>
              axis_command = AXIS_COMMAND_NON_MODAL;
    15d2:	21 e0       	ldi	r18, 0x01	; 1
    15d4:	2b a3       	std	Y+35, r18	; 0x23
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
    15d6:	3c e1       	ldi	r19, 0x1C	; 28
    15d8:	a3 16       	cp	r10, r19
    15da:	f9 f0       	breq	.+62     	; 0x161a <gc_execute_line+0x160>
    15dc:	3a 15       	cp	r19, r10
    15de:	38 f0       	brcs	.+14     	; 0x15ee <gc_execute_line+0x134>
    15e0:	84 e0       	ldi	r24, 0x04	; 4
    15e2:	a8 16       	cp	r10, r24
    15e4:	71 f0       	breq	.+28     	; 0x1602 <gc_execute_line+0x148>
    15e6:	9a e0       	ldi	r25, 0x0A	; 10
    15e8:	a9 16       	cp	r10, r25
    15ea:	89 f0       	breq	.+34     	; 0x160e <gc_execute_line+0x154>
    15ec:	f1 c0       	rjmp	.+482    	; 0x17d0 <gc_execute_line+0x316>
    15ee:	a5 e3       	ldi	r26, 0x35	; 53
    15f0:	aa 16       	cp	r10, r26
    15f2:	b9 f1       	breq	.+110    	; 0x1662 <gc_execute_line+0x1a8>
    15f4:	bc e5       	ldi	r27, 0x5C	; 92
    15f6:	ab 16       	cp	r10, r27
    15f8:	d1 f1       	breq	.+116    	; 0x166e <gc_execute_line+0x1b4>
    15fa:	ee e1       	ldi	r30, 0x1E	; 30
    15fc:	ae 12       	cpse	r10, r30
    15fe:	e8 c0       	rjmp	.+464    	; 0x17d0 <gc_execute_line+0x316>
    1600:	1e c0       	rjmp	.+60     	; 0x163e <gc_execute_line+0x184>
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
    1602:	81 e0       	ldi	r24, 0x01	; 1
    1604:	a5 e4       	ldi	r26, 0x45	; 69
    1606:	b6 e0       	ldi	r27, 0x06	; 6
    1608:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    160a:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
    160c:	e6 c0       	rjmp	.+460    	; 0x17da <gc_execute_line+0x320>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
    160e:	82 e0       	ldi	r24, 0x02	; 2
    1610:	e5 e4       	ldi	r30, 0x45	; 69
    1612:	f6 e0       	ldi	r31, 0x06	; 6
    1614:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1616:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
    1618:	e0 c0       	rjmp	.+448    	; 0x17da <gc_execute_line+0x320>
              case 28:
                switch(mantissa) {
    161a:	66 23       	and	r22, r22
    161c:	21 f0       	breq	.+8      	; 0x1626 <gc_execute_line+0x16c>
    161e:	6a 30       	cpi	r22, 0x0A	; 10
    1620:	41 f0       	breq	.+16     	; 0x1632 <gc_execute_line+0x178>
    1622:	0c 94 9a 14 	jmp	0x2934	; 0x2934 <gc_execute_line+0x147a>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
    1626:	83 e0       	ldi	r24, 0x03	; 3
    1628:	a5 e4       	ldi	r26, 0x45	; 69
    162a:	b6 e0       	ldi	r27, 0x06	; 6
    162c:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    162e:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
    1630:	d7 c0       	rjmp	.+430    	; 0x17e0 <gc_execute_line+0x326>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
    1632:	84 e0       	ldi	r24, 0x04	; 4
    1634:	e5 e4       	ldi	r30, 0x45	; 69
    1636:	f6 e0       	ldi	r31, 0x06	; 6
    1638:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    163a:	80 e0       	ldi	r24, 0x00	; 0
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
    163c:	d1 c0       	rjmp	.+418    	; 0x17e0 <gc_execute_line+0x326>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
    163e:	66 23       	and	r22, r22
    1640:	21 f0       	breq	.+8      	; 0x164a <gc_execute_line+0x190>
    1642:	6a 30       	cpi	r22, 0x0A	; 10
    1644:	41 f0       	breq	.+16     	; 0x1656 <gc_execute_line+0x19c>
    1646:	0c 94 9c 14 	jmp	0x2938	; 0x2938 <gc_execute_line+0x147e>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
    164a:	85 e0       	ldi	r24, 0x05	; 5
    164c:	a5 e4       	ldi	r26, 0x45	; 69
    164e:	b6 e0       	ldi	r27, 0x06	; 6
    1650:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1652:	80 e0       	ldi	r24, 0x00	; 0
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
    1654:	c5 c0       	rjmp	.+394    	; 0x17e0 <gc_execute_line+0x326>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
    1656:	86 e0       	ldi	r24, 0x06	; 6
    1658:	e5 e4       	ldi	r30, 0x45	; 69
    165a:	f6 e0       	ldi	r31, 0x06	; 6
    165c:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    165e:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
    1660:	bf c0       	rjmp	.+382    	; 0x17e0 <gc_execute_line+0x326>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
    1662:	87 e0       	ldi	r24, 0x07	; 7
    1664:	a5 e4       	ldi	r26, 0x45	; 69
    1666:	b6 e0       	ldi	r27, 0x06	; 6
    1668:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    166a:	80 e0       	ldi	r24, 0x00	; 0
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
    166c:	b6 c0       	rjmp	.+364    	; 0x17da <gc_execute_line+0x320>
              case 92: 
                switch(mantissa) {
    166e:	66 23       	and	r22, r22
    1670:	21 f0       	breq	.+8      	; 0x167a <gc_execute_line+0x1c0>
    1672:	6a 30       	cpi	r22, 0x0A	; 10
    1674:	41 f0       	breq	.+16     	; 0x1686 <gc_execute_line+0x1cc>
    1676:	0c 94 9e 14 	jmp	0x293c	; 0x293c <gc_execute_line+0x1482>
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
    167a:	88 e0       	ldi	r24, 0x08	; 8
    167c:	e5 e4       	ldi	r30, 0x45	; 69
    167e:	f6 e0       	ldi	r31, 0x06	; 6
    1680:	80 83       	st	Z, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    1682:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
    1684:	ad c0       	rjmp	.+346    	; 0x17e0 <gc_execute_line+0x326>
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
    1686:	89 e0       	ldi	r24, 0x09	; 9
    1688:	a5 e4       	ldi	r26, 0x45	; 69
    168a:	b6 e0       	ldi	r27, 0x06	; 6
    168c:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    168e:	80 e0       	ldi	r24, 0x00	; 0
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
    1690:	a7 c0       	rjmp	.+334    	; 0x17e0 <gc_execute_line+0x326>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1692:	bb a1       	ldd	r27, Y+35	; 0x23
    1694:	b1 11       	cpse	r27, r1
    1696:	0c 94 a0 14 	jmp	0x2940	; 0x2940 <gc_execute_line+0x1486>
            axis_command = AXIS_COMMAND_MOTION_MODE; 
    169a:	e2 e0       	ldi	r30, 0x02	; 2
    169c:	eb a3       	std	Y+35, r30	; 0x23
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
            switch(int_value) {
    169e:	f2 e0       	ldi	r31, 0x02	; 2
    16a0:	af 16       	cp	r10, r31
    16a2:	e1 f0       	breq	.+56     	; 0x16dc <gc_execute_line+0x222>
    16a4:	fa 15       	cp	r31, r10
    16a6:	30 f0       	brcs	.+12     	; 0x16b4 <gc_execute_line+0x1fa>
    16a8:	aa 20       	and	r10, r10
    16aa:	71 f0       	breq	.+28     	; 0x16c8 <gc_execute_line+0x20e>
    16ac:	21 e0       	ldi	r18, 0x01	; 1
    16ae:	a2 16       	cp	r10, r18
    16b0:	81 f0       	breq	.+32     	; 0x16d2 <gc_execute_line+0x218>
    16b2:	90 c0       	rjmp	.+288    	; 0x17d4 <gc_execute_line+0x31a>
    16b4:	36 e2       	ldi	r19, 0x26	; 38
    16b6:	a3 16       	cp	r10, r19
    16b8:	e9 f0       	breq	.+58     	; 0x16f4 <gc_execute_line+0x23a>
    16ba:	80 e5       	ldi	r24, 0x50	; 80
    16bc:	a8 16       	cp	r10, r24
    16be:	21 f1       	breq	.+72     	; 0x1708 <gc_execute_line+0x24e>
    16c0:	93 e0       	ldi	r25, 0x03	; 3
    16c2:	a9 12       	cpse	r10, r25
    16c4:	87 c0       	rjmp	.+270    	; 0x17d4 <gc_execute_line+0x31a>
    16c6:	10 c0       	rjmp	.+32     	; 0x16e8 <gc_execute_line+0x22e>
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
    16c8:	a6 e4       	ldi	r26, 0x46	; 70
    16ca:	b6 e0       	ldi	r27, 0x06	; 6
    16cc:	1c 92       	st	X, r1
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    16ce:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
    16d0:	84 c0       	rjmp	.+264    	; 0x17da <gc_execute_line+0x320>
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	e6 e4       	ldi	r30, 0x46	; 70
    16d6:	f6 e0       	ldi	r31, 0x06	; 6
    16d8:	80 83       	st	Z, r24
    16da:	7f c0       	rjmp	.+254    	; 0x17da <gc_execute_line+0x320>
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
    16dc:	82 e0       	ldi	r24, 0x02	; 2
    16de:	a6 e4       	ldi	r26, 0x46	; 70
    16e0:	b6 e0       	ldi	r27, 0x06	; 6
    16e2:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    16e4:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
    16e6:	79 c0       	rjmp	.+242    	; 0x17da <gc_execute_line+0x320>
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
    16e8:	83 e0       	ldi	r24, 0x03	; 3
    16ea:	e6 e4       	ldi	r30, 0x46	; 70
    16ec:	f6 e0       	ldi	r31, 0x06	; 6
    16ee:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    16f0:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
    16f2:	73 c0       	rjmp	.+230    	; 0x17da <gc_execute_line+0x320>
              case 38: 
                switch(mantissa) {
    16f4:	64 31       	cpi	r22, 0x14	; 20
    16f6:	11 f0       	breq	.+4      	; 0x16fc <gc_execute_line+0x242>
    16f8:	0c 94 a2 14 	jmp	0x2944	; 0x2944 <gc_execute_line+0x148a>
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE; break;  // G38.2
    16fc:	84 e0       	ldi	r24, 0x04	; 4
    16fe:	a6 e4       	ldi	r26, 0x46	; 70
    1700:	b6 e0       	ldi	r27, 0x06	; 6
    1702:	8c 93       	st	X, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1704:	81 e0       	ldi	r24, 0x01	; 1
                  // case 40: // Not supported.
                  // case 50: // Not supported.
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
    1706:	6c c0       	rjmp	.+216    	; 0x17e0 <gc_execute_line+0x326>
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
    1708:	85 e0       	ldi	r24, 0x05	; 5
    170a:	e6 e4       	ldi	r30, 0x46	; 70
    170c:	f6 e0       	ldi	r31, 0x06	; 6
    170e:	80 83       	st	Z, r24
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    1710:	81 e0       	ldi	r24, 0x01	; 1
                  // case 50: // Not supported.
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
    1712:	63 c0       	rjmp	.+198    	; 0x17da <gc_execute_line+0x320>
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
            switch(int_value) {
    1714:	f2 e1       	ldi	r31, 0x12	; 18
    1716:	af 16       	cp	r10, r31
    1718:	59 f0       	breq	.+22     	; 0x1730 <gc_execute_line+0x276>
    171a:	23 e1       	ldi	r18, 0x13	; 19
    171c:	a2 16       	cp	r10, r18
    171e:	71 f0       	breq	.+28     	; 0x173c <gc_execute_line+0x282>
    1720:	31 e1       	ldi	r19, 0x11	; 17
    1722:	a3 12       	cpse	r10, r19
    1724:	59 c0       	rjmp	.+178    	; 0x17d8 <gc_execute_line+0x31e>
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
    1726:	aa e4       	ldi	r26, 0x4A	; 74
    1728:	b6 e0       	ldi	r27, 0x06	; 6
    172a:	1c 92       	st	X, r1
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    172c:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
    172e:	55 c0       	rjmp	.+170    	; 0x17da <gc_execute_line+0x320>
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	ea e4       	ldi	r30, 0x4A	; 74
    1734:	f6 e0       	ldi	r31, 0x06	; 6
    1736:	80 83       	st	Z, r24
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    1738:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
    173a:	4f c0       	rjmp	.+158    	; 0x17da <gc_execute_line+0x320>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
    173c:	82 e0       	ldi	r24, 0x02	; 2
    173e:	aa e4       	ldi	r26, 0x4A	; 74
    1740:	b6 e0       	ldi	r27, 0x06	; 6
    1742:	8c 93       	st	X, r24
    1744:	4a c0       	rjmp	.+148    	; 0x17da <gc_execute_line+0x320>
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
    1746:	ba e5       	ldi	r27, 0x5A	; 90
    1748:	ab 12       	cpse	r10, r27
    174a:	05 c0       	rjmp	.+10     	; 0x1756 <gc_execute_line+0x29c>
    174c:	e9 e4       	ldi	r30, 0x49	; 73
    174e:	f6 e0       	ldi	r31, 0x06	; 6
    1750:	10 82       	st	Z, r1
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
    1752:	83 e0       	ldi	r24, 0x03	; 3
    1754:	42 c0       	rjmp	.+132    	; 0x17da <gc_execute_line+0x320>
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	a9 e4       	ldi	r26, 0x49	; 73
    175a:	b6 e0       	ldi	r27, 0x06	; 6
    175c:	8c 93       	st	X, r24
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            word_bit = MODAL_GROUP_G3; 
    175e:	83 e0       	ldi	r24, 0x03	; 3
    1760:	3c c0       	rjmp	.+120    	; 0x17da <gc_execute_line+0x320>
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
    1762:	bd e5       	ldi	r27, 0x5D	; 93
    1764:	ab 12       	cpse	r10, r27
    1766:	06 c0       	rjmp	.+12     	; 0x1774 <gc_execute_line+0x2ba>
    1768:	81 e0       	ldi	r24, 0x01	; 1
    176a:	e7 e4       	ldi	r30, 0x47	; 71
    176c:	f6 e0       	ldi	r31, 0x06	; 6
    176e:	80 83       	st	Z, r24
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
    1770:	84 e0       	ldi	r24, 0x04	; 4
    1772:	33 c0       	rjmp	.+102    	; 0x17da <gc_execute_line+0x320>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
    1774:	a7 e4       	ldi	r26, 0x47	; 71
    1776:	b6 e0       	ldi	r27, 0x06	; 6
    1778:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G3; 
            if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
            else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91            
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
    177a:	84 e0       	ldi	r24, 0x04	; 4
    177c:	2e c0       	rjmp	.+92     	; 0x17da <gc_execute_line+0x320>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
    177e:	b4 e1       	ldi	r27, 0x14	; 20
    1780:	ab 12       	cpse	r10, r27
    1782:	06 c0       	rjmp	.+12     	; 0x1790 <gc_execute_line+0x2d6>
    1784:	81 e0       	ldi	r24, 0x01	; 1
    1786:	e8 e4       	ldi	r30, 0x48	; 72
    1788:	f6 e0       	ldi	r31, 0x06	; 6
    178a:	80 83       	st	Z, r24
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
    178c:	85 e0       	ldi	r24, 0x05	; 5
    178e:	25 c0       	rjmp	.+74     	; 0x17da <gc_execute_line+0x320>
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
    1790:	a8 e4       	ldi	r26, 0x48	; 72
    1792:	b6 e0       	ldi	r27, 0x06	; 6
    1794:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
    1796:	85 e0       	ldi	r24, 0x05	; 5
    1798:	20 c0       	rjmp	.+64     	; 0x17da <gc_execute_line+0x320>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            switch (int_value) {
    179a:	bb e2       	ldi	r27, 0x2B	; 43
    179c:	ab 16       	cp	r10, r27
    179e:	49 f0       	breq	.+18     	; 0x17b2 <gc_execute_line+0x2f8>
    17a0:	e1 e3       	ldi	r30, 0x31	; 49
    17a2:	ae 12       	cpse	r10, r30
    17a4:	0c 94 a4 14 	jmp	0x2948	; 0x2948 <gc_execute_line+0x148e>
				case 49: gc_block.modal.tool_comp = 0; break;
    17a8:	a0 e5       	ldi	r26, 0x50	; 80
    17aa:	b6 e0       	ldi	r27, 0x06	; 6
    17ac:	1c 92       	st	X, r1
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    17ae:	86 e0       	ldi	r24, 0x06	; 6
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            switch (int_value) {
				case 49: gc_block.modal.tool_comp = 0; break;
    17b0:	17 c0       	rjmp	.+46     	; 0x17e0 <gc_execute_line+0x326>
				case 43: gc_block.modal.tool_comp = gc_block.values.h; break;
    17b2:	e5 e5       	ldi	r30, 0x55	; 85
    17b4:	f6 e0       	ldi	r31, 0x06	; 6
    17b6:	80 81       	ld	r24, Z
    17b8:	a0 e5       	ldi	r26, 0x50	; 80
    17ba:	b6 e0       	ldi	r27, 0x06	; 6
    17bc:	8c 93       	st	X, r24
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
    17be:	86 e0       	ldi	r24, 0x06	; 6
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            switch (int_value) {
				case 49: gc_block.modal.tool_comp = 0; break;
				case 43: gc_block.modal.tool_comp = gc_block.values.h; break;
    17c0:	0f c0       	rjmp	.+30     	; 0x17e0 <gc_execute_line+0x326>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
    17c2:	8a ec       	ldi	r24, 0xCA	; 202
    17c4:	8a 0d       	add	r24, r10
    17c6:	eb e4       	ldi	r30, 0x4B	; 75
    17c8:	f6 e0       	ldi	r31, 0x06	; 6
    17ca:	80 83       	st	Z, r24
            } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
    17cc:	87 e0       	ldi	r24, 0x07	; 7
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
    17ce:	05 c0       	rjmp	.+10     	; 0x17da <gc_execute_line+0x320>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
    17d0:	80 e0       	ldi	r24, 0x00	; 0
    17d2:	03 c0       	rjmp	.+6      	; 0x17da <gc_execute_line+0x320>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	01 c0       	rjmp	.+2      	; 0x17da <gc_execute_line+0x320>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
    17d8:	82 e0       	ldi	r24, 0x02	; 2
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    17da:	61 11       	cpse	r22, r1
    17dc:	0c 94 a6 14 	jmp	0x294c	; 0x294c <gc_execute_line+0x1492>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    17e0:	96 01       	movw	r18, r12
    17e2:	02 c0       	rjmp	.+4      	; 0x17e8 <gc_execute_line+0x32e>
    17e4:	22 0f       	add	r18, r18
    17e6:	33 1f       	adc	r19, r19
    17e8:	8a 95       	dec	r24
    17ea:	e2 f7       	brpl	.-8      	; 0x17e4 <gc_execute_line+0x32a>
    17ec:	c9 01       	movw	r24, r18
    17ee:	20 23       	and	r18, r16
    17f0:	31 23       	and	r19, r17
    17f2:	23 2b       	or	r18, r19
    17f4:	11 f0       	breq	.+4      	; 0x17fa <gc_execute_line+0x340>
    17f6:	0c 94 a8 14 	jmp	0x2950	; 0x2950 <gc_execute_line+0x1496>
        bit_true(command_words,bit(word_bit));
    17fa:	08 2b       	or	r16, r24
    17fc:	19 2b       	or	r17, r25
        break;
    17fe:	29 c1       	rjmp	.+594    	; 0x1a52 <gc_execute_line+0x598>
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    1800:	61 11       	cpse	r22, r1
    1802:	0c 94 aa 14 	jmp	0x2954	; 0x2954 <gc_execute_line+0x149a>
        switch(int_value) {
    1806:	8a 2d       	mov	r24, r10
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	8f 31       	cpi	r24, 0x1F	; 31
    180c:	91 05       	cpc	r25, r1
    180e:	10 f0       	brcs	.+4      	; 0x1814 <gc_execute_line+0x35a>
    1810:	0c 94 ac 14 	jmp	0x2958	; 0x2958 <gc_execute_line+0x149e>
    1814:	fc 01       	movw	r30, r24
    1816:	ed 56       	subi	r30, 0x6D	; 109
    1818:	ff 4f       	sbci	r31, 0xFF	; 255
    181a:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
            switch(int_value) {
    181e:	32 e0       	ldi	r19, 0x02	; 2
    1820:	a3 16       	cp	r10, r19
    1822:	51 f0       	breq	.+20     	; 0x1838 <gc_execute_line+0x37e>
    1824:	8e e1       	ldi	r24, 0x1E	; 30
    1826:	a8 16       	cp	r10, r24
    1828:	39 f0       	breq	.+14     	; 0x1838 <gc_execute_line+0x37e>
    182a:	a1 10       	cpse	r10, r1
    182c:	3e c0       	rjmp	.+124    	; 0x18aa <gc_execute_line+0x3f0>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    182e:	81 e0       	ldi	r24, 0x01	; 1
    1830:	80 93 4c 06 	sts	0x064C, r24
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1834:	88 e0       	ldi	r24, 0x08	; 8
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1836:	3e c0       	rjmp	.+124    	; 0x18b4 <gc_execute_line+0x3fa>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1838:	82 e0       	ldi	r24, 0x02	; 2
    183a:	80 93 4c 06 	sts	0x064C, r24
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    183e:	88 e0       	ldi	r24, 0x08	; 8
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1840:	39 c0       	rjmp	.+114    	; 0x18b4 <gc_execute_line+0x3fa>
            }
            break;
		  case 6:
		    word_bit = MODAL_GROUP_M6;
		    gc_block.modal.tool = gc_block.values.t;
    1842:	80 91 73 06 	lds	r24, 0x0673
    1846:	80 93 4f 06 	sts	0x064F, r24
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
            }
            break;
		  case 6:
		    word_bit = MODAL_GROUP_M6;
    184a:	89 e0       	ldi	r24, 0x09	; 9
		    gc_block.modal.tool = gc_block.values.t;
		    break;
    184c:	33 c0       	rjmp	.+102    	; 0x18b4 <gc_execute_line+0x3fa>
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7; 
            switch(int_value) {
    184e:	94 e0       	ldi	r25, 0x04	; 4
    1850:	a9 16       	cp	r10, r25
    1852:	59 f0       	breq	.+22     	; 0x186a <gc_execute_line+0x3b0>
    1854:	a5 e0       	ldi	r26, 0x05	; 5
    1856:	aa 16       	cp	r10, r26
    1858:	69 f0       	breq	.+26     	; 0x1874 <gc_execute_line+0x3ba>
    185a:	b3 e0       	ldi	r27, 0x03	; 3
    185c:	ab 12       	cpse	r10, r27
    185e:	27 c0       	rjmp	.+78     	; 0x18ae <gc_execute_line+0x3f4>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1860:	81 e0       	ldi	r24, 0x01	; 1
    1862:	80 93 4e 06 	sts	0x064E, r24
		  case 6:
		    word_bit = MODAL_GROUP_M6;
		    gc_block.modal.tool = gc_block.values.t;
		    break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7; 
    1866:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1868:	25 c0       	rjmp	.+74     	; 0x18b4 <gc_execute_line+0x3fa>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    186a:	82 e0       	ldi	r24, 0x02	; 2
    186c:	80 93 4e 06 	sts	0x064E, r24
		  case 6:
		    word_bit = MODAL_GROUP_M6;
		    gc_block.modal.tool = gc_block.values.t;
		    break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7; 
    1870:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1872:	20 c0       	rjmp	.+64     	; 0x18b4 <gc_execute_line+0x3fa>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1874:	10 92 4e 06 	sts	0x064E, r1
		  case 6:
		    word_bit = MODAL_GROUP_M6;
		    gc_block.modal.tool = gc_block.values.t;
		    break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7; 
    1878:	8a e0       	ldi	r24, 0x0A	; 10
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    187a:	1c c0       	rjmp	.+56     	; 0x18b4 <gc_execute_line+0x3fa>
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    187c:	e8 e0       	ldi	r30, 0x08	; 8
    187e:	ae 16       	cp	r10, r30
    1880:	59 f0       	breq	.+22     	; 0x1898 <gc_execute_line+0x3de>
    1882:	f9 e0       	ldi	r31, 0x09	; 9
    1884:	af 16       	cp	r10, r31
    1886:	69 f0       	breq	.+26     	; 0x18a2 <gc_execute_line+0x3e8>
    1888:	27 e0       	ldi	r18, 0x07	; 7
    188a:	a2 12       	cpse	r10, r18
    188c:	12 c0       	rjmp	.+36     	; 0x18b2 <gc_execute_line+0x3f8>
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
    188e:	81 e0       	ldi	r24, 0x01	; 1
    1890:	80 93 4d 06 	sts	0x064D, r24
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1894:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
    1896:	0e c0       	rjmp	.+28     	; 0x18b4 <gc_execute_line+0x3fa>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1898:	82 e0       	ldi	r24, 0x02	; 2
    189a:	80 93 4d 06 	sts	0x064D, r24
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    189e:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    18a0:	09 c0       	rjmp	.+18     	; 0x18b4 <gc_execute_line+0x3fa>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    18a2:	10 92 4d 06 	sts	0x064D, r1
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    18a6:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    18a8:	05 c0       	rjmp	.+10     	; 0x18b4 <gc_execute_line+0x3fa>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    18aa:	88 e0       	ldi	r24, 0x08	; 8
    18ac:	03 c0       	rjmp	.+6      	; 0x18b4 <gc_execute_line+0x3fa>
		  case 6:
		    word_bit = MODAL_GROUP_M6;
		    gc_block.modal.tool = gc_block.values.t;
		    break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7; 
    18ae:	8a e0       	ldi	r24, 0x0A	; 10
    18b0:	01 c0       	rjmp	.+2      	; 0x18b4 <gc_execute_line+0x3fa>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    18b2:	8b e0       	ldi	r24, 0x0B	; 11
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }            
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    18b4:	d6 01       	movw	r26, r12
    18b6:	02 c0       	rjmp	.+4      	; 0x18bc <gc_execute_line+0x402>
    18b8:	aa 0f       	add	r26, r26
    18ba:	bb 1f       	adc	r27, r27
    18bc:	8a 95       	dec	r24
    18be:	e2 f7       	brpl	.-8      	; 0x18b8 <gc_execute_line+0x3fe>
    18c0:	9d 01       	movw	r18, r26
    18c2:	20 23       	and	r18, r16
    18c4:	31 23       	and	r19, r17
    18c6:	23 2b       	or	r18, r19
    18c8:	11 f0       	breq	.+4      	; 0x18ce <gc_execute_line+0x414>
    18ca:	0c 94 ae 14 	jmp	0x295c	; 0x295c <gc_execute_line+0x14a2>
        bit_true(command_words,bit(word_bit));
    18ce:	0a 2b       	or	r16, r26
    18d0:	1b 2b       	or	r17, r27
        break;
    18d2:	bf c0       	rjmp	.+382    	; 0x1a52 <gc_execute_line+0x598>
      default: 
  
        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    18d4:	8b 2d       	mov	r24, r11
    18d6:	90 e0       	ldi	r25, 0x00	; 0
    18d8:	fc 01       	movw	r30, r24
    18da:	e6 54       	subi	r30, 0x46	; 70
    18dc:	f1 09       	sbc	r31, r1
    18de:	e5 31       	cpi	r30, 0x15	; 21
    18e0:	f1 05       	cpc	r31, r1
    18e2:	10 f0       	brcs	.+4      	; 0x18e8 <gc_execute_line+0x42e>
    18e4:	0c 94 b0 14 	jmp	0x2960	; 0x2960 <gc_execute_line+0x14a6>
    18e8:	ee 54       	subi	r30, 0x4E	; 78
    18ea:	ff 4f       	sbci	r31, 0xFF	; 255
    18ec:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    18f0:	40 92 51 06 	sts	0x0651, r4
    18f4:	50 92 52 06 	sts	0x0652, r5
    18f8:	60 92 53 06 	sts	0x0653, r6
    18fc:	70 92 54 06 	sts	0x0654, r7
    1900:	20 e0       	ldi	r18, 0x00	; 0
    1902:	86 c0       	rjmp	.+268    	; 0x1a10 <gc_execute_line+0x556>
          case 'H': word_bit = WORD_H; gc_block.values.h = int_value; break;
    1904:	e5 e5       	ldi	r30, 0x55	; 85
    1906:	f6 e0       	ldi	r31, 0x06	; 6
    1908:	a0 82       	st	Z, r10
    190a:	21 e0       	ldi	r18, 0x01	; 1
    190c:	81 c0       	rjmp	.+258    	; 0x1a10 <gc_execute_line+0x556>
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    190e:	40 92 56 06 	sts	0x0656, r4
    1912:	50 92 57 06 	sts	0x0657, r5
    1916:	60 92 58 06 	sts	0x0658, r6
    191a:	70 92 59 06 	sts	0x0659, r7
    191e:	fa a1       	ldd	r31, Y+34	; 0x22
    1920:	f1 60       	ori	r31, 0x01	; 1
    1922:	fa a3       	std	Y+34, r31	; 0x22
    1924:	22 e0       	ldi	r18, 0x02	; 2
    1926:	74 c0       	rjmp	.+232    	; 0x1a10 <gc_execute_line+0x556>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    1928:	40 92 5a 06 	sts	0x065A, r4
    192c:	50 92 5b 06 	sts	0x065B, r5
    1930:	60 92 5c 06 	sts	0x065C, r6
    1934:	70 92 5d 06 	sts	0x065D, r7
    1938:	2a a1       	ldd	r18, Y+34	; 0x22
    193a:	22 60       	ori	r18, 0x02	; 2
    193c:	2a a3       	std	Y+34, r18	; 0x22
    193e:	23 e0       	ldi	r18, 0x03	; 3
    1940:	67 c0       	rjmp	.+206    	; 0x1a10 <gc_execute_line+0x556>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    1942:	40 92 5e 06 	sts	0x065E, r4
    1946:	50 92 5f 06 	sts	0x065F, r5
    194a:	60 92 60 06 	sts	0x0660, r6
    194e:	70 92 61 06 	sts	0x0661, r7
    1952:	3a a1       	ldd	r19, Y+34	; 0x22
    1954:	34 60       	ori	r19, 0x04	; 4
    1956:	3a a3       	std	Y+34, r19	; 0x22
    1958:	24 e0       	ldi	r18, 0x04	; 4
    195a:	5a c0       	rjmp	.+180    	; 0x1a10 <gc_execute_line+0x556>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    195c:	a0 92 62 06 	sts	0x0662, r10
    1960:	25 e0       	ldi	r18, 0x05	; 5
    1962:	56 c0       	rjmp	.+172    	; 0x1a10 <gc_execute_line+0x556>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    1964:	c3 01       	movw	r24, r6
    1966:	b2 01       	movw	r22, r4
    1968:	0e 94 cb 39 	call	0x7396	; 0x7396 <__fixsfsi>
    196c:	60 93 63 06 	sts	0x0663, r22
    1970:	70 93 64 06 	sts	0x0664, r23
    1974:	80 93 65 06 	sts	0x0665, r24
    1978:	90 93 66 06 	sts	0x0666, r25
    197c:	26 e0       	ldi	r18, 0x06	; 6
    197e:	48 c0       	rjmp	.+144    	; 0x1a10 <gc_execute_line+0x556>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    1980:	40 92 67 06 	sts	0x0667, r4
    1984:	50 92 68 06 	sts	0x0668, r5
    1988:	60 92 69 06 	sts	0x0669, r6
    198c:	70 92 6a 06 	sts	0x066A, r7
    1990:	27 e0       	ldi	r18, 0x07	; 7
    1992:	3e c0       	rjmp	.+124    	; 0x1a10 <gc_execute_line+0x556>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1994:	40 92 6b 06 	sts	0x066B, r4
    1998:	50 92 6c 06 	sts	0x066C, r5
    199c:	60 92 6d 06 	sts	0x066D, r6
    19a0:	70 92 6e 06 	sts	0x066E, r7
    19a4:	28 e0       	ldi	r18, 0x08	; 8
    19a6:	34 c0       	rjmp	.+104    	; 0x1a10 <gc_execute_line+0x556>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    19a8:	40 92 6f 06 	sts	0x066F, r4
    19ac:	50 92 70 06 	sts	0x0670, r5
    19b0:	60 92 71 06 	sts	0x0671, r6
    19b4:	70 92 72 06 	sts	0x0672, r7
    19b8:	29 e0       	ldi	r18, 0x09	; 9
    19ba:	2a c0       	rjmp	.+84     	; 0x1a10 <gc_execute_line+0x556>
          case 'T': word_bit = WORD_T; gc_block.values.t = int_value; break;
    19bc:	a0 92 73 06 	sts	0x0673, r10
    19c0:	2a e0       	ldi	r18, 0x0A	; 10
    19c2:	26 c0       	rjmp	.+76     	; 0x1a10 <gc_execute_line+0x556>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    19c4:	40 92 74 06 	sts	0x0674, r4
    19c8:	50 92 75 06 	sts	0x0675, r5
    19cc:	60 92 76 06 	sts	0x0676, r6
    19d0:	70 92 77 06 	sts	0x0677, r7
    19d4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    19d6:	81 60       	ori	r24, 0x01	; 1
    19d8:	8e 8f       	std	Y+30, r24	; 0x1e
    19da:	2b e0       	ldi	r18, 0x0B	; 11
    19dc:	19 c0       	rjmp	.+50     	; 0x1a10 <gc_execute_line+0x556>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    19de:	40 92 78 06 	sts	0x0678, r4
    19e2:	50 92 79 06 	sts	0x0679, r5
    19e6:	60 92 7a 06 	sts	0x067A, r6
    19ea:	70 92 7b 06 	sts	0x067B, r7
    19ee:	9e 8d       	ldd	r25, Y+30	; 0x1e
    19f0:	92 60       	ori	r25, 0x02	; 2
    19f2:	9e 8f       	std	Y+30, r25	; 0x1e
    19f4:	2c e0       	ldi	r18, 0x0C	; 12
    19f6:	0c c0       	rjmp	.+24     	; 0x1a10 <gc_execute_line+0x556>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    19f8:	40 92 7c 06 	sts	0x067C, r4
    19fc:	50 92 7d 06 	sts	0x067D, r5
    1a00:	60 92 7e 06 	sts	0x067E, r6
    1a04:	70 92 7f 06 	sts	0x067F, r7
    1a08:	ae 8d       	ldd	r26, Y+30	; 0x1e
    1a0a:	a4 60       	ori	r26, 0x04	; 4
    1a0c:	ae 8f       	std	Y+30, r26	; 0x1e
    1a0e:	2d e0       	ldi	r18, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1a10:	56 01       	movw	r10, r12
    1a12:	02 2e       	mov	r0, r18
    1a14:	02 c0       	rjmp	.+4      	; 0x1a1a <gc_execute_line+0x560>
    1a16:	aa 0c       	add	r10, r10
    1a18:	bb 1c       	adc	r11, r11
    1a1a:	0a 94       	dec	r0
    1a1c:	e2 f7       	brpl	.-8      	; 0x1a16 <gc_execute_line+0x55c>
    1a1e:	c5 01       	movw	r24, r10
    1a20:	82 21       	and	r24, r2
    1a22:	93 21       	and	r25, r3
    1a24:	89 2b       	or	r24, r25
    1a26:	09 f0       	breq	.+2      	; 0x1a2a <gc_execute_line+0x570>
    1a28:	9d c7       	rjmp	.+3898   	; 0x2964 <gc_execute_line+0x14aa>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    1a2a:	c4 01       	movw	r24, r8
    1a2c:	02 c0       	rjmp	.+4      	; 0x1a32 <gc_execute_line+0x578>
    1a2e:	95 95       	asr	r25
    1a30:	87 95       	ror	r24
    1a32:	2a 95       	dec	r18
    1a34:	e2 f7       	brpl	.-8      	; 0x1a2e <gc_execute_line+0x574>
    1a36:	80 ff       	sbrs	r24, 0
    1a38:	0a c0       	rjmp	.+20     	; 0x1a4e <gc_execute_line+0x594>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    1a3a:	20 e0       	ldi	r18, 0x00	; 0
    1a3c:	30 e0       	ldi	r19, 0x00	; 0
    1a3e:	a9 01       	movw	r20, r18
    1a40:	c3 01       	movw	r24, r6
    1a42:	b2 01       	movw	r22, r4
    1a44:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    1a48:	88 23       	and	r24, r24
    1a4a:	0c f4       	brge	.+2      	; 0x1a4e <gc_execute_line+0x594>
    1a4c:	8d c7       	rjmp	.+3866   	; 0x2968 <gc_execute_line+0x14ae>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    1a4e:	2a 28       	or	r2, r10
    1a50:	3b 28       	or	r3, r11
  float value;
  uint8_t int_value = 0;
  uint8_t mantissa = 0; // NOTE: For mantissa values > 255, variable type must be changed to uint16_t.


  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1a52:	89 8d       	ldd	r24, Y+25	; 0x19
    1a54:	f7 01       	movw	r30, r14
    1a56:	e8 0f       	add	r30, r24
    1a58:	f1 1d       	adc	r31, r1
    1a5a:	b0 80       	ld	r11, Z
    1a5c:	b1 10       	cpse	r11, r1
    1a5e:	6a cd       	rjmp	.-1324   	; 0x1534 <gc_execute_line+0x7a>
    1a60:	71 01       	movw	r14, r2
    1a62:	8b a1       	ldd	r24, Y+35	; 0x23
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  
  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    1a64:	be 8d       	ldd	r27, Y+30	; 0x1e
    1a66:	bb 23       	and	r27, r27
    1a68:	21 f0       	breq	.+8      	; 0x1a72 <gc_execute_line+0x5b8>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    1a6a:	81 11       	cpse	r24, r1
    1a6c:	02 c0       	rjmp	.+4      	; 0x1a72 <gc_execute_line+0x5b8>
    1a6e:	e2 e0       	ldi	r30, 0x02	; 2
    1a70:	eb a3       	std	Y+35, r30	; 0x23
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1a72:	e6 fe       	sbrs	r14, 6
    1a74:	0e c0       	rjmp	.+28     	; 0x1a92 <gc_execute_line+0x5d8>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1a76:	80 91 63 06 	lds	r24, 0x0663
    1a7a:	90 91 64 06 	lds	r25, 0x0664
    1a7e:	a0 91 65 06 	lds	r26, 0x0665
    1a82:	b0 91 66 06 	lds	r27, 0x0666
    1a86:	80 38       	cpi	r24, 0x80	; 128
    1a88:	96 49       	sbci	r25, 0x96	; 150
    1a8a:	a8 49       	sbci	r26, 0x98	; 152
    1a8c:	b1 05       	cpc	r27, r1
    1a8e:	0c f0       	brlt	.+2      	; 0x1a92 <gc_execute_line+0x5d8>
    1a90:	6d c7       	rjmp	.+3802   	; 0x296c <gc_execute_line+0x14b2>
  
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
  
  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1a92:	80 91 47 06 	lds	r24, 0x0647
    1a96:	81 30       	cpi	r24, 0x01	; 1
    1a98:	31 f4       	brne	.+12     	; 0x1aa6 <gc_execute_line+0x5ec>
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
    1a9a:	2b a1       	ldd	r18, Y+35	; 0x23
    1a9c:	22 30       	cpi	r18, 0x02	; 2
    1a9e:	a1 f5       	brne	.+104    	; 0x1b08 <gc_execute_line+0x64e>
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1aa0:	e0 fe       	sbrs	r14, 0
    1aa2:	66 c7       	rjmp	.+3788   	; 0x2970 <gc_execute_line+0x14b6>
    1aa4:	31 c0       	rjmp	.+98     	; 0x1b08 <gc_execute_line+0x64e>
    // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error 
    // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
  } else { // = G94
    // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    1aa6:	80 91 be 05 	lds	r24, 0x05BE
    1aaa:	81 11       	cpse	r24, r1
    1aac:	2d c0       	rjmp	.+90     	; 0x1b08 <gc_execute_line+0x64e>
      if (bit_istrue(value_words,bit(WORD_F))) {
    1aae:	e0 fe       	sbrs	r14, 0
    1ab0:	1b c0       	rjmp	.+54     	; 0x1ae8 <gc_execute_line+0x62e>
        if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    1ab2:	80 91 48 06 	lds	r24, 0x0648
    1ab6:	81 30       	cpi	r24, 0x01	; 1
    1ab8:	39 f5       	brne	.+78     	; 0x1b08 <gc_execute_line+0x64e>
    1aba:	0f 2e       	mov	r0, r31
    1abc:	f1 e5       	ldi	r31, 0x51	; 81
    1abe:	cf 2e       	mov	r12, r31
    1ac0:	f6 e0       	ldi	r31, 0x06	; 6
    1ac2:	df 2e       	mov	r13, r31
    1ac4:	f0 2d       	mov	r31, r0
    1ac6:	23 e3       	ldi	r18, 0x33	; 51
    1ac8:	33 e3       	ldi	r19, 0x33	; 51
    1aca:	4b ec       	ldi	r20, 0xCB	; 203
    1acc:	51 e4       	ldi	r21, 0x41	; 65
    1ace:	d6 01       	movw	r26, r12
    1ad0:	6d 91       	ld	r22, X+
    1ad2:	7d 91       	ld	r23, X+
    1ad4:	8d 91       	ld	r24, X+
    1ad6:	9c 91       	ld	r25, X
    1ad8:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    1adc:	f6 01       	movw	r30, r12
    1ade:	60 83       	st	Z, r22
    1ae0:	71 83       	std	Z+1, r23	; 0x01
    1ae2:	82 83       	std	Z+2, r24	; 0x02
    1ae4:	93 83       	std	Z+3, r25	; 0x03
    1ae6:	10 c0       	rjmp	.+32     	; 0x1b08 <gc_execute_line+0x64e>
      } else {
        gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    1ae8:	80 91 cc 05 	lds	r24, 0x05CC
    1aec:	90 91 cd 05 	lds	r25, 0x05CD
    1af0:	a0 91 ce 05 	lds	r26, 0x05CE
    1af4:	b0 91 cf 05 	lds	r27, 0x05CF
    1af8:	80 93 51 06 	sts	0x0651, r24
    1afc:	90 93 52 06 	sts	0x0652, r25
    1b00:	a0 93 53 06 	sts	0x0653, r26
    1b04:	b0 93 54 06 	sts	0x0654, r27
    } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
  } 
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
  
  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    1b08:	f1 fc       	sbrc	r15, 1
    1b0a:	10 c0       	rjmp	.+32     	; 0x1b2c <gc_execute_line+0x672>
    1b0c:	80 91 c8 05 	lds	r24, 0x05C8
    1b10:	90 91 c9 05 	lds	r25, 0x05C9
    1b14:	a0 91 ca 05 	lds	r26, 0x05CA
    1b18:	b0 91 cb 05 	lds	r27, 0x05CB
    1b1c:	80 93 6f 06 	sts	0x066F, r24
    1b20:	90 93 70 06 	sts	0x0670, r25
    1b24:	a0 93 71 06 	sts	0x0671, r26
    1b28:	b0 93 72 06 	sts	0x0672, r27
  // bit_false(value_words,bit(WORD_S)); // NOTE: Single-meaning value word. Set at end of error-checking.
    
  // [5. Select tool ]:  T is negative (done.) Not an integer. Greater than max tool value.
  if (bit_istrue(value_words,bit(WORD_T))) {
    1b2c:	f2 fe       	sbrs	r15, 2
    1b2e:	06 c0       	rjmp	.+12     	; 0x1b3c <gc_execute_line+0x682>
	  if (gc_block.values.t >= N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); }
    1b30:	80 91 73 06 	lds	r24, 0x0673
    1b34:	85 30       	cpi	r24, 0x05	; 5
    1b36:	08 f0       	brcs	.+2      	; 0x1b3a <gc_execute_line+0x680>
    1b38:	1d c7       	rjmp	.+3642   	; 0x2974 <gc_execute_line+0x14ba>
    1b3a:	04 c0       	rjmp	.+8      	; 0x1b44 <gc_execute_line+0x68a>
  } else {
	  gc_block.values.t = gc_state.tool_slot;
    1b3c:	80 91 d0 05 	lds	r24, 0x05D0
    1b40:	80 93 73 06 	sts	0x0673, r24
  }
  // bit_false(value_words,bit(WORD_T)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [5a. Select tool offset]:
  if (bit_istrue(value_words,bit(WORD_H))) {
    1b44:	e1 fe       	sbrs	r14, 1
    1b46:	06 c0       	rjmp	.+12     	; 0x1b54 <gc_execute_line+0x69a>
	  if (gc_block.values.h > N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); }
    1b48:	80 91 55 06 	lds	r24, 0x0655
    1b4c:	86 30       	cpi	r24, 0x06	; 6
    1b4e:	08 f0       	brcs	.+2      	; 0x1b52 <gc_execute_line+0x698>
    1b50:	13 c7       	rjmp	.+3622   	; 0x2978 <gc_execute_line+0x14be>
    1b52:	04 c0       	rjmp	.+8      	; 0x1b5c <gc_execute_line+0x6a2>
  } else {
	  gc_block.values.h = gc_state.modal.tool_comp;
    1b54:	80 91 c7 05 	lds	r24, 0x05C7
    1b58:	80 93 55 06 	sts	0x0655, r24
  // [7. Spindle control ]: N/A
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    1b5c:	80 91 45 06 	lds	r24, 0x0645
    1b60:	81 30       	cpi	r24, 0x01	; 1
    1b62:	29 f4       	brne	.+10     	; 0x1b6e <gc_execute_line+0x6b4>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    1b64:	e7 fe       	sbrs	r14, 7
    1b66:	0a c7       	rjmp	.+3604   	; 0x297c <gc_execute_line+0x14c2>
    bit_false(value_words,bit(WORD_P));
    1b68:	17 01       	movw	r2, r14
    1b6a:	e8 94       	clt
    1b6c:	27 f8       	bld	r2, 7
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    1b6e:	80 91 4a 06 	lds	r24, 0x064A
    1b72:	88 23       	and	r24, r24
    1b74:	19 f0       	breq	.+6      	; 0x1b7c <gc_execute_line+0x6c2>
    1b76:	81 30       	cpi	r24, 0x01	; 1
    1b78:	69 f0       	breq	.+26     	; 0x1b94 <gc_execute_line+0x6da>
    1b7a:	06 c0       	rjmp	.+12     	; 0x1b88 <gc_execute_line+0x6ce>
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    1b7c:	f2 e0       	ldi	r31, 0x02	; 2
    1b7e:	fa a7       	std	Y+42, r31	; 0x2a
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1b80:	21 e0       	ldi	r18, 0x01	; 1
    1b82:	2f a3       	std	Y+39, r18	; 0x27
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    1b84:	1e a2       	std	Y+38, r1	; 0x26
    1b86:	0b c0       	rjmp	.+22     	; 0x1b9e <gc_execute_line+0x6e4>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    1b88:	1a a6       	std	Y+42, r1	; 0x2a
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    1b8a:	32 e0       	ldi	r19, 0x02	; 2
    1b8c:	3f a3       	std	Y+39, r19	; 0x27
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    1b8e:	81 e0       	ldi	r24, 0x01	; 1
    1b90:	8e a3       	std	Y+38, r24	; 0x26
    1b92:	05 c0       	rjmp	.+10     	; 0x1b9e <gc_execute_line+0x6e4>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    1b94:	91 e0       	ldi	r25, 0x01	; 1
    1b96:	9a a7       	std	Y+42, r25	; 0x2a
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    1b98:	1f a2       	std	Y+39, r1	; 0x27
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    1b9a:	a2 e0       	ldi	r26, 0x02	; 2
    1b9c:	ae a3       	std	Y+38, r26	; 0x26
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1b9e:	80 91 48 06 	lds	r24, 0x0648
    1ba2:	81 30       	cpi	r24, 0x01	; 1
    1ba4:	79 f5       	brne	.+94     	; 0x1c04 <gc_execute_line+0x74a>
    1ba6:	0f 2e       	mov	r0, r31
    1ba8:	f4 e7       	ldi	r31, 0x74	; 116
    1baa:	cf 2e       	mov	r12, r31
    1bac:	f6 e0       	ldi	r31, 0x06	; 6
    1bae:	df 2e       	mov	r13, r31
    1bb0:	f0 2d       	mov	r31, r0
    1bb2:	e1 2c       	mov	r14, r1
    1bb4:	f1 2c       	mov	r15, r1
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    1bb6:	be 8d       	ldd	r27, Y+30	; 0x1e
    1bb8:	ab 2e       	mov	r10, r27
    1bba:	b1 2c       	mov	r11, r1
    1bbc:	c5 01       	movw	r24, r10
    1bbe:	0e 2c       	mov	r0, r14
    1bc0:	02 c0       	rjmp	.+4      	; 0x1bc6 <gc_execute_line+0x70c>
    1bc2:	95 95       	asr	r25
    1bc4:	87 95       	ror	r24
    1bc6:	0a 94       	dec	r0
    1bc8:	e2 f7       	brpl	.-8      	; 0x1bc2 <gc_execute_line+0x708>
    1bca:	80 ff       	sbrs	r24, 0
    1bcc:	11 c0       	rjmp	.+34     	; 0x1bf0 <gc_execute_line+0x736>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    1bce:	23 e3       	ldi	r18, 0x33	; 51
    1bd0:	33 e3       	ldi	r19, 0x33	; 51
    1bd2:	4b ec       	ldi	r20, 0xCB	; 203
    1bd4:	51 e4       	ldi	r21, 0x41	; 65
    1bd6:	f6 01       	movw	r30, r12
    1bd8:	60 81       	ld	r22, Z
    1bda:	71 81       	ldd	r23, Z+1	; 0x01
    1bdc:	82 81       	ldd	r24, Z+2	; 0x02
    1bde:	93 81       	ldd	r25, Z+3	; 0x03
    1be0:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    1be4:	d6 01       	movw	r26, r12
    1be6:	6d 93       	st	X+, r22
    1be8:	7d 93       	st	X+, r23
    1bea:	8d 93       	st	X+, r24
    1bec:	9c 93       	st	X, r25
    1bee:	13 97       	sbiw	r26, 0x03	; 3
    1bf0:	bf ef       	ldi	r27, 0xFF	; 255
    1bf2:	eb 1a       	sub	r14, r27
    1bf4:	fb 0a       	sbc	r15, r27
    1bf6:	e4 e0       	ldi	r30, 0x04	; 4
    1bf8:	ce 0e       	add	r12, r30
    1bfa:	d1 1c       	adc	r13, r1
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1bfc:	f3 e0       	ldi	r31, 0x03	; 3
    1bfe:	ef 16       	cp	r14, r31
    1c00:	f1 04       	cpc	r15, r1
    1c02:	e1 f6       	brne	.-72     	; 0x1bbc <gc_execute_line+0x702>
  // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
    1c04:	8c e0       	ldi	r24, 0x0C	; 12
    1c06:	ed e2       	ldi	r30, 0x2D	; 45
    1c08:	f6 e0       	ldi	r31, 0x06	; 6
    1c0a:	de 01       	movw	r26, r28
    1c0c:	11 96       	adiw	r26, 0x01	; 1
    1c0e:	01 90       	ld	r0, Z+
    1c10:	0d 92       	st	X+, r0
    1c12:	8a 95       	dec	r24
    1c14:	e1 f7       	brne	.-8      	; 0x1c0e <gc_execute_line+0x754>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    1c16:	07 ff       	sbrs	r16, 7
    1c18:	11 c0       	rjmp	.+34     	; 0x1c3c <gc_execute_line+0x782>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1c1a:	80 91 4b 06 	lds	r24, 0x064B
    1c1e:	87 30       	cpi	r24, 0x07	; 7
    1c20:	08 f0       	brcs	.+2      	; 0x1c24 <gc_execute_line+0x76a>
    1c22:	ae c6       	rjmp	.+3420   	; 0x2980 <gc_execute_line+0x14c6>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    1c24:	90 91 c2 05 	lds	r25, 0x05C2
    1c28:	89 17       	cp	r24, r25
    1c2a:	41 f0       	breq	.+16     	; 0x1c3c <gc_execute_line+0x782>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    1c2c:	be 01       	movw	r22, r28
    1c2e:	6f 5f       	subi	r22, 0xFF	; 255
    1c30:	7f 4f       	sbci	r23, 0xFF	; 255
    1c32:	0e 94 6d 23 	call	0x46da	; 0x46da <settings_read_coord_data>
    1c36:	88 23       	and	r24, r24
    1c38:	09 f4       	brne	.+2      	; 0x1c3c <gc_execute_line+0x782>
    1c3a:	a4 c6       	rjmp	.+3400   	; 0x2984 <gc_execute_line+0x14ca>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets. 
  switch (gc_block.non_modal_command) {
    1c3c:	50 90 45 06 	lds	r5, 0x0645
    1c40:	22 e0       	ldi	r18, 0x02	; 2
    1c42:	52 16       	cp	r5, r18
    1c44:	29 f0       	breq	.+10     	; 0x1c50 <gc_execute_line+0x796>
    1c46:	38 e0       	ldi	r19, 0x08	; 8
    1c48:	53 16       	cp	r5, r19
    1c4a:	09 f4       	brne	.+2      	; 0x1c4e <gc_execute_line+0x794>
    1c4c:	e8 c0       	rjmp	.+464    	; 0x1e1e <gc_execute_line+0x964>
    1c4e:	4d c1       	rjmp	.+666    	; 0x1eea <gc_execute_line+0xa30>
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words && bit_isfalse(value_words,(1<<WORD_R)) ) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    1c50:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c52:	81 11       	cpse	r24, r1
    1c54:	02 c0       	rjmp	.+4      	; 0x1c5a <gc_execute_line+0x7a0>
    1c56:	30 fe       	sbrs	r3, 0
    1c58:	97 c6       	rjmp	.+3374   	; 0x2988 <gc_execute_line+0x14ce>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    1c5a:	c1 01       	movw	r24, r2
    1c5c:	80 7a       	andi	r24, 0xA0	; 160
    1c5e:	99 27       	eor	r25, r25
    1c60:	89 2b       	or	r24, r25
    1c62:	09 f4       	brne	.+2      	; 0x1c66 <gc_execute_line+0x7ac>
    1c64:	93 c6       	rjmp	.+3366   	; 0x298c <gc_execute_line+0x14d2>
      int_value = trunc(gc_block.values.p); // Convert p value to int.
    1c66:	60 91 67 06 	lds	r22, 0x0667
    1c6a:	70 91 68 06 	lds	r23, 0x0668
    1c6e:	80 91 69 06 	lds	r24, 0x0669
    1c72:	90 91 6a 06 	lds	r25, 0x066A
    1c76:	0e 94 68 3c 	call	0x78d0	; 0x78d0 <trunc>
    1c7a:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>

      switch( gc_block.values.l) {
    1c7e:	80 91 62 06 	lds	r24, 0x0662
    1c82:	82 30       	cpi	r24, 0x02	; 2
    1c84:	09 f4       	brne	.+2      	; 0x1c88 <gc_execute_line+0x7ce>
    1c86:	57 c0       	rjmp	.+174    	; 0x1d36 <gc_execute_line+0x87c>
    1c88:	84 31       	cpi	r24, 0x14	; 20
    1c8a:	09 f4       	brne	.+2      	; 0x1c8e <gc_execute_line+0x7d4>
    1c8c:	56 c0       	rjmp	.+172    	; 0x1d3a <gc_execute_line+0x880>
    1c8e:	81 30       	cpi	r24, 0x01	; 1
    1c90:	09 f0       	breq	.+2      	; 0x1c94 <gc_execute_line+0x7da>
    1c92:	7e c6       	rjmp	.+3324   	; 0x2990 <gc_execute_line+0x14d6>
      	  case 1:
      	      if (int_value > N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); } // [Greater than N sys]
    1c94:	66 30       	cpi	r22, 0x06	; 6
    1c96:	08 f0       	brcs	.+2      	; 0x1c9a <gc_execute_line+0x7e0>
    1c98:	7d c6       	rjmp	.+3322   	; 0x2994 <gc_execute_line+0x14da>
//      	      if (bit_istrue(value_words,bit(WORD_X)|bit(WORD_Y))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
      	      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    1c9a:	91 01       	movw	r18, r2
    1c9c:	2f 75       	andi	r18, 0x5F	; 95

      	      // tool index
      	      if (int_value < 0) { int_value = gc_state.modal.tool; } // keep current tool

      	      if ( int_value > 0) {
    1c9e:	66 23       	and	r22, r22
    1ca0:	09 f4       	brne	.+2      	; 0x1ca4 <gc_execute_line+0x7ea>
    1ca2:	c5 c1       	rjmp	.+906    	; 0x202e <gc_execute_line+0xb74>
				  // set tool radius
				  if (bit_isfalse(value_words,bit(WORD_R))) {
    1ca4:	30 fc       	sbrc	r3, 0
    1ca6:	14 c0       	rjmp	.+40     	; 0x1cd0 <gc_execute_line+0x816>
					  gc_block.values.r = gc_state.tool_table[ int_value].r;
    1ca8:	90 e1       	ldi	r25, 0x10	; 16
    1caa:	69 9f       	mul	r22, r25
    1cac:	f0 01       	movw	r30, r0
    1cae:	11 24       	eor	r1, r1
    1cb0:	e3 54       	subi	r30, 0x43	; 67
    1cb2:	fa 4f       	sbci	r31, 0xFA	; 250
    1cb4:	84 89       	ldd	r24, Z+20	; 0x14
    1cb6:	95 89       	ldd	r25, Z+21	; 0x15
    1cb8:	a6 89       	ldd	r26, Z+22	; 0x16
    1cba:	b7 89       	ldd	r27, Z+23	; 0x17
    1cbc:	80 93 6b 06 	sts	0x066B, r24
    1cc0:	90 93 6c 06 	sts	0x066C, r25
    1cc4:	a0 93 6d 06 	sts	0x066D, r26
    1cc8:	b0 93 6e 06 	sts	0x066E, r27

      switch( gc_block.values.l) {
      	  case 1:
      	      if (int_value > N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); } // [Greater than N sys]
//      	      if (bit_istrue(value_words,bit(WORD_X)|bit(WORD_Y))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
      	      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    1ccc:	19 01       	movw	r2, r18
    1cce:	04 c0       	rjmp	.+8      	; 0x1cd8 <gc_execute_line+0x81e>
      	      if ( int_value > 0) {
				  // set tool radius
				  if (bit_isfalse(value_words,bit(WORD_R))) {
					  gc_block.values.r = gc_state.tool_table[ int_value].r;
				  } else {
					  bit_false(value_words,(bit(WORD_R)));
    1cd0:	af e5       	ldi	r26, 0x5F	; 95
    1cd2:	2a 22       	and	r2, r26
    1cd4:	e8 94       	clt
    1cd6:	30 f8       	bld	r3, 0
    1cd8:	b0 e1       	ldi	r27, 0x10	; 16
    1cda:	6b 9f       	mul	r22, r27
    1cdc:	b0 01       	movw	r22, r0
    1cde:	11 24       	eor	r1, r1
    1ce0:	63 54       	subi	r22, 0x43	; 67
    1ce2:	7a 4f       	sbci	r23, 0xFA	; 250

      switch( gc_block.values.l) {
      	  case 1:
      	      if (int_value > N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); } // [Greater than N sys]
//      	      if (bit_istrue(value_words,bit(WORD_X)|bit(WORD_Y))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
      	      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    1ce4:	20 e0       	ldi	r18, 0x00	; 0
    1ce6:	30 e0       	ldi	r19, 0x00	; 0
    1ce8:	80 e0       	ldi	r24, 0x00	; 0
    1cea:	90 e0       	ldi	r25, 0x00	; 0
					  bit_false(value_words,(bit(WORD_R)));
				  }
				  // set tool xyz-offsets
				  for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
					// Update axes defined only in block. Always in machine coordinates. Can change non-active system.
					if ( bit_isfalse(axis_words,bit(idx)) ) {
    1cec:	ee 8d       	ldd	r30, Y+30	; 0x1e
    1cee:	4e 2f       	mov	r20, r30
    1cf0:	50 e0       	ldi	r21, 0x00	; 0
    1cf2:	f9 01       	movw	r30, r18
    1cf4:	9a 01       	movw	r18, r20
    1cf6:	08 2e       	mov	r0, r24
    1cf8:	02 c0       	rjmp	.+4      	; 0x1cfe <gc_execute_line+0x844>
    1cfa:	35 95       	asr	r19
    1cfc:	27 95       	ror	r18
    1cfe:	0a 94       	dec	r0
    1d00:	e2 f7       	brpl	.-8      	; 0x1cfa <gc_execute_line+0x840>
    1d02:	20 fd       	sbrc	r18, 0
    1d04:	12 c0       	rjmp	.+36     	; 0x1d2a <gc_execute_line+0x870>
    1d06:	db 01       	movw	r26, r22
    1d08:	ae 0f       	add	r26, r30
    1d0a:	bf 1f       	adc	r27, r31
						gc_block.values.xyz[ idx] = gc_state.tool_table[ int_value].xyz[idx];
    1d0c:	58 96       	adiw	r26, 0x18	; 24
    1d0e:	0d 91       	ld	r16, X+
    1d10:	1d 91       	ld	r17, X+
    1d12:	2d 91       	ld	r18, X+
    1d14:	3c 91       	ld	r19, X
    1d16:	5b 97       	sbiw	r26, 0x1b	; 27
    1d18:	df 01       	movw	r26, r30
    1d1a:	ab 5b       	subi	r26, 0xBB	; 187
    1d1c:	b9 4f       	sbci	r27, 0xF9	; 249
    1d1e:	9f 96       	adiw	r26, 0x2f	; 47
    1d20:	0d 93       	st	X+, r16
    1d22:	1d 93       	st	X+, r17
    1d24:	2d 93       	st	X+, r18
    1d26:	3c 93       	st	X, r19
    1d28:	d2 97       	sbiw	r26, 0x32	; 50
    1d2a:	01 96       	adiw	r24, 0x01	; 1
    1d2c:	34 96       	adiw	r30, 0x04	; 4
					  gc_block.values.r = gc_state.tool_table[ int_value].r;
				  } else {
					  bit_false(value_words,(bit(WORD_R)));
				  }
				  // set tool xyz-offsets
				  for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1d2e:	83 30       	cpi	r24, 0x03	; 3
    1d30:	91 05       	cpc	r25, r1
    1d32:	01 f7       	brne	.-64     	; 0x1cf4 <gc_execute_line+0x83a>
    1d34:	7d c1       	rjmp	.+762    	; 0x2030 <gc_execute_line+0xb76>
				  }
      	      }
    	  break;

      	  case 2:
  	          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    1d36:	30 fc       	sbrc	r3, 0
    1d38:	2f c6       	rjmp	.+3166   	; 0x2998 <gc_execute_line+0x14de>
      	  case 20:
      	      if (int_value > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1d3a:	67 30       	cpi	r22, 0x07	; 7
    1d3c:	08 f0       	brcs	.+2      	; 0x1d40 <gc_execute_line+0x886>
    1d3e:	2e c6       	rjmp	.+3164   	; 0x299c <gc_execute_line+0x14e2>

      	      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    1d40:	ff e5       	ldi	r31, 0x5F	; 95
    1d42:	2f 22       	and	r2, r31

      	      // Load EEPROM coordinate data and pre-calculate the new coordinate data.
      	      if (int_value > 0) { int_value--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1d44:	66 23       	and	r22, r22
    1d46:	19 f0       	breq	.+6      	; 0x1d4e <gc_execute_line+0x894>
    1d48:	8f ef       	ldi	r24, 0xFF	; 255
    1d4a:	86 0f       	add	r24, r22
    1d4c:	02 c0       	rjmp	.+4      	; 0x1d52 <gc_execute_line+0x898>
      		  else { int_value = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    1d4e:	80 91 4b 06 	lds	r24, 0x064B
      	      if (!settings_read_coord_data(int_value,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1d52:	be 01       	movw	r22, r28
    1d54:	63 5f       	subi	r22, 0xF3	; 243
    1d56:	7f 4f       	sbci	r23, 0xFF	; 255
    1d58:	0e 94 6d 23 	call	0x46da	; 0x46da <settings_read_coord_data>
    1d5c:	88 23       	and	r24, r24
    1d5e:	09 f4       	brne	.+2      	; 0x1d62 <gc_execute_line+0x8a8>
    1d60:	1f c6       	rjmp	.+3134   	; 0x29a0 <gc_execute_line+0x14e6>
      	      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      	        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
      	        if (bit_istrue(axis_words,bit(idx)) ) {
      	          if (gc_block.values.l == 20) {
    1d62:	50 90 62 06 	lds	r5, 0x0662
    1d66:	01 e2       	ldi	r16, 0x21	; 33
    1d68:	16 e0       	ldi	r17, 0x06	; 6
    1d6a:	0f 2e       	mov	r0, r31
    1d6c:	f4 e7       	ldi	r31, 0x74	; 116
    1d6e:	af 2e       	mov	r10, r31
    1d70:	f6 e0       	ldi	r31, 0x06	; 6
    1d72:	bf 2e       	mov	r11, r31
    1d74:	f0 2d       	mov	r31, r0
    1d76:	6e 01       	movw	r12, r28
    1d78:	2d e0       	ldi	r18, 0x0D	; 13
    1d7a:	c2 0e       	add	r12, r18
    1d7c:	d1 1c       	adc	r13, r1
    1d7e:	80 90 c6 05 	lds	r8, 0x05C6
    1d82:	30 e1       	ldi	r19, 0x10	; 16
    1d84:	83 9e       	mul	r8, r19
    1d86:	40 01       	movw	r8, r0
    1d88:	11 24       	eor	r1, r1
      	            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
      	            parameter_data[idx] = gc_state.position[idx]-gc_block.values.xyz[idx]; // L20: Update axis current position to target
      	            parameter_data[idx] -= gc_state.tool_table[ gc_state.modal.tool].xyz[idx];
    1d8a:	e1 2c       	mov	r14, r1
    1d8c:	f1 2c       	mov	r15, r1
      	      if (int_value > 0) { int_value--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      		  else { int_value = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      	      if (!settings_read_coord_data(int_value,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
      	      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      	        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
      	        if (bit_istrue(axis_words,bit(idx)) ) {
    1d8e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1d90:	68 2e       	mov	r6, r24
    1d92:	71 2c       	mov	r7, r1
    1d94:	c3 01       	movw	r24, r6
    1d96:	0e 2c       	mov	r0, r14
    1d98:	02 c0       	rjmp	.+4      	; 0x1d9e <gc_execute_line+0x8e4>
    1d9a:	95 95       	asr	r25
    1d9c:	87 95       	ror	r24
    1d9e:	0a 94       	dec	r0
    1da0:	e2 f7       	brpl	.-8      	; 0x1d9a <gc_execute_line+0x8e0>
    1da2:	80 ff       	sbrs	r24, 0
    1da4:	2b c0       	rjmp	.+86     	; 0x1dfc <gc_execute_line+0x942>
      	          if (gc_block.values.l == 20) {
    1da6:	94 e1       	ldi	r25, 0x14	; 20
    1da8:	59 12       	cpse	r5, r25
    1daa:	1e c0       	rjmp	.+60     	; 0x1de8 <gc_execute_line+0x92e>
      	            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
      	            parameter_data[idx] = gc_state.position[idx]-gc_block.values.xyz[idx]; // L20: Update axis current position to target
    1dac:	d5 01       	movw	r26, r10
    1dae:	2d 91       	ld	r18, X+
    1db0:	3d 91       	ld	r19, X+
    1db2:	4d 91       	ld	r20, X+
    1db4:	5c 91       	ld	r21, X
    1db6:	f8 01       	movw	r30, r16
    1db8:	60 81       	ld	r22, Z
    1dba:	71 81       	ldd	r23, Z+1	; 0x01
    1dbc:	82 81       	ldd	r24, Z+2	; 0x02
    1dbe:	93 81       	ldd	r25, Z+3	; 0x03
    1dc0:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    1dc4:	f8 01       	movw	r30, r16
    1dc6:	e8 0d       	add	r30, r8
    1dc8:	f9 1d       	adc	r31, r9
    1dca:	ec 54       	subi	r30, 0x4C	; 76
    1dcc:	f1 09       	sbc	r31, r1
      	            parameter_data[idx] -= gc_state.tool_table[ gc_state.modal.tool].xyz[idx];
    1dce:	20 81       	ld	r18, Z
    1dd0:	31 81       	ldd	r19, Z+1	; 0x01
    1dd2:	42 81       	ldd	r20, Z+2	; 0x02
    1dd4:	53 81       	ldd	r21, Z+3	; 0x03
    1dd6:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    1dda:	d6 01       	movw	r26, r12
    1ddc:	6d 93       	st	X+, r22
    1dde:	7d 93       	st	X+, r23
    1de0:	8d 93       	st	X+, r24
    1de2:	9c 93       	st	X, r25
    1de4:	13 97       	sbiw	r26, 0x03	; 3
    1de6:	0a c0       	rjmp	.+20     	; 0x1dfc <gc_execute_line+0x942>
      	          } else {
					// L2: Update coordinate system axis to programmed value.
					parameter_data[idx] = gc_block.values.xyz[idx];
    1de8:	f5 01       	movw	r30, r10
    1dea:	80 81       	ld	r24, Z
    1dec:	91 81       	ldd	r25, Z+1	; 0x01
    1dee:	a2 81       	ldd	r26, Z+2	; 0x02
    1df0:	b3 81       	ldd	r27, Z+3	; 0x03
    1df2:	f6 01       	movw	r30, r12
    1df4:	80 83       	st	Z, r24
    1df6:	91 83       	std	Z+1, r25	; 0x01
    1df8:	a2 83       	std	Z+2, r26	; 0x02
    1dfa:	b3 83       	std	Z+3, r27	; 0x03
    1dfc:	ff ef       	ldi	r31, 0xFF	; 255
    1dfe:	ef 1a       	sub	r14, r31
    1e00:	ff 0a       	sbc	r15, r31
    1e02:	0c 5f       	subi	r16, 0xFC	; 252
    1e04:	1f 4f       	sbci	r17, 0xFF	; 255
    1e06:	24 e0       	ldi	r18, 0x04	; 4
    1e08:	a2 0e       	add	r10, r18
    1e0a:	b1 1c       	adc	r11, r1
    1e0c:	34 e0       	ldi	r19, 0x04	; 4
    1e0e:	c3 0e       	add	r12, r19
    1e10:	d1 1c       	adc	r13, r1

      	      // Load EEPROM coordinate data and pre-calculate the new coordinate data.
      	      if (int_value > 0) { int_value--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      		  else { int_value = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      	      if (!settings_read_coord_data(int_value,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
      	      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1e12:	83 e0       	ldi	r24, 0x03	; 3
    1e14:	e8 16       	cp	r14, r24
    1e16:	f1 04       	cpc	r15, r1
    1e18:	09 f0       	breq	.+2      	; 0x1e1c <gc_execute_line+0x962>
    1e1a:	bc cf       	rjmp	.-136    	; 0x1d94 <gc_execute_line+0x8da>
    1e1c:	09 c1       	rjmp	.+530    	; 0x2030 <gc_execute_line+0xb76>
      		FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1e1e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1e20:	99 23       	and	r25, r25
    1e22:	09 f4       	brne	.+2      	; 0x1e26 <gc_execute_line+0x96c>
    1e24:	bf c5       	rjmp	.+2942   	; 0x29a4 <gc_execute_line+0x14ea>
    1e26:	0f 2e       	mov	r0, r31
    1e28:	f1 e2       	ldi	r31, 0x21	; 33
    1e2a:	cf 2e       	mov	r12, r31
    1e2c:	f6 e0       	ldi	r31, 0x06	; 6
    1e2e:	df 2e       	mov	r13, r31
    1e30:	f0 2d       	mov	r31, r0
    1e32:	de 01       	movw	r26, r28
    1e34:	11 96       	adiw	r26, 0x01	; 1
    1e36:	4d 01       	movw	r8, r26
    1e38:	04 e7       	ldi	r16, 0x74	; 116
    1e3a:	16 e0       	ldi	r17, 0x06	; 6
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
          gc_block.values.xyz[idx] -= gc_state.tool_table[ gc_state.modal.tool].xyz[idx];
    1e3c:	80 91 c6 05 	lds	r24, 0x05C6
    1e40:	b0 e1       	ldi	r27, 0x10	; 16
    1e42:	8b 9f       	mul	r24, r27
    1e44:	c0 01       	movw	r24, r0
    1e46:	11 24       	eor	r1, r1
    1e48:	fc 01       	movw	r30, r24
    1e4a:	eb 52       	subi	r30, 0x2B	; 43
    1e4c:	fa 4f       	sbci	r31, 0xFA	; 250
    1e4e:	5f 01       	movw	r10, r30
    1e50:	e1 2c       	mov	r14, r1
    1e52:	f1 2c       	mov	r15, r1
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1e54:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1e56:	6f 2e       	mov	r6, r31
    1e58:	71 2c       	mov	r7, r1
    1e5a:	c3 01       	movw	r24, r6
    1e5c:	0e 2c       	mov	r0, r14
    1e5e:	02 c0       	rjmp	.+4      	; 0x1e64 <gc_execute_line+0x9aa>
    1e60:	95 95       	asr	r25
    1e62:	87 95       	ror	r24
    1e64:	0a 94       	dec	r0
    1e66:	e2 f7       	brpl	.-8      	; 0x1e60 <gc_execute_line+0x9a6>
    1e68:	80 ff       	sbrs	r24, 0
    1e6a:	21 c0       	rjmp	.+66     	; 0x1eae <gc_execute_line+0x9f4>
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
    1e6c:	d4 01       	movw	r26, r8
    1e6e:	2d 91       	ld	r18, X+
    1e70:	3d 91       	ld	r19, X+
    1e72:	4d 91       	ld	r20, X+
    1e74:	5c 91       	ld	r21, X
    1e76:	f6 01       	movw	r30, r12
    1e78:	60 81       	ld	r22, Z
    1e7a:	71 81       	ldd	r23, Z+1	; 0x01
    1e7c:	82 81       	ldd	r24, Z+2	; 0x02
    1e7e:	93 81       	ldd	r25, Z+3	; 0x03
    1e80:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    1e84:	d8 01       	movw	r26, r16
    1e86:	2d 91       	ld	r18, X+
    1e88:	3d 91       	ld	r19, X+
    1e8a:	4d 91       	ld	r20, X+
    1e8c:	5c 91       	ld	r21, X
    1e8e:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
          gc_block.values.xyz[idx] -= gc_state.tool_table[ gc_state.modal.tool].xyz[idx];
    1e92:	f5 01       	movw	r30, r10
    1e94:	20 81       	ld	r18, Z
    1e96:	31 81       	ldd	r19, Z+1	; 0x01
    1e98:	42 81       	ldd	r20, Z+2	; 0x02
    1e9a:	53 81       	ldd	r21, Z+3	; 0x03
    1e9c:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    1ea0:	d8 01       	movw	r26, r16
    1ea2:	6d 93       	st	X+, r22
    1ea4:	7d 93       	st	X+, r23
    1ea6:	8d 93       	st	X+, r24
    1ea8:	9c 93       	st	X, r25
    1eaa:	13 97       	sbiw	r26, 0x03	; 3
    1eac:	0a c0       	rjmp	.+20     	; 0x1ec2 <gc_execute_line+0xa08>
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    1eae:	f6 01       	movw	r30, r12
    1eb0:	80 8d       	ldd	r24, Z+24	; 0x18
    1eb2:	91 8d       	ldd	r25, Z+25	; 0x19
    1eb4:	a2 8d       	ldd	r26, Z+26	; 0x1a
    1eb6:	b3 8d       	ldd	r27, Z+27	; 0x1b
    1eb8:	f8 01       	movw	r30, r16
    1eba:	80 83       	st	Z, r24
    1ebc:	91 83       	std	Z+1, r25	; 0x01
    1ebe:	a2 83       	std	Z+2, r26	; 0x02
    1ec0:	b3 83       	std	Z+3, r27	; 0x03
    1ec2:	ff ef       	ldi	r31, 0xFF	; 255
    1ec4:	ef 1a       	sub	r14, r31
    1ec6:	ff 0a       	sbc	r15, r31
    1ec8:	24 e0       	ldi	r18, 0x04	; 4
    1eca:	c2 0e       	add	r12, r18
    1ecc:	d1 1c       	adc	r13, r1
    1ece:	34 e0       	ldi	r19, 0x04	; 4
    1ed0:	83 0e       	add	r8, r19
    1ed2:	91 1c       	adc	r9, r1
    1ed4:	0c 5f       	subi	r16, 0xFC	; 252
    1ed6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ed8:	84 e0       	ldi	r24, 0x04	; 4
    1eda:	a8 0e       	add	r10, r24
    1edc:	b1 1c       	adc	r11, r1
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1ede:	93 e0       	ldi	r25, 0x03	; 3
    1ee0:	e9 16       	cp	r14, r25
    1ee2:	f1 04       	cpc	r15, r1
    1ee4:	09 f0       	breq	.+2      	; 0x1ee8 <gc_execute_line+0xa2e>
    1ee6:	b9 cf       	rjmp	.-142    	; 0x1e5a <gc_execute_line+0x9a0>
    1ee8:	7d c5       	rjmp	.+2810   	; 0x29e4 <gc_execute_line+0x152a>
    
      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_words) {
    1eea:	ae 8d       	ldd	r26, Y+30	; 0x1e
    1eec:	aa 23       	and	r26, r26
    1eee:	09 f4       	brne	.+2      	; 0x1ef2 <gc_execute_line+0xa38>
    1ef0:	7b c0       	rjmp	.+246    	; 0x1fe8 <gc_execute_line+0xb2e>
          } else {
            // Update specified value according to distance mode or ignore if absolute override is active.
            // NOTE: G53 is never active with G28/30 since they are in the same modal group.
            if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
              // Apply coordinate offsets based on distance mode.
              if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1ef2:	40 90 49 06 	lds	r4, 0x0649
    1ef6:	0f 2e       	mov	r0, r31
    1ef8:	f1 e2       	ldi	r31, 0x21	; 33
    1efa:	ef 2e       	mov	r14, r31
    1efc:	f6 e0       	ldi	r31, 0x06	; 6
    1efe:	ff 2e       	mov	r15, r31
    1f00:	f0 2d       	mov	r31, r0
    1f02:	04 e7       	ldi	r16, 0x74	; 116
    1f04:	16 e0       	ldi	r17, 0x06	; 6
    1f06:	fe 01       	movw	r30, r28
    1f08:	31 96       	adiw	r30, 0x01	; 1
    1f0a:	4f 01       	movw	r8, r30
                gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
                gc_block.values.xyz[idx] += gc_state.tool_table[ gc_state.modal.tool_comp].xyz[idx];
    1f0c:	80 91 c7 05 	lds	r24, 0x05C7
    1f10:	f0 e1       	ldi	r31, 0x10	; 16
    1f12:	8f 9f       	mul	r24, r31
    1f14:	c0 01       	movw	r24, r0
    1f16:	11 24       	eor	r1, r1
    1f18:	9c 01       	movw	r18, r24
    1f1a:	2b 52       	subi	r18, 0x2B	; 43
    1f1c:	3a 4f       	sbci	r19, 0xFA	; 250
    1f1e:	59 01       	movw	r10, r18
    1f20:	c1 2c       	mov	r12, r1
    1f22:	d1 2c       	mov	r13, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_words) {
        for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
          if ( bit_isfalse(axis_words,bit(idx)) ) {
    1f24:	6a 2e       	mov	r6, r26
    1f26:	71 2c       	mov	r7, r1
    1f28:	c3 01       	movw	r24, r6
    1f2a:	0c 2c       	mov	r0, r12
    1f2c:	02 c0       	rjmp	.+4      	; 0x1f32 <gc_execute_line+0xa78>
    1f2e:	95 95       	asr	r25
    1f30:	87 95       	ror	r24
    1f32:	0a 94       	dec	r0
    1f34:	e2 f7       	brpl	.-8      	; 0x1f2e <gc_execute_line+0xa74>
    1f36:	80 fd       	sbrc	r24, 0
    1f38:	0b c0       	rjmp	.+22     	; 0x1f50 <gc_execute_line+0xa96>
            gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    1f3a:	f7 01       	movw	r30, r14
    1f3c:	80 81       	ld	r24, Z
    1f3e:	91 81       	ldd	r25, Z+1	; 0x01
    1f40:	a2 81       	ldd	r26, Z+2	; 0x02
    1f42:	b3 81       	ldd	r27, Z+3	; 0x03
    1f44:	f8 01       	movw	r30, r16
    1f46:	80 83       	st	Z, r24
    1f48:	91 83       	std	Z+1, r25	; 0x01
    1f4a:	a2 83       	std	Z+2, r26	; 0x02
    1f4c:	b3 83       	std	Z+3, r27	; 0x03
    1f4e:	39 c0       	rjmp	.+114    	; 0x1fc2 <gc_execute_line+0xb08>
          } else {
            // Update specified value according to distance mode or ignore if absolute override is active.
            // NOTE: G53 is never active with G28/30 since they are in the same modal group.
            if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    1f50:	f7 e0       	ldi	r31, 0x07	; 7
    1f52:	5f 16       	cp	r5, r31
    1f54:	b1 f1       	breq	.+108    	; 0x1fc2 <gc_execute_line+0xb08>
              // Apply coordinate offsets based on distance mode.
              if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1f56:	41 10       	cpse	r4, r1
    1f58:	23 c0       	rjmp	.+70     	; 0x1fa0 <gc_execute_line+0xae6>
                gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
    1f5a:	d7 01       	movw	r26, r14
    1f5c:	58 96       	adiw	r26, 0x18	; 24
    1f5e:	2d 91       	ld	r18, X+
    1f60:	3d 91       	ld	r19, X+
    1f62:	4d 91       	ld	r20, X+
    1f64:	5c 91       	ld	r21, X
    1f66:	5b 97       	sbiw	r26, 0x1b	; 27
    1f68:	f4 01       	movw	r30, r8
    1f6a:	60 81       	ld	r22, Z
    1f6c:	71 81       	ldd	r23, Z+1	; 0x01
    1f6e:	82 81       	ldd	r24, Z+2	; 0x02
    1f70:	93 81       	ldd	r25, Z+3	; 0x03
    1f72:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    1f76:	d8 01       	movw	r26, r16
    1f78:	2d 91       	ld	r18, X+
    1f7a:	3d 91       	ld	r19, X+
    1f7c:	4d 91       	ld	r20, X+
    1f7e:	5c 91       	ld	r21, X
    1f80:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
                gc_block.values.xyz[idx] += gc_state.tool_table[ gc_state.modal.tool_comp].xyz[idx];
    1f84:	f5 01       	movw	r30, r10
    1f86:	20 81       	ld	r18, Z
    1f88:	31 81       	ldd	r19, Z+1	; 0x01
    1f8a:	42 81       	ldd	r20, Z+2	; 0x02
    1f8c:	53 81       	ldd	r21, Z+3	; 0x03
    1f8e:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    1f92:	d8 01       	movw	r26, r16
    1f94:	6d 93       	st	X+, r22
    1f96:	7d 93       	st	X+, r23
    1f98:	8d 93       	st	X+, r24
    1f9a:	9c 93       	st	X, r25
    1f9c:	13 97       	sbiw	r26, 0x03	; 3
    1f9e:	11 c0       	rjmp	.+34     	; 0x1fc2 <gc_execute_line+0xb08>
              } else {  // Incremental mode
                gc_block.values.xyz[idx] += gc_state.position[idx];
    1fa0:	f7 01       	movw	r30, r14
    1fa2:	20 81       	ld	r18, Z
    1fa4:	31 81       	ldd	r19, Z+1	; 0x01
    1fa6:	42 81       	ldd	r20, Z+2	; 0x02
    1fa8:	53 81       	ldd	r21, Z+3	; 0x03
    1faa:	d8 01       	movw	r26, r16
    1fac:	6d 91       	ld	r22, X+
    1fae:	7d 91       	ld	r23, X+
    1fb0:	8d 91       	ld	r24, X+
    1fb2:	9c 91       	ld	r25, X
    1fb4:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    1fb8:	f8 01       	movw	r30, r16
    1fba:	60 83       	st	Z, r22
    1fbc:	71 83       	std	Z+1, r23	; 0x01
    1fbe:	82 83       	std	Z+2, r24	; 0x02
    1fc0:	93 83       	std	Z+3, r25	; 0x03
    1fc2:	ff ef       	ldi	r31, 0xFF	; 255
    1fc4:	cf 1a       	sub	r12, r31
    1fc6:	df 0a       	sbc	r13, r31
    1fc8:	24 e0       	ldi	r18, 0x04	; 4
    1fca:	e2 0e       	add	r14, r18
    1fcc:	f1 1c       	adc	r15, r1
    1fce:	0c 5f       	subi	r16, 0xFC	; 252
    1fd0:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd2:	34 e0       	ldi	r19, 0x04	; 4
    1fd4:	83 0e       	add	r8, r19
    1fd6:	91 1c       	adc	r9, r1
    1fd8:	84 e0       	ldi	r24, 0x04	; 4
    1fda:	a8 0e       	add	r10, r24
    1fdc:	b1 1c       	adc	r11, r1
      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_words) {
        for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1fde:	93 e0       	ldi	r25, 0x03	; 3
    1fe0:	c9 16       	cp	r12, r25
    1fe2:	d1 04       	cpc	r13, r1
    1fe4:	09 f0       	breq	.+2      	; 0x1fe8 <gc_execute_line+0xb2e>
    1fe6:	a0 cf       	rjmp	.-192    	; 0x1f28 <gc_execute_line+0xa6e>
          }
        }
      }
    
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    1fe8:	a5 e0       	ldi	r26, 0x05	; 5
    1fea:	5a 16       	cp	r5, r26
    1fec:	81 f0       	breq	.+32     	; 0x200e <gc_execute_line+0xb54>
    1fee:	b7 e0       	ldi	r27, 0x07	; 7
    1ff0:	5b 16       	cp	r5, r27
    1ff2:	b9 f0       	breq	.+46     	; 0x2022 <gc_execute_line+0xb68>
    1ff4:	e3 e0       	ldi	r30, 0x03	; 3
    1ff6:	5e 12       	cpse	r5, r30
    1ff8:	1b c0       	rjmp	.+54     	; 0x2030 <gc_execute_line+0xb76>
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1ffa:	be 01       	movw	r22, r28
    1ffc:	63 5f       	subi	r22, 0xF3	; 243
    1ffe:	7f 4f       	sbci	r23, 0xFF	; 255
    2000:	86 e0       	ldi	r24, 0x06	; 6
    2002:	0e 94 6d 23 	call	0x46da	; 0x46da <settings_read_coord_data>
    2006:	88 23       	and	r24, r24
    2008:	09 f4       	brne	.+2      	; 0x200c <gc_execute_line+0xb52>
    200a:	ce c4       	rjmp	.+2460   	; 0x29a8 <gc_execute_line+0x14ee>
    200c:	11 c0       	rjmp	.+34     	; 0x2030 <gc_execute_line+0xb76>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    200e:	be 01       	movw	r22, r28
    2010:	63 5f       	subi	r22, 0xF3	; 243
    2012:	7f 4f       	sbci	r23, 0xFF	; 255
    2014:	87 e0       	ldi	r24, 0x07	; 7
    2016:	0e 94 6d 23 	call	0x46da	; 0x46da <settings_read_coord_data>
    201a:	88 23       	and	r24, r24
    201c:	09 f4       	brne	.+2      	; 0x2020 <gc_execute_line+0xb66>
    201e:	c6 c4       	rjmp	.+2444   	; 0x29ac <gc_execute_line+0x14f2>
    2020:	07 c0       	rjmp	.+14     	; 0x2030 <gc_execute_line+0xb76>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    2022:	80 91 46 06 	lds	r24, 0x0646
    2026:	82 30       	cpi	r24, 0x02	; 2
    2028:	08 f0       	brcs	.+2      	; 0x202c <gc_execute_line+0xb72>
    202a:	c2 c4       	rjmp	.+2436   	; 0x29b0 <gc_execute_line+0x14f6>
    202c:	01 c0       	rjmp	.+2      	; 0x2030 <gc_execute_line+0xb76>

      switch( gc_block.values.l) {
      	  case 1:
      	      if (int_value > N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); } // [Greater than N sys]
//      	      if (bit_istrue(value_words,bit(WORD_X)|bit(WORD_Y))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
      	      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    202e:	19 01       	movw	r2, r18
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    2030:	10 91 46 06 	lds	r17, 0x0646
    2034:	15 30       	cpi	r17, 0x05	; 5
    2036:	49 f4       	brne	.+18     	; 0x204a <gc_execute_line+0xb90>
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    2038:	fe 8d       	ldd	r31, Y+30	; 0x1e
    203a:	ff 23       	and	r31, r31
    203c:	09 f4       	brne	.+2      	; 0x2040 <gc_execute_line+0xb86>
    203e:	8f c2       	rjmp	.+1310   	; 0x255e <gc_execute_line+0x10a4>
    2040:	2b a1       	ldd	r18, Y+35	; 0x23
    2042:	21 30       	cpi	r18, 0x01	; 1
    2044:	09 f0       	breq	.+2      	; 0x2048 <gc_execute_line+0xb8e>
    2046:	b6 c4       	rjmp	.+2412   	; 0x29b4 <gc_execute_line+0x14fa>
    2048:	91 c2       	rjmp	.+1314   	; 0x256c <gc_execute_line+0x10b2>
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    }

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or 
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    204a:	3b a1       	ldd	r19, Y+35	; 0x23
    204c:	32 30       	cpi	r19, 0x02	; 2
    204e:	09 f0       	breq	.+2      	; 0x2052 <gc_execute_line+0xb98>
    2050:	86 c2       	rjmp	.+1292   	; 0x255e <gc_execute_line+0x10a4>
  
    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    2052:	11 11       	cpse	r17, r1
    2054:	05 c0       	rjmp	.+10     	; 0x2060 <gc_execute_line+0xba6>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    2056:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2058:	88 23       	and	r24, r24
    205a:	09 f4       	brne	.+2      	; 0x205e <gc_execute_line+0xba4>
    205c:	d4 c4       	rjmp	.+2472   	; 0x2a06 <gc_execute_line+0x154c>
    205e:	86 c2       	rjmp	.+1292   	; 0x256c <gc_execute_line+0x10b2>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2060:	20 e0       	ldi	r18, 0x00	; 0
    2062:	30 e0       	ldi	r19, 0x00	; 0
    2064:	a9 01       	movw	r20, r18
    2066:	60 91 51 06 	lds	r22, 0x0651
    206a:	70 91 52 06 	lds	r23, 0x0652
    206e:	80 91 53 06 	lds	r24, 0x0653
    2072:	90 91 54 06 	lds	r25, 0x0654
    2076:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    207a:	88 23       	and	r24, r24
    207c:	09 f4       	brne	.+2      	; 0x2080 <gc_execute_line+0xbc6>
    207e:	9c c4       	rjmp	.+2360   	; 0x29b8 <gc_execute_line+0x14fe>
     
      switch (gc_block.modal.motion) {
    2080:	14 30       	cpi	r17, 0x04	; 4
    2082:	28 f4       	brcc	.+10     	; 0x208e <gc_execute_line+0xbd4>
    2084:	12 30       	cpi	r17, 0x02	; 2
    2086:	60 f4       	brcc	.+24     	; 0x20a0 <gc_execute_line+0xbe6>
    2088:	11 30       	cpi	r17, 0x01	; 1
    208a:	29 f0       	breq	.+10     	; 0x2096 <gc_execute_line+0xbdc>
    208c:	68 c2       	rjmp	.+1232   	; 0x255e <gc_execute_line+0x10a4>
    208e:	14 30       	cpi	r17, 0x04	; 4
    2090:	09 f4       	brne	.+2      	; 0x2094 <gc_execute_line+0xbda>
    2092:	23 c2       	rjmp	.+1094   	; 0x24da <gc_execute_line+0x1020>
    2094:	64 c2       	rjmp	.+1224   	; 0x255e <gc_execute_line+0x10a4>
        case MOTION_MODE_LINEAR: 
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    2096:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2098:	99 23       	and	r25, r25
    209a:	09 f4       	brne	.+2      	; 0x209e <gc_execute_line+0xbe4>
    209c:	b4 c4       	rjmp	.+2408   	; 0x2a06 <gc_execute_line+0x154c>
    209e:	66 c2       	rjmp	.+1228   	; 0x256c <gc_execute_line+0x10b2>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20a0:	ae 8d       	ldd	r26, Y+30	; 0x1e
    20a2:	aa 23       	and	r26, r26
    20a4:	09 f4       	brne	.+2      	; 0x20a8 <gc_execute_line+0xbee>
    20a6:	8a c4       	rjmp	.+2324   	; 0x29bc <gc_execute_line+0x1502>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    20a8:	fe a1       	ldd	r31, Y+38	; 0x26
    20aa:	ef 2f       	mov	r30, r31
    20ac:	f0 e0       	ldi	r31, 0x00	; 0
    20ae:	fd a3       	std	Y+37, r31	; 0x25
    20b0:	ec a3       	std	Y+36, r30	; 0x24
    20b2:	3f a1       	ldd	r19, Y+39	; 0x27
    20b4:	23 2f       	mov	r18, r19
    20b6:	30 e0       	ldi	r19, 0x00	; 0
    20b8:	39 a7       	std	Y+41, r19	; 0x29
    20ba:	28 a7       	std	Y+40, r18	; 0x28
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	90 e0       	ldi	r25, 0x00	; 0
    20c0:	9c 01       	movw	r18, r24
    20c2:	0f a0       	ldd	r0, Y+39	; 0x27
    20c4:	02 c0       	rjmp	.+4      	; 0x20ca <gc_execute_line+0xc10>
    20c6:	22 0f       	add	r18, r18
    20c8:	33 1f       	adc	r19, r19
    20ca:	0a 94       	dec	r0
    20cc:	e2 f7       	brpl	.-8      	; 0x20c6 <gc_execute_line+0xc0c>
    20ce:	0e a0       	ldd	r0, Y+38	; 0x26
    20d0:	02 c0       	rjmp	.+4      	; 0x20d6 <gc_execute_line+0xc1c>
    20d2:	88 0f       	add	r24, r24
    20d4:	99 1f       	adc	r25, r25
    20d6:	0a 94       	dec	r0
    20d8:	e2 f7       	brpl	.-8      	; 0x20d2 <gc_execute_line+0xc18>
    20da:	89 01       	movw	r16, r18
    20dc:	08 2b       	or	r16, r24
    20de:	19 2b       	or	r17, r25
    20e0:	8a 2f       	mov	r24, r26
    20e2:	90 e0       	ldi	r25, 0x00	; 0
    20e4:	80 23       	and	r24, r16
    20e6:	91 23       	and	r25, r17
    20e8:	89 2b       	or	r24, r25
    20ea:	09 f4       	brne	.+2      	; 0x20ee <gc_execute_line+0xc34>
    20ec:	69 c4       	rjmp	.+2258   	; 0x29c0 <gc_execute_line+0x1506>
        
          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    20ee:	ee 0f       	add	r30, r30
    20f0:	ff 1f       	adc	r31, r31
    20f2:	ee 0f       	add	r30, r30
    20f4:	ff 1f       	adc	r31, r31
    20f6:	eb 5b       	subi	r30, 0xBB	; 187
    20f8:	f9 4f       	sbci	r31, 0xF9	; 249
    20fa:	ac a1       	ldd	r26, Y+36	; 0x24
    20fc:	bd a1       	ldd	r27, Y+37	; 0x25
    20fe:	aa 0f       	add	r26, r26
    2100:	bb 1f       	adc	r27, r27
    2102:	aa 0f       	add	r26, r26
    2104:	bb 1f       	adc	r27, r27
    2106:	af 5d       	subi	r26, 0xDF	; 223
    2108:	b9 4f       	sbci	r27, 0xF9	; 249
    210a:	2d 91       	ld	r18, X+
    210c:	3d 91       	ld	r19, X+
    210e:	4d 91       	ld	r20, X+
    2110:	5c 91       	ld	r21, X
    2112:	67 a5       	ldd	r22, Z+47	; 0x2f
    2114:	70 a9       	ldd	r23, Z+48	; 0x30
    2116:	81 a9       	ldd	r24, Z+49	; 0x31
    2118:	92 a9       	ldd	r25, Z+50	; 0x32
    211a:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    211e:	6b 01       	movw	r12, r22
    2120:	7c 01       	movw	r14, r24
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    2122:	e8 a5       	ldd	r30, Y+40	; 0x28
    2124:	f9 a5       	ldd	r31, Y+41	; 0x29
    2126:	ee 0f       	add	r30, r30
    2128:	ff 1f       	adc	r31, r31
    212a:	ee 0f       	add	r30, r30
    212c:	ff 1f       	adc	r31, r31
    212e:	eb 5b       	subi	r30, 0xBB	; 187
    2130:	f9 4f       	sbci	r31, 0xF9	; 249
    2132:	a8 a5       	ldd	r26, Y+40	; 0x28
    2134:	b9 a5       	ldd	r27, Y+41	; 0x29
    2136:	aa 0f       	add	r26, r26
    2138:	bb 1f       	adc	r27, r27
    213a:	aa 0f       	add	r26, r26
    213c:	bb 1f       	adc	r27, r27
    213e:	af 5d       	subi	r26, 0xDF	; 223
    2140:	b9 4f       	sbci	r27, 0xF9	; 249
    2142:	2d 91       	ld	r18, X+
    2144:	3d 91       	ld	r19, X+
    2146:	4d 91       	ld	r20, X+
    2148:	5c 91       	ld	r21, X
    214a:	67 a5       	ldd	r22, Z+47	; 0x2f
    214c:	70 a9       	ldd	r23, Z+48	; 0x30
    214e:	81 a9       	ldd	r24, Z+49	; 0x31
    2150:	92 a9       	ldd	r25, Z+50	; 0x32
    2152:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    2156:	4b 01       	movw	r8, r22
    2158:	5c 01       	movw	r10, r24

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
    215a:	30 fe       	sbrs	r3, 0
    215c:	10 c1       	rjmp	.+544    	; 0x237e <gc_execute_line+0xec4>
            bit_false(value_words,bit(WORD_R));
    215e:	e8 94       	clt
    2160:	30 f8       	bld	r3, 0

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
    2162:	20 91 74 06 	lds	r18, 0x0674
    2166:	30 91 75 06 	lds	r19, 0x0675
    216a:	40 91 76 06 	lds	r20, 0x0676
    216e:	50 91 77 06 	lds	r21, 0x0677
    2172:	60 91 21 06 	lds	r22, 0x0621
    2176:	70 91 22 06 	lds	r23, 0x0622
    217a:	80 91 23 06 	lds	r24, 0x0623
    217e:	90 91 24 06 	lds	r25, 0x0624
    2182:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    2186:	81 11       	cpse	r24, r1
    2188:	33 c4       	rjmp	.+2150   	; 0x29f0 <gc_execute_line+0x1536>
    218a:	20 91 78 06 	lds	r18, 0x0678
    218e:	30 91 79 06 	lds	r19, 0x0679
    2192:	40 91 7a 06 	lds	r20, 0x067A
    2196:	50 91 7b 06 	lds	r21, 0x067B
    219a:	60 91 25 06 	lds	r22, 0x0625
    219e:	70 91 26 06 	lds	r23, 0x0626
    21a2:	80 91 27 06 	lds	r24, 0x0627
    21a6:	90 91 28 06 	lds	r25, 0x0628
    21aa:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    21ae:	81 11       	cpse	r24, r1
    21b0:	1f c4       	rjmp	.+2110   	; 0x29f0 <gc_execute_line+0x1536>
    21b2:	20 91 7c 06 	lds	r18, 0x067C
    21b6:	30 91 7d 06 	lds	r19, 0x067D
    21ba:	40 91 7e 06 	lds	r20, 0x067E
    21be:	50 91 7f 06 	lds	r21, 0x067F
    21c2:	60 91 29 06 	lds	r22, 0x0629
    21c6:	70 91 2a 06 	lds	r23, 0x062A
    21ca:	80 91 2b 06 	lds	r24, 0x062B
    21ce:	90 91 2c 06 	lds	r25, 0x062C
    21d2:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    21d6:	81 11       	cpse	r24, r1
    21d8:	0b c4       	rjmp	.+2070   	; 0x29f0 <gc_execute_line+0x1536>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    21da:	81 e2       	ldi	r24, 0x21	; 33
    21dc:	19 c4       	rjmp	.+2098   	; 0x2a10 <gc_execute_line+0x1556>
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    21de:	0b e6       	ldi	r16, 0x6B	; 107
    21e0:	16 e0       	ldi	r17, 0x06	; 6
    21e2:	23 e3       	ldi	r18, 0x33	; 51
    21e4:	33 e3       	ldi	r19, 0x33	; 51
    21e6:	4b ec       	ldi	r20, 0xCB	; 203
    21e8:	51 e4       	ldi	r21, 0x41	; 65
    21ea:	d8 01       	movw	r26, r16
    21ec:	6d 91       	ld	r22, X+
    21ee:	7d 91       	ld	r23, X+
    21f0:	8d 91       	ld	r24, X+
    21f2:	9c 91       	ld	r25, X
    21f4:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    21f8:	f8 01       	movw	r30, r16
    21fa:	60 83       	st	Z, r22
    21fc:	71 83       	std	Z+1, r23	; 0x01
    21fe:	82 83       	std	Z+2, r24	; 0x02
    2200:	93 83       	std	Z+3, r25	; 0x03
                j = (y + (x * h_x2_div_d))/2       
            */      

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    2202:	40 90 6b 06 	lds	r4, 0x066B
    2206:	50 90 6c 06 	lds	r5, 0x066C
    220a:	60 90 6d 06 	lds	r6, 0x066D
    220e:	70 90 6e 06 	lds	r7, 0x066E
    2212:	20 e0       	ldi	r18, 0x00	; 0
    2214:	30 e0       	ldi	r19, 0x00	; 0
    2216:	40 e8       	ldi	r20, 0x80	; 128
    2218:	50 e4       	ldi	r21, 0x40	; 64
    221a:	c3 01       	movw	r24, r6
    221c:	b2 01       	movw	r22, r4
    221e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    2222:	9b 01       	movw	r18, r22
    2224:	ac 01       	movw	r20, r24
    2226:	c3 01       	movw	r24, r6
    2228:	b2 01       	movw	r22, r4
    222a:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    222e:	2b 01       	movw	r4, r22
    2230:	3c 01       	movw	r6, r24
    2232:	a7 01       	movw	r20, r14
    2234:	96 01       	movw	r18, r12
    2236:	c7 01       	movw	r24, r14
    2238:	b6 01       	movw	r22, r12
    223a:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    223e:	9b 01       	movw	r18, r22
    2240:	ac 01       	movw	r20, r24
    2242:	c3 01       	movw	r24, r6
    2244:	b2 01       	movw	r22, r4
    2246:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    224a:	2b 01       	movw	r4, r22
    224c:	3c 01       	movw	r6, r24
    224e:	a5 01       	movw	r20, r10
    2250:	94 01       	movw	r18, r8
    2252:	c5 01       	movw	r24, r10
    2254:	b4 01       	movw	r22, r8
    2256:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    225a:	9b 01       	movw	r18, r22
    225c:	ac 01       	movw	r20, r24
    225e:	c3 01       	movw	r24, r6
    2260:	b2 01       	movw	r22, r4
    2262:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    2266:	2b 01       	movw	r4, r22
    2268:	3c 01       	movw	r6, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    226a:	20 e0       	ldi	r18, 0x00	; 0
    226c:	30 e0       	ldi	r19, 0x00	; 0
    226e:	a9 01       	movw	r20, r18
    2270:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    2274:	88 23       	and	r24, r24
    2276:	0c f4       	brge	.+2      	; 0x227a <gc_execute_line+0xdc0>
    2278:	a5 c3       	rjmp	.+1866   	; 0x29c4 <gc_execute_line+0x150a>
    
            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    227a:	c3 01       	movw	r24, r6
    227c:	b2 01       	movw	r22, r4
    227e:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    2282:	2b 01       	movw	r4, r22
    2284:	3c 01       	movw	r6, r24
    2286:	a5 01       	movw	r20, r10
    2288:	94 01       	movw	r18, r8
    228a:	c7 01       	movw	r24, r14
    228c:	b6 01       	movw	r22, r12
    228e:	0e 94 f2 2a 	call	0x55e4	; 0x55e4 <hypot_f>
    2292:	9b 01       	movw	r18, r22
    2294:	ac 01       	movw	r20, r24
    2296:	c3 01       	movw	r24, r6
    2298:	b2 01       	movw	r22, r4
    229a:	90 58       	subi	r25, 0x80	; 128
    229c:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    22a0:	2b 01       	movw	r4, r22
    22a2:	3c 01       	movw	r6, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }  
    22a4:	80 91 46 06 	lds	r24, 0x0646
    22a8:	83 30       	cpi	r24, 0x03	; 3
    22aa:	21 f4       	brne	.+8      	; 0x22b4 <gc_execute_line+0xdfa>
    22ac:	77 fa       	bst	r7, 7
    22ae:	70 94       	com	r7
    22b0:	77 f8       	bld	r7, 7
    22b2:	70 94       	com	r7
            */  
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
            // even though it is advised against ever generating such circles in a single line of g-code. By 
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) { 
    22b4:	80 91 6b 06 	lds	r24, 0x066B
    22b8:	90 91 6c 06 	lds	r25, 0x066C
    22bc:	a0 91 6d 06 	lds	r26, 0x066D
    22c0:	b0 91 6e 06 	lds	r27, 0x066E
    22c4:	8e 8f       	std	Y+30, r24	; 0x1e
    22c6:	9f 8f       	std	Y+31, r25	; 0x1f
    22c8:	a8 a3       	std	Y+32, r26	; 0x20
    22ca:	b9 a3       	std	Y+33, r27	; 0x21
    22cc:	20 e0       	ldi	r18, 0x00	; 0
    22ce:	30 e0       	ldi	r19, 0x00	; 0
    22d0:	a9 01       	movw	r20, r18
    22d2:	bc 01       	movw	r22, r24
    22d4:	cd 01       	movw	r24, r26
    22d6:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    22da:	88 23       	and	r24, r24
    22dc:	8c f4       	brge	.+34     	; 0x2300 <gc_execute_line+0xe46>
                h_x2_div_d = -h_x2_div_d; 
    22de:	77 fa       	bst	r7, 7
    22e0:	70 94       	com	r7
    22e2:	77 f8       	bld	r7, 7
    22e4:	70 94       	com	r7
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    22e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    22e8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    22ea:	a8 a1       	ldd	r26, Y+32	; 0x20
    22ec:	b9 a1       	ldd	r27, Y+33	; 0x21
    22ee:	b0 58       	subi	r27, 0x80	; 128
    22f0:	80 93 6b 06 	sts	0x066B, r24
    22f4:	90 93 6c 06 	sts	0x066C, r25
    22f8:	a0 93 6d 06 	sts	0x066D, r26
    22fc:	b0 93 6e 06 	sts	0x066E, r27
            }        
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    2300:	0c a1       	ldd	r16, Y+36	; 0x24
    2302:	1d a1       	ldd	r17, Y+37	; 0x25
    2304:	00 0f       	add	r16, r16
    2306:	11 1f       	adc	r17, r17
    2308:	00 0f       	add	r16, r16
    230a:	11 1f       	adc	r17, r17
    230c:	0b 5b       	subi	r16, 0xBB	; 187
    230e:	19 4f       	sbci	r17, 0xF9	; 249
    2310:	a3 01       	movw	r20, r6
    2312:	92 01       	movw	r18, r4
    2314:	c5 01       	movw	r24, r10
    2316:	b4 01       	movw	r22, r8
    2318:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    231c:	9b 01       	movw	r18, r22
    231e:	ac 01       	movw	r20, r24
    2320:	c7 01       	movw	r24, r14
    2322:	b6 01       	movw	r22, r12
    2324:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    2328:	20 e0       	ldi	r18, 0x00	; 0
    232a:	30 e0       	ldi	r19, 0x00	; 0
    232c:	40 e0       	ldi	r20, 0x00	; 0
    232e:	5f e3       	ldi	r21, 0x3F	; 63
    2330:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    2334:	d8 01       	movw	r26, r16
    2336:	51 96       	adiw	r26, 0x11	; 17
    2338:	6d 93       	st	X+, r22
    233a:	7d 93       	st	X+, r23
    233c:	8d 93       	st	X+, r24
    233e:	9c 93       	st	X, r25
    2340:	54 97       	sbiw	r26, 0x14	; 20
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    2342:	08 a5       	ldd	r16, Y+40	; 0x28
    2344:	19 a5       	ldd	r17, Y+41	; 0x29
    2346:	00 0f       	add	r16, r16
    2348:	11 1f       	adc	r17, r17
    234a:	00 0f       	add	r16, r16
    234c:	11 1f       	adc	r17, r17
    234e:	0b 5b       	subi	r16, 0xBB	; 187
    2350:	19 4f       	sbci	r17, 0xF9	; 249
    2352:	a3 01       	movw	r20, r6
    2354:	92 01       	movw	r18, r4
    2356:	c7 01       	movw	r24, r14
    2358:	b6 01       	movw	r22, r12
    235a:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    235e:	a5 01       	movw	r20, r10
    2360:	94 01       	movw	r18, r8
    2362:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    2366:	20 e0       	ldi	r18, 0x00	; 0
    2368:	30 e0       	ldi	r19, 0x00	; 0
    236a:	40 e0       	ldi	r20, 0x00	; 0
    236c:	5f e3       	ldi	r21, 0x3F	; 63
    236e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    2372:	f8 01       	movw	r30, r16
    2374:	61 8b       	std	Z+17, r22	; 0x11
    2376:	72 8b       	std	Z+18, r23	; 0x12
    2378:	83 8b       	std	Z+19, r24	; 0x13
    237a:	94 8b       	std	Z+20, r25	; 0x14
    237c:	f7 c0       	rjmp	.+494    	; 0x256c <gc_execute_line+0x10b2>
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    237e:	fa a1       	ldd	r31, Y+34	; 0x22
    2380:	4f 2e       	mov	r4, r31
    2382:	51 2c       	mov	r5, r1
    2384:	04 21       	and	r16, r4
    2386:	15 21       	and	r17, r5
    2388:	01 2b       	or	r16, r17
    238a:	09 f4       	brne	.+2      	; 0x238e <gc_execute_line+0xed4>
    238c:	1d c3       	rjmp	.+1594   	; 0x29c8 <gc_execute_line+0x150e>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
    238e:	23 ee       	ldi	r18, 0xE3	; 227
    2390:	22 22       	and	r2, r18
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2392:	80 91 48 06 	lds	r24, 0x0648
    2396:	81 30       	cpi	r24, 0x01	; 1
    2398:	49 f5       	brne	.+82     	; 0x23ec <gc_execute_line+0xf32>
    239a:	0f 2e       	mov	r0, r31
    239c:	f6 e5       	ldi	r31, 0x56	; 86
    239e:	6f 2e       	mov	r6, r31
    23a0:	f6 e0       	ldi	r31, 0x06	; 6
    23a2:	7f 2e       	mov	r7, r31
    23a4:	f0 2d       	mov	r31, r0
    23a6:	00 e0       	ldi	r16, 0x00	; 0
    23a8:	10 e0       	ldi	r17, 0x00	; 0
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    23aa:	c2 01       	movw	r24, r4
    23ac:	00 2e       	mov	r0, r16
    23ae:	02 c0       	rjmp	.+4      	; 0x23b4 <gc_execute_line+0xefa>
    23b0:	95 95       	asr	r25
    23b2:	87 95       	ror	r24
    23b4:	0a 94       	dec	r0
    23b6:	e2 f7       	brpl	.-8      	; 0x23b0 <gc_execute_line+0xef6>
    23b8:	80 ff       	sbrs	r24, 0
    23ba:	10 c0       	rjmp	.+32     	; 0x23dc <gc_execute_line+0xf22>
    23bc:	23 e3       	ldi	r18, 0x33	; 51
    23be:	33 e3       	ldi	r19, 0x33	; 51
    23c0:	4b ec       	ldi	r20, 0xCB	; 203
    23c2:	51 e4       	ldi	r21, 0x41	; 65
    23c4:	d3 01       	movw	r26, r6
    23c6:	6d 91       	ld	r22, X+
    23c8:	7d 91       	ld	r23, X+
    23ca:	8d 91       	ld	r24, X+
    23cc:	9c 91       	ld	r25, X
    23ce:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    23d2:	f3 01       	movw	r30, r6
    23d4:	60 83       	st	Z, r22
    23d6:	71 83       	std	Z+1, r23	; 0x01
    23d8:	82 83       	std	Z+2, r24	; 0x02
    23da:	93 83       	std	Z+3, r25	; 0x03
    23dc:	0f 5f       	subi	r16, 0xFF	; 255
    23de:	1f 4f       	sbci	r17, 0xFF	; 255
    23e0:	f4 e0       	ldi	r31, 0x04	; 4
    23e2:	6f 0e       	add	r6, r31
    23e4:	71 1c       	adc	r7, r1
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    23e6:	03 30       	cpi	r16, 0x03	; 3
    23e8:	11 05       	cpc	r17, r1
    23ea:	f9 f6       	brne	.-66     	; 0x23aa <gc_execute_line+0xef0>
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    23ec:	08 a5       	ldd	r16, Y+40	; 0x28
    23ee:	19 a5       	ldd	r17, Y+41	; 0x29
    23f0:	00 0f       	add	r16, r16
    23f2:	11 1f       	adc	r17, r17
    23f4:	00 0f       	add	r16, r16
    23f6:	11 1f       	adc	r17, r17
    23f8:	0b 5b       	subi	r16, 0xBB	; 187
    23fa:	19 4f       	sbci	r17, 0xF9	; 249
    23fc:	d8 01       	movw	r26, r16
    23fe:	51 96       	adiw	r26, 0x11	; 17
    2400:	2d 91       	ld	r18, X+
    2402:	3d 91       	ld	r19, X+
    2404:	4d 91       	ld	r20, X+
    2406:	5c 91       	ld	r21, X
    2408:	54 97       	sbiw	r26, 0x14	; 20
    240a:	c5 01       	movw	r24, r10
    240c:	b4 01       	movw	r22, r8
    240e:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    2412:	2b 01       	movw	r4, r22
    2414:	3c 01       	movw	r6, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    2416:	8c a1       	ldd	r24, Y+36	; 0x24
    2418:	9d a1       	ldd	r25, Y+37	; 0x25
    241a:	88 0f       	add	r24, r24
    241c:	99 1f       	adc	r25, r25
    241e:	88 0f       	add	r24, r24
    2420:	99 1f       	adc	r25, r25
    2422:	fc 01       	movw	r30, r24
    2424:	eb 5b       	subi	r30, 0xBB	; 187
    2426:	f9 4f       	sbci	r31, 0xF9	; 249
    2428:	5f 01       	movw	r10, r30
    242a:	21 89       	ldd	r18, Z+17	; 0x11
    242c:	32 89       	ldd	r19, Z+18	; 0x12
    242e:	43 89       	ldd	r20, Z+19	; 0x13
    2430:	54 89       	ldd	r21, Z+20	; 0x14
    2432:	c7 01       	movw	r24, r14
    2434:	b6 01       	movw	r22, r12
    2436:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y); 
    243a:	a3 01       	movw	r20, r6
    243c:	92 01       	movw	r18, r4
    243e:	0e 94 f2 2a 	call	0x55e4	; 0x55e4 <hypot_f>
    2442:	6b 01       	movw	r12, r22
    2444:	7c 01       	movw	r14, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
    2446:	d8 01       	movw	r26, r16
    2448:	51 96       	adiw	r26, 0x11	; 17
    244a:	2d 91       	ld	r18, X+
    244c:	3d 91       	ld	r19, X+
    244e:	4d 91       	ld	r20, X+
    2450:	5c 91       	ld	r21, X
    2452:	54 97       	sbiw	r26, 0x14	; 20
    2454:	f5 01       	movw	r30, r10
    2456:	61 89       	ldd	r22, Z+17	; 0x11
    2458:	72 89       	ldd	r23, Z+18	; 0x12
    245a:	83 89       	ldd	r24, Z+19	; 0x13
    245c:	94 89       	ldd	r25, Z+20	; 0x14
    245e:	0e 94 f2 2a 	call	0x55e4	; 0x55e4 <hypot_f>
    2462:	4b 01       	movw	r8, r22
    2464:	5c 01       	movw	r10, r24
    2466:	60 93 6b 06 	sts	0x066B, r22
    246a:	70 93 6c 06 	sts	0x066C, r23
    246e:	80 93 6d 06 	sts	0x066D, r24
    2472:	90 93 6e 06 	sts	0x066E, r25
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    2476:	9b 01       	movw	r18, r22
    2478:	ac 01       	movw	r20, r24
    247a:	c7 01       	movw	r24, r14
    247c:	b6 01       	movw	r22, r12
    247e:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    2482:	6b 01       	movw	r12, r22
    2484:	7c 01       	movw	r14, r24
    2486:	e8 94       	clt
    2488:	f7 f8       	bld	r15, 7
            if (delta_r > 0.005) { 
    248a:	2a e0       	ldi	r18, 0x0A	; 10
    248c:	37 ed       	ldi	r19, 0xD7	; 215
    248e:	43 ea       	ldi	r20, 0xA3	; 163
    2490:	5b e3       	ldi	r21, 0x3B	; 59
    2492:	c7 01       	movw	r24, r14
    2494:	b6 01       	movw	r22, r12
    2496:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    249a:	18 16       	cp	r1, r24
    249c:	0c f0       	brlt	.+2      	; 0x24a0 <gc_execute_line+0xfe6>
    249e:	66 c0       	rjmp	.+204    	; 0x256c <gc_execute_line+0x10b2>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    24a0:	20 e0       	ldi	r18, 0x00	; 0
    24a2:	30 e0       	ldi	r19, 0x00	; 0
    24a4:	40 e0       	ldi	r20, 0x00	; 0
    24a6:	5f e3       	ldi	r21, 0x3F	; 63
    24a8:	c7 01       	movw	r24, r14
    24aa:	b6 01       	movw	r22, r12
    24ac:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    24b0:	18 16       	cp	r1, r24
    24b2:	0c f4       	brge	.+2      	; 0x24b6 <gc_execute_line+0xffc>
    24b4:	8b c2       	rjmp	.+1302   	; 0x29cc <gc_execute_line+0x1512>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    24b6:	2f e6       	ldi	r18, 0x6F	; 111
    24b8:	32 e1       	ldi	r19, 0x12	; 18
    24ba:	43 e8       	ldi	r20, 0x83	; 131
    24bc:	5a e3       	ldi	r21, 0x3A	; 58
    24be:	c5 01       	movw	r24, r10
    24c0:	b4 01       	movw	r22, r8
    24c2:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    24c6:	9b 01       	movw	r18, r22
    24c8:	ac 01       	movw	r20, r24
    24ca:	c7 01       	movw	r24, r14
    24cc:	b6 01       	movw	r22, r12
    24ce:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    24d2:	18 16       	cp	r1, r24
    24d4:	0c f4       	brge	.+2      	; 0x24d8 <gc_execute_line+0x101e>
    24d6:	7c c2       	rjmp	.+1272   	; 0x29d0 <gc_execute_line+0x1516>
    24d8:	49 c0       	rjmp	.+146    	; 0x256c <gc_execute_line+0x10b2>
          }
          break;
        case MOTION_MODE_PROBE:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    24da:	fe 8d       	ldd	r31, Y+30	; 0x1e
    24dc:	ff 23       	and	r31, r31
    24de:	09 f4       	brne	.+2      	; 0x24e2 <gc_execute_line+0x1028>
    24e0:	79 c2       	rjmp	.+1266   	; 0x29d4 <gc_execute_line+0x151a>

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
    24e2:	20 91 74 06 	lds	r18, 0x0674
    24e6:	30 91 75 06 	lds	r19, 0x0675
    24ea:	40 91 76 06 	lds	r20, 0x0676
    24ee:	50 91 77 06 	lds	r21, 0x0677
    24f2:	60 91 21 06 	lds	r22, 0x0621
    24f6:	70 91 22 06 	lds	r23, 0x0622
    24fa:	80 91 23 06 	lds	r24, 0x0623
    24fe:	90 91 24 06 	lds	r25, 0x0624
    2502:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    2506:	81 11       	cpse	r24, r1
    2508:	79 c2       	rjmp	.+1266   	; 0x29fc <gc_execute_line+0x1542>
    250a:	20 91 78 06 	lds	r18, 0x0678
    250e:	30 91 79 06 	lds	r19, 0x0679
    2512:	40 91 7a 06 	lds	r20, 0x067A
    2516:	50 91 7b 06 	lds	r21, 0x067B
    251a:	60 91 25 06 	lds	r22, 0x0625
    251e:	70 91 26 06 	lds	r23, 0x0626
    2522:	80 91 27 06 	lds	r24, 0x0627
    2526:	90 91 28 06 	lds	r25, 0x0628
    252a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    252e:	81 11       	cpse	r24, r1
    2530:	65 c2       	rjmp	.+1226   	; 0x29fc <gc_execute_line+0x1542>
    2532:	20 91 7c 06 	lds	r18, 0x067C
    2536:	30 91 7d 06 	lds	r19, 0x067D
    253a:	40 91 7e 06 	lds	r20, 0x067E
    253e:	50 91 7f 06 	lds	r21, 0x067F
    2542:	60 91 29 06 	lds	r22, 0x0629
    2546:	70 91 2a 06 	lds	r23, 0x062A
    254a:	80 91 2b 06 	lds	r24, 0x062B
    254e:	90 91 2c 06 	lds	r25, 0x062C
    2552:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    2556:	81 11       	cpse	r24, r1
    2558:	51 c2       	rjmp	.+1186   	; 0x29fc <gc_execute_line+0x1542>
          break;
        case MOTION_MODE_PROBE:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    255a:	81 e2       	ldi	r24, 0x21	; 33
    255c:	59 c2       	rjmp	.+1202   	; 0x2a10 <gc_execute_line+0x1556>
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    255e:	2b a1       	ldd	r18, Y+35	; 0x23
    2560:	21 11       	cpse	r18, r1
    2562:	04 c0       	rjmp	.+8      	; 0x256c <gc_execute_line+0x10b2>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    2564:	c1 01       	movw	r24, r2
    2566:	8e 7b       	andi	r24, 0xBE	; 190
    2568:	99 7f       	andi	r25, 0xF9	; 249
    256a:	03 c0       	rjmp	.+6      	; 0x2572 <gc_execute_line+0x10b8>
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    256c:	c1 01       	movw	r24, r2
    256e:	8e 7b       	andi	r24, 0xBE	; 190
    2570:	91 7c       	andi	r25, 0xC1	; 193
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2572:	89 2b       	or	r24, r25
    2574:	09 f0       	breq	.+2      	; 0x2578 <gc_execute_line+0x10be>
    2576:	30 c2       	rjmp	.+1120   	; 0x29d8 <gc_execute_line+0x151e>
  */ 
  
  // [1. Comments feedback ]:  NOT SUPPORTED
  
  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    2578:	80 91 47 06 	lds	r24, 0x0647
    257c:	80 93 be 05 	sts	0x05BE, r24
  
  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    2580:	80 91 51 06 	lds	r24, 0x0651
    2584:	90 91 52 06 	lds	r25, 0x0652
    2588:	a0 91 53 06 	lds	r26, 0x0653
    258c:	b0 91 54 06 	lds	r27, 0x0654
    2590:	80 93 cc 05 	sts	0x05CC, r24
    2594:	90 93 cd 05 	sts	0x05CD, r25
    2598:	a0 93 ce 05 	sts	0x05CE, r26
    259c:	b0 93 cf 05 	sts	0x05CF, r27

  // [4. Set spindle speed ]:
  if (gc_state.spindle_speed != gc_block.values.s) { 
    25a0:	c0 90 6f 06 	lds	r12, 0x066F
    25a4:	d0 90 70 06 	lds	r13, 0x0670
    25a8:	e0 90 71 06 	lds	r14, 0x0671
    25ac:	f0 90 72 06 	lds	r15, 0x0672
    25b0:	a7 01       	movw	r20, r14
    25b2:	96 01       	movw	r18, r12
    25b4:	60 91 c8 05 	lds	r22, 0x05C8
    25b8:	70 91 c9 05 	lds	r23, 0x05C9
    25bc:	80 91 ca 05 	lds	r24, 0x05CA
    25c0:	90 91 cb 05 	lds	r25, 0x05CB
    25c4:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    25c8:	88 23       	and	r24, r24
    25ca:	d1 f0       	breq	.+52     	; 0x2600 <gc_execute_line+0x1146>
    gc_state.spindle_speed = gc_block.values.s; 
    25cc:	c0 92 c8 05 	sts	0x05C8, r12
    25d0:	d0 92 c9 05 	sts	0x05C9, r13
    25d4:	e0 92 ca 05 	sts	0x05CA, r14
    25d8:	f0 92 cb 05 	sts	0x05CB, r15
    
    // Update running spindle only if not in check mode and not already enabled.
    if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    25dc:	80 91 c5 05 	lds	r24, 0x05C5
    25e0:	88 23       	and	r24, r24
    25e2:	71 f0       	breq	.+28     	; 0x2600 <gc_execute_line+0x1146>

//    	if (sys.state != STATE_CYCLE) protocol_auto_cycle_start();
    	protocol_buffer_synchronize(); // Finish all remaining buffered motions. Program paused when complete.
    25e4:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>
    	spindle_run(gc_state.modal.spindle, gc_state.spindle_speed);
    25e8:	40 91 c8 05 	lds	r20, 0x05C8
    25ec:	50 91 c9 05 	lds	r21, 0x05C9
    25f0:	60 91 ca 05 	lds	r22, 0x05CA
    25f4:	70 91 cb 05 	lds	r23, 0x05CB
    25f8:	80 91 c5 05 	lds	r24, 0x05C5
    25fc:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <spindle_run>
    }
  }
    
  // [5. Select tool ]:
  if (gc_state.tool_slot != gc_block.values.t) {
    2600:	80 91 73 06 	lds	r24, 0x0673
    2604:	90 91 d0 05 	lds	r25, 0x05D0
    2608:	98 17       	cp	r25, r24
    260a:	21 f0       	breq	.+8      	; 0x2614 <gc_execute_line+0x115a>
	  gc_state.tool_slot = gc_block.values.t;
    260c:	80 93 d0 05 	sts	0x05D0, r24
	  tools_select( gc_state.tool_slot);
    2610:	0e 94 80 38 	call	0x7100	; 0x7100 <tools_select>
  }

  // [6. Change tool ]:
  if (gc_state.modal.tool != gc_block.modal.tool) {
    2614:	90 91 c6 05 	lds	r25, 0x05C6
    2618:	80 91 4f 06 	lds	r24, 0x064F
    261c:	98 17       	cp	r25, r24
    261e:	59 f0       	breq	.+22     	; 0x2636 <gc_execute_line+0x117c>
	gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED;
    2620:	81 e0       	ldi	r24, 0x01	; 1
    2622:	80 93 4c 06 	sts	0x064C, r24
    protocol_buffer_synchronize(); // Finish all remaining buffered motions. Program paused when complete.
    2626:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>

	gc_state.modal.tool = gc_block.modal.tool;
    262a:	80 91 4f 06 	lds	r24, 0x064F
    262e:	80 93 c6 05 	sts	0x05C6, r24
	// add code for tool change here
	tools_change();
    2632:	0e 94 81 38 	call	0x7102	; 0x7102 <tools_change>
  }

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    2636:	80 91 4e 06 	lds	r24, 0x064E
    263a:	90 91 c5 05 	lds	r25, 0x05C5
    263e:	98 17       	cp	r25, r24
    2640:	91 f0       	breq	.+36     	; 0x2666 <gc_execute_line+0x11ac>
    gc_state.modal.spindle = gc_block.modal.spindle;    
    2642:	05 ec       	ldi	r16, 0xC5	; 197
    2644:	15 e0       	ldi	r17, 0x05	; 5
    2646:	d8 01       	movw	r26, r16
    2648:	8c 93       	st	X, r24

    // Update spindle control and apply spindle speed when enabling it in this block.    
//    if (sys.state != STATE_CYCLE) protocol_auto_cycle_start();
    protocol_buffer_synchronize(); // Finish all remaining buffered motions. Program paused when complete.
    264a:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>
    spindle_run(gc_state.modal.spindle, gc_state.spindle_speed);
    264e:	40 91 c8 05 	lds	r20, 0x05C8
    2652:	50 91 c9 05 	lds	r21, 0x05C9
    2656:	60 91 ca 05 	lds	r22, 0x05CA
    265a:	70 91 cb 05 	lds	r23, 0x05CB
    265e:	f8 01       	movw	r30, r16
    2660:	80 81       	ld	r24, Z
    2662:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <spindle_run>
  }

  // [8. Coolant control ]:  
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    2666:	80 91 4d 06 	lds	r24, 0x064D
    266a:	90 91 c4 05 	lds	r25, 0x05C4
    266e:	98 17       	cp	r25, r24
    2670:	51 f0       	breq	.+20     	; 0x2686 <gc_execute_line+0x11cc>
    gc_state.modal.coolant = gc_block.modal.coolant;
    2672:	04 ec       	ldi	r16, 0xC4	; 196
    2674:	15 e0       	ldi	r17, 0x05	; 5
    2676:	d8 01       	movw	r26, r16
    2678:	8c 93       	st	X, r24

//    if (sys.state != STATE_CYCLE) protocol_auto_cycle_start();
    protocol_buffer_synchronize(); // Finish all remaining buffered motions. Program paused when complete.
    267a:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>
    coolant_run(gc_state.modal.coolant);
    267e:	f8 01       	movw	r30, r16
    2680:	80 81       	ld	r24, Z
    2682:	0e 94 66 15 	call	0x2acc	; 0x2acc <coolant_run>
  }
  
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    2686:	80 91 45 06 	lds	r24, 0x0645
    268a:	81 30       	cpi	r24, 0x01	; 1
    268c:	51 f4       	brne	.+20     	; 0x26a2 <gc_execute_line+0x11e8>
    268e:	60 91 67 06 	lds	r22, 0x0667
    2692:	70 91 68 06 	lds	r23, 0x0668
    2696:	80 91 69 06 	lds	r24, 0x0669
    269a:	90 91 6a 06 	lds	r25, 0x066A
    269e:	0e 94 ba 08 	call	0x1174	; 0x1174 <mc_dwell>
  
  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;  
    26a2:	80 91 4a 06 	lds	r24, 0x064A
    26a6:	80 93 c1 05 	sts	0x05C1, r24

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    26aa:	80 91 48 06 	lds	r24, 0x0648
    26ae:	80 93 bf 05 	sts	0x05BF, r24
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array. 

  // [14. Cutter length compensation ]: NOT SUPPORTED
  if ( gc_state.modal.tool_comp != gc_block.values.h ) {
    26b2:	80 91 55 06 	lds	r24, 0x0655
    26b6:	90 91 c7 05 	lds	r25, 0x05C7
    26ba:	98 13       	cpse	r25, r24
	  gc_state.modal.tool_comp = gc_block.values.h;
    26bc:	80 93 c7 05 	sts	0x05C7, r24
      gc_state.tool_length_offset = 0.0;
    }
  }
*/
  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    26c0:	80 91 4b 06 	lds	r24, 0x064B
    26c4:	90 91 c2 05 	lds	r25, 0x05C2
    26c8:	98 17       	cp	r25, r24
    26ca:	59 f0       	breq	.+22     	; 0x26e2 <gc_execute_line+0x1228>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    26cc:	80 93 c2 05 	sts	0x05C2, r24
    memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    26d0:	8c e0       	ldi	r24, 0x0C	; 12
    26d2:	fe 01       	movw	r30, r28
    26d4:	31 96       	adiw	r30, 0x01	; 1
    26d6:	ad e2       	ldi	r26, 0x2D	; 45
    26d8:	b6 e0       	ldi	r27, 0x06	; 6
    26da:	01 90       	ld	r0, Z+
    26dc:	0d 92       	st	X+, r0
    26de:	8a 95       	dec	r24
    26e0:	e1 f7       	brne	.-8      	; 0x26da <gc_execute_line+0x1220>
  }
  
  // [16. Set path control mode ]: NOT SUPPORTED
  
  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    26e2:	80 91 49 06 	lds	r24, 0x0649
    26e6:	80 93 c0 05 	sts	0x05C0, r24
  
  // [18. Set retract mode ]: NOT SUPPORTED
    
  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    26ea:	80 91 45 06 	lds	r24, 0x0645
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	fc 01       	movw	r30, r24
    26f2:	32 97       	sbiw	r30, 0x02	; 2
    26f4:	e8 30       	cpi	r30, 0x08	; 8
    26f6:	f1 05       	cpc	r31, r1
    26f8:	08 f0       	brcs	.+2      	; 0x26fc <gc_execute_line+0x1242>
    26fa:	94 c0       	rjmp	.+296    	; 0x2824 <gc_execute_line+0x136a>
    26fc:	e9 53       	subi	r30, 0x39	; 57
    26fe:	ff 4f       	sbci	r31, 0xFF	; 255
    2700:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
	  case NON_MODAL_SET_COORDINATE_DATA:
		int_value = trunc(gc_block.values.p); // Convert p value to int.
    2704:	60 91 67 06 	lds	r22, 0x0667
    2708:	70 91 68 06 	lds	r23, 0x0668
    270c:	80 91 69 06 	lds	r24, 0x0669
    2710:	90 91 6a 06 	lds	r25, 0x066A
    2714:	0e 94 68 3c 	call	0x78d0	; 0x78d0 <trunc>
    2718:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    271c:	86 2f       	mov	r24, r22
		switch( gc_block.values.l) {
    271e:	90 91 62 06 	lds	r25, 0x0662
    2722:	92 30       	cpi	r25, 0x02	; 2
    2724:	41 f1       	breq	.+80     	; 0x2776 <gc_execute_line+0x12bc>
    2726:	94 31       	cpi	r25, 0x14	; 20
    2728:	31 f1       	breq	.+76     	; 0x2776 <gc_execute_line+0x12bc>
    272a:	91 30       	cpi	r25, 0x01	; 1
    272c:	09 f0       	breq	.+2      	; 0x2730 <gc_execute_line+0x1276>
    272e:	7a c0       	rjmp	.+244    	; 0x2824 <gc_execute_line+0x136a>
				case 1:
				  gc_state.tool_table[ int_value].r = gc_block.values.r;
    2730:	f0 e1       	ldi	r31, 0x10	; 16
    2732:	6f 9f       	mul	r22, r31
    2734:	90 01       	movw	r18, r0
    2736:	11 24       	eor	r1, r1
    2738:	f9 01       	movw	r30, r18
    273a:	e3 54       	subi	r30, 0x43	; 67
    273c:	fa 4f       	sbci	r31, 0xFA	; 250
    273e:	40 91 6b 06 	lds	r20, 0x066B
    2742:	50 91 6c 06 	lds	r21, 0x066C
    2746:	60 91 6d 06 	lds	r22, 0x066D
    274a:	70 91 6e 06 	lds	r23, 0x066E
    274e:	44 8b       	std	Z+20, r20	; 0x14
    2750:	55 8b       	std	Z+21, r21	; 0x15
    2752:	66 8b       	std	Z+22, r22	; 0x16
    2754:	77 8b       	std	Z+23, r23	; 0x17
				  memcpy( gc_state.tool_table[ int_value].xyz, gc_block.values.xyz, sizeof( gc_block.values.xyz));
    2756:	d9 01       	movw	r26, r18
    2758:	ab 52       	subi	r26, 0x2B	; 43
    275a:	ba 4f       	sbci	r27, 0xFA	; 250
    275c:	9c e0       	ldi	r25, 0x0C	; 12
    275e:	e4 e7       	ldi	r30, 0x74	; 116
    2760:	f6 e0       	ldi	r31, 0x06	; 6
    2762:	01 90       	ld	r0, Z+
    2764:	0d 92       	st	X+, r0
    2766:	9a 95       	dec	r25
    2768:	e1 f7       	brne	.-8      	; 0x2762 <gc_execute_line+0x12a8>

				  settings_write_tool_data( int_value, &gc_state.tool_table[ int_value]);
    276a:	b9 01       	movw	r22, r18
    276c:	6f 52       	subi	r22, 0x2F	; 47
    276e:	7a 4f       	sbci	r23, 0xFA	; 250
    2770:	0e 94 5e 22 	call	0x44bc	; 0x44bc <settings_write_tool_data>
				  break;
    2774:	57 c0       	rjmp	.+174    	; 0x2824 <gc_execute_line+0x136a>
				case 2:
				case 20:
				  if (int_value > 0) { int_value--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    2776:	88 23       	and	r24, r24
    2778:	19 f0       	breq	.+6      	; 0x2780 <gc_execute_line+0x12c6>
    277a:	1f ef       	ldi	r17, 0xFF	; 255
    277c:	18 0f       	add	r17, r24
    277e:	02 c0       	rjmp	.+4      	; 0x2784 <gc_execute_line+0x12ca>
				  else { int_value = gc_state.modal.coord_select; } // Index P0 as the active coordinate system
    2780:	10 91 c2 05 	lds	r17, 0x05C2

				  settings_write_coord_data(int_value,parameter_data);
    2784:	be 01       	movw	r22, r28
    2786:	63 5f       	subi	r22, 0xF3	; 243
    2788:	7f 4f       	sbci	r23, 0xFF	; 255
    278a:	81 2f       	mov	r24, r17
    278c:	0e 94 54 22 	call	0x44a8	; 0x44a8 <settings_write_coord_data>
				  // Update system coordinate system if currently active.
				  if (gc_state.modal.coord_select == int_value) { memcpy(gc_state.coord_system,parameter_data,sizeof(parameter_data)); }
    2790:	80 91 c2 05 	lds	r24, 0x05C2
    2794:	81 13       	cpse	r24, r17
    2796:	46 c0       	rjmp	.+140    	; 0x2824 <gc_execute_line+0x136a>
    2798:	8c e0       	ldi	r24, 0x0C	; 12
    279a:	fe 01       	movw	r30, r28
    279c:	3d 96       	adiw	r30, 0x0d	; 13
    279e:	ad e2       	ldi	r26, 0x2D	; 45
    27a0:	b6 e0       	ldi	r27, 0x06	; 6
    27a2:	01 90       	ld	r0, Z+
    27a4:	0d 92       	st	X+, r0
    27a6:	8a 95       	dec	r24
    27a8:	e1 f7       	brne	.-8      	; 0x27a2 <gc_execute_line+0x12e8>
    27aa:	3c c0       	rjmp	.+120    	; 0x2824 <gc_execute_line+0x136a>
		}
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1: 
      // Move to intermediate position before going home. Obeys current coordinate system and offsets 
      // and absolute and incremental modes.
      if (axis_command) {
    27ac:	2b a1       	ldd	r18, Y+35	; 0x23
    27ae:	22 23       	and	r18, r18
    27b0:	49 f0       	breq	.+18     	; 0x27c4 <gc_execute_line+0x130a>
        #ifdef USE_LINE_NUMBERS
          mc_line(gc_block.values.xyz, -1.0, false, gc_block.values.n);
        #else
          mc_line(gc_block.values.xyz, -1.0, false);
    27b2:	20 e0       	ldi	r18, 0x00	; 0
    27b4:	40 e0       	ldi	r20, 0x00	; 0
    27b6:	50 e0       	ldi	r21, 0x00	; 0
    27b8:	60 e8       	ldi	r22, 0x80	; 128
    27ba:	7f eb       	ldi	r23, 0xBF	; 191
    27bc:	84 e7       	ldi	r24, 0x74	; 116
    27be:	96 e0       	ldi	r25, 0x06	; 6
    27c0:	0e 94 62 05 	call	0xac4	; 0xac4 <mc_line>
        #endif
      }
      #ifdef USE_LINE_NUMBERS
        mc_line(parameter_data, -1.0, false, gc_block.values.n); 
      #else
        mc_line(parameter_data, -1.0, false); 
    27c4:	20 e0       	ldi	r18, 0x00	; 0
    27c6:	40 e0       	ldi	r20, 0x00	; 0
    27c8:	50 e0       	ldi	r21, 0x00	; 0
    27ca:	60 e8       	ldi	r22, 0x80	; 128
    27cc:	7f eb       	ldi	r23, 0xBF	; 191
    27ce:	ce 01       	movw	r24, r28
    27d0:	0d 96       	adiw	r24, 0x0d	; 13
    27d2:	0e 94 62 05 	call	0xac4	; 0xac4 <mc_line>
      #endif
      memcpy(gc_state.position, parameter_data, sizeof(parameter_data));
    27d6:	8c e0       	ldi	r24, 0x0C	; 12
    27d8:	fe 01       	movw	r30, r28
    27da:	3d 96       	adiw	r30, 0x0d	; 13
    27dc:	a1 e2       	ldi	r26, 0x21	; 33
    27de:	b6 e0       	ldi	r27, 0x06	; 6
    27e0:	01 90       	ld	r0, Z+
    27e2:	0d 92       	st	X+, r0
    27e4:	8a 95       	dec	r24
    27e6:	e1 f7       	brne	.-8      	; 0x27e0 <gc_execute_line+0x1326>
      break;
    27e8:	1d c0       	rjmp	.+58     	; 0x2824 <gc_execute_line+0x136a>
    case NON_MODAL_SET_HOME_0: 
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    27ea:	61 e2       	ldi	r22, 0x21	; 33
    27ec:	76 e0       	ldi	r23, 0x06	; 6
    27ee:	86 e0       	ldi	r24, 0x06	; 6
    27f0:	0e 94 54 22 	call	0x44a8	; 0x44a8 <settings_write_coord_data>
      break;
    27f4:	17 c0       	rjmp	.+46     	; 0x2824 <gc_execute_line+0x136a>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    27f6:	61 e2       	ldi	r22, 0x21	; 33
    27f8:	76 e0       	ldi	r23, 0x06	; 6
    27fa:	87 e0       	ldi	r24, 0x07	; 7
    27fc:	0e 94 54 22 	call	0x44a8	; 0x44a8 <settings_write_coord_data>
      break;
    2800:	11 c0       	rjmp	.+34     	; 0x2824 <gc_execute_line+0x136a>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    2802:	8c e0       	ldi	r24, 0x0C	; 12
    2804:	e4 e7       	ldi	r30, 0x74	; 116
    2806:	f6 e0       	ldi	r31, 0x06	; 6
    2808:	a9 e3       	ldi	r26, 0x39	; 57
    280a:	b6 e0       	ldi	r27, 0x06	; 6
    280c:	01 90       	ld	r0, Z+
    280e:	0d 92       	st	X+, r0
    2810:	8a 95       	dec	r24
    2812:	e1 f7       	brne	.-8      	; 0x280c <gc_execute_line+0x1352>
      break;
    2814:	07 c0       	rjmp	.+14     	; 0x2824 <gc_execute_line+0x136a>
    case NON_MODAL_RESET_COORDINATE_OFFSET: 
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    2816:	8c e0       	ldi	r24, 0x0C	; 12
    2818:	e9 e3       	ldi	r30, 0x39	; 57
    281a:	f6 e0       	ldi	r31, 0x06	; 6
    281c:	df 01       	movw	r26, r30
    281e:	1d 92       	st	X+, r1
    2820:	8a 95       	dec	r24
    2822:	e9 f7       	brne	.-6      	; 0x281e <gc_execute_line+0x1364>

  
  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes. 
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    2824:	80 91 46 06 	lds	r24, 0x0646
    2828:	80 93 bd 05 	sts	0x05BD, r24
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    282c:	85 30       	cpi	r24, 0x05	; 5
    282e:	09 f4       	brne	.+2      	; 0x2832 <gc_execute_line+0x1378>
    2830:	62 c0       	rjmp	.+196    	; 0x28f6 <gc_execute_line+0x143c>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    2832:	bb a1       	ldd	r27, Y+35	; 0x23
    2834:	b2 30       	cpi	r27, 0x02	; 2
    2836:	09 f0       	breq	.+2      	; 0x283a <gc_execute_line+0x1380>
    2838:	5e c0       	rjmp	.+188    	; 0x28f6 <gc_execute_line+0x143c>
      switch (gc_state.modal.motion) {
    283a:	84 30       	cpi	r24, 0x04	; 4
    283c:	38 f4       	brcc	.+14     	; 0x284c <gc_execute_line+0x1392>
    283e:	82 30       	cpi	r24, 0x02	; 2
    2840:	08 f5       	brcc	.+66     	; 0x2884 <gc_execute_line+0x13ca>
    2842:	88 23       	and	r24, r24
    2844:	31 f0       	breq	.+12     	; 0x2852 <gc_execute_line+0x1398>
    2846:	81 30       	cpi	r24, 0x01	; 1
    2848:	71 f0       	breq	.+28     	; 0x2866 <gc_execute_line+0x13ac>
    284a:	4c c0       	rjmp	.+152    	; 0x28e4 <gc_execute_line+0x142a>
    284c:	84 30       	cpi	r24, 0x04	; 4
    284e:	e1 f1       	breq	.+120    	; 0x28c8 <gc_execute_line+0x140e>
    2850:	49 c0       	rjmp	.+146    	; 0x28e4 <gc_execute_line+0x142a>
        case MOTION_MODE_SEEK:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, -1.0, false, gc_block.values.n);
          #else
            mc_line(gc_block.values.xyz, -1.0, false);
    2852:	20 e0       	ldi	r18, 0x00	; 0
    2854:	40 e0       	ldi	r20, 0x00	; 0
    2856:	50 e0       	ldi	r21, 0x00	; 0
    2858:	60 e8       	ldi	r22, 0x80	; 128
    285a:	7f eb       	ldi	r23, 0xBF	; 191
    285c:	84 e7       	ldi	r24, 0x74	; 116
    285e:	96 e0       	ldi	r25, 0x06	; 6
    2860:	0e 94 62 05 	call	0xac4	; 0xac4 <mc_line>
          #endif
          break;
    2864:	3f c0       	rjmp	.+126    	; 0x28e4 <gc_execute_line+0x142a>
        case MOTION_MODE_LINEAR:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_block.values.n);
          #else
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
    2866:	40 91 cc 05 	lds	r20, 0x05CC
    286a:	50 91 cd 05 	lds	r21, 0x05CD
    286e:	60 91 ce 05 	lds	r22, 0x05CE
    2872:	70 91 cf 05 	lds	r23, 0x05CF
    2876:	20 91 be 05 	lds	r18, 0x05BE
    287a:	84 e7       	ldi	r24, 0x74	; 116
    287c:	96 e0       	ldi	r25, 0x06	; 6
    287e:	0e 94 62 05 	call	0xac4	; 0xac4 <mc_line>
          #endif
          break;
    2882:	30 c0       	rjmp	.+96     	; 0x28e4 <gc_execute_line+0x142a>
        case MOTION_MODE_CW_ARC: case MOTION_MODE_CCW_ARC:
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, gc_block.values.n);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    2884:	c0 90 cc 05 	lds	r12, 0x05CC
    2888:	d0 90 cd 05 	lds	r13, 0x05CD
    288c:	e0 90 ce 05 	lds	r14, 0x05CE
    2890:	f0 90 cf 05 	lds	r15, 0x05CF
    2894:	00 91 6b 06 	lds	r16, 0x066B
    2898:	10 91 6c 06 	lds	r17, 0x066C
    289c:	20 91 6d 06 	lds	r18, 0x066D
    28a0:	30 91 6e 06 	lds	r19, 0x066E
    28a4:	ea a5       	ldd	r30, Y+42	; 0x2a
    28a6:	ef 93       	push	r30
    28a8:	ff a1       	ldd	r31, Y+39	; 0x27
    28aa:	ff 93       	push	r31
    28ac:	8e a0       	ldd	r8, Y+38	; 0x26
    28ae:	a0 90 be 05 	lds	r10, 0x05BE
    28b2:	46 e5       	ldi	r20, 0x56	; 86
    28b4:	56 e0       	ldi	r21, 0x06	; 6
    28b6:	64 e7       	ldi	r22, 0x74	; 116
    28b8:	76 e0       	ldi	r23, 0x06	; 6
    28ba:	81 e2       	ldi	r24, 0x21	; 33
    28bc:	96 e0       	ldi	r25, 0x06	; 6
    28be:	0e 94 9f 05 	call	0xb3e	; 0xb3e <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear); 
          #endif
          break;
    28c2:	0f 90       	pop	r0
    28c4:	0f 90       	pop	r0
    28c6:	0e c0       	rjmp	.+28     	; 0x28e4 <gc_execute_line+0x142a>
          // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
          // upon a successful probing cycle, the machine position and the returned value should be the same.
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_block.values.n);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
    28c8:	40 91 cc 05 	lds	r20, 0x05CC
    28cc:	50 91 cd 05 	lds	r21, 0x05CD
    28d0:	60 91 ce 05 	lds	r22, 0x05CE
    28d4:	70 91 cf 05 	lds	r23, 0x05CF
    28d8:	20 91 be 05 	lds	r18, 0x05BE
    28dc:	84 e7       	ldi	r24, 0x74	; 116
    28de:	96 e0       	ldi	r25, 0x06	; 6
    28e0:	0e 94 3a 09 	call	0x1274	; 0x1274 <mc_probe_cycle>
      }
    
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc.position[] = target[];
    28e4:	8c e0       	ldi	r24, 0x0C	; 12
    28e6:	e4 e7       	ldi	r30, 0x74	; 116
    28e8:	f6 e0       	ldi	r31, 0x06	; 6
    28ea:	a1 e2       	ldi	r26, 0x21	; 33
    28ec:	b6 e0       	ldi	r27, 0x06	; 6
    28ee:	01 90       	ld	r0, Z+
    28f0:	0d 92       	st	X+, r0
    28f2:	8a 95       	dec	r24
    28f4:	e1 f7       	brne	.-8      	; 0x28ee <gc_execute_line+0x1434>
  }
  
  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may 
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    28f6:	80 91 4c 06 	lds	r24, 0x064C
    28fa:	80 93 c3 05 	sts	0x05C3, r24
  if (gc_state.modal.program_flow) { 
    28fe:	88 23       	and	r24, r24
    2900:	09 f4       	brne	.+2      	; 0x2904 <gc_execute_line+0x144a>
    2902:	6c c0       	rjmp	.+216    	; 0x29dc <gc_execute_line+0x1522>
    protocol_buffer_synchronize(); // Finish all remaining buffered motions. Program paused when complete.
    2904:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>
    sys.auto_start = false; // Disable auto cycle start. Forces pause until cycle start issued.
    2908:	10 92 93 05 	sts	0x0593, r1
  
    // If complete, reset to reload defaults (G92.2,G54,G17,G90,G94,M48,G40,M5,M9). Otherwise,
    // re-enable program flow after pause complete, where cycle start will resume the program.
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    290c:	80 91 c3 05 	lds	r24, 0x05C3
    2910:	82 30       	cpi	r24, 0x02	; 2
    2912:	21 f4       	brne	.+8      	; 0x291c <gc_execute_line+0x1462>
    2914:	0e 94 d6 09 	call	0x13ac	; 0x13ac <mc_reset>
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; }
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2918:	80 e0       	ldi	r24, 0x00	; 0
    291a:	7a c0       	rjmp	.+244    	; 0x2a10 <gc_execute_line+0x1556>
    sys.auto_start = false; // Disable auto cycle start. Forces pause until cycle start issued.
  
    // If complete, reset to reload defaults (G92.2,G54,G17,G90,G94,M48,G40,M5,M9). Otherwise,
    // re-enable program flow after pause complete, where cycle start will resume the program.
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; }
    291c:	10 92 c3 05 	sts	0x05C3, r1
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    2920:	80 e0       	ldi	r24, 0x00	; 0
    2922:	76 c0       	rjmp	.+236    	; 0x2a10 <gc_execute_line+0x1556>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	74 c0       	rjmp	.+232    	; 0x2a10 <gc_execute_line+0x1556>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2928:	82 e0       	ldi	r24, 0x02	; 2
    292a:	72 c0       	rjmp	.+228    	; 0x2a10 <gc_execute_line+0x1556>
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    292c:	84 e1       	ldi	r24, 0x14	; 20
    292e:	70 c0       	rjmp	.+224    	; 0x2a10 <gc_execute_line+0x1556>
        switch(int_value) {
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2930:	88 e1       	ldi	r24, 0x18	; 24
    2932:	6e c0       	rjmp	.+220    	; 0x2a10 <gc_execute_line+0x1556>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
    2934:	84 e1       	ldi	r24, 0x14	; 20
    2936:	6c c0       	rjmp	.+216    	; 0x2a10 <gc_execute_line+0x1556>
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
    2938:	84 e1       	ldi	r24, 0x14	; 20
    293a:	6a c0       	rjmp	.+212    	; 0x2a10 <gc_execute_line+0x1556>
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G92.x command]
    293c:	84 e1       	ldi	r24, 0x14	; 20
    293e:	68 c0       	rjmp	.+208    	; 0x2a10 <gc_execute_line+0x1556>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    2940:	88 e1       	ldi	r24, 0x18	; 24
    2942:	66 c0       	rjmp	.+204    	; 0x2a10 <gc_execute_line+0x1556>
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE; break;  // G38.2
                  // NOTE: If G38.3+ are enabled, change mantissa variable type to uint16_t.
                  // case 30: gc_block.modal.motion = MOTION_MODE_PROBE_NO_ERROR; break; // G38.3 Not supported.
                  // case 40: // Not supported.
                  // case 50: // Not supported.
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    2944:	84 e1       	ldi	r24, 0x14	; 20
    2946:	64 c0       	rjmp	.+200    	; 0x2a10 <gc_execute_line+0x1556>
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            switch (int_value) {
				case 49: gc_block.modal.tool_comp = 0; break;
				case 43: gc_block.modal.tool_comp = gc_block.values.h; break;
				default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2948:	84 e1       	ldi	r24, 0x14	; 20
    294a:	62 c0       	rjmp	.+196    	; 0x2a10 <gc_execute_line+0x1556>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    294c:	87 e1       	ldi	r24, 0x17	; 23
    294e:	60 c0       	rjmp	.+192    	; 0x2a10 <gc_execute_line+0x1556>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2950:	85 e1       	ldi	r24, 0x15	; 21
    2952:	5e c0       	rjmp	.+188    	; 0x2a10 <gc_execute_line+0x1556>
        break;
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    2954:	87 e1       	ldi	r24, 0x17	; 23
    2956:	5c c0       	rjmp	.+184    	; 0x2a10 <gc_execute_line+0x1556>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    2958:	84 e1       	ldi	r24, 0x14	; 20
    295a:	5a c0       	rjmp	.+180    	; 0x2a10 <gc_execute_line+0x1556>
        }            
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    295c:	85 e1       	ldi	r24, 0x15	; 21
    295e:	58 c0       	rjmp	.+176    	; 0x2a10 <gc_execute_line+0x1556>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; gc_block.values.t = int_value; break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2960:	84 e1       	ldi	r24, 0x14	; 20
    2962:	56 c0       	rjmp	.+172    	; 0x2a10 <gc_execute_line+0x1556>
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    2964:	89 e1       	ldi	r24, 0x19	; 25
    2966:	54 c0       	rjmp	.+168    	; 0x2a10 <gc_execute_line+0x1556>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    2968:	84 e0       	ldi	r24, 0x04	; 4
    296a:	52 c0       	rjmp	.+164    	; 0x2a10 <gc_execute_line+0x1556>
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    296c:	8b e1       	ldi	r24, 0x1B	; 27
    296e:	50 c0       	rjmp	.+160    	; 0x2a10 <gc_execute_line+0x1556>
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    2970:	86 e1       	ldi	r24, 0x16	; 22
    2972:	4e c0       	rjmp	.+156    	; 0x2a10 <gc_execute_line+0x1556>
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
  // bit_false(value_words,bit(WORD_S)); // NOTE: Single-meaning value word. Set at end of error-checking.
    
  // [5. Select tool ]:  T is negative (done.) Not an integer. Greater than max tool value.
  if (bit_istrue(value_words,bit(WORD_T))) {
	  if (gc_block.values.t >= N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); }
    2974:	87 e2       	ldi	r24, 0x27	; 39
    2976:	4c c0       	rjmp	.+152    	; 0x2a10 <gc_execute_line+0x1556>
  }
  // bit_false(value_words,bit(WORD_T)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [5a. Select tool offset]:
  if (bit_istrue(value_words,bit(WORD_H))) {
	  if (gc_block.values.h > N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); }
    2978:	87 e2       	ldi	r24, 0x27	; 39
    297a:	4a c0       	rjmp	.+148    	; 0x2a10 <gc_execute_line+0x1556>
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    297c:	8c e1       	ldi	r24, 0x1C	; 28
    297e:	48 c0       	rjmp	.+144    	; 0x2a10 <gc_execute_line+0x1556>
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    2980:	8d e1       	ldi	r24, 0x1D	; 29
    2982:	46 c0       	rjmp	.+140    	; 0x2a10 <gc_execute_line+0x1556>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2984:	87 e0       	ldi	r24, 0x07	; 7
    2986:	44 c0       	rjmp	.+136    	; 0x2a10 <gc_execute_line+0x1556>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words && bit_isfalse(value_words,(1<<WORD_R)) ) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    2988:	8a e1       	ldi	r24, 0x1A	; 26
    298a:	42 c0       	rjmp	.+132    	; 0x2a10 <gc_execute_line+0x1556>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    298c:	8c e1       	ldi	r24, 0x1C	; 28
    298e:	40 c0       	rjmp	.+128    	; 0x2a10 <gc_execute_line+0x1556>
      	        }
      	      }
    	  break;

      	  default:
      		FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    2990:	84 e1       	ldi	r24, 0x14	; 20
    2992:	3e c0       	rjmp	.+124    	; 0x2a10 <gc_execute_line+0x1556>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      int_value = trunc(gc_block.values.p); // Convert p value to int.

      switch( gc_block.values.l) {
      	  case 1:
      	      if (int_value > N_TOOL_TABLE) { FAIL(STATUS_GCODE_UNSUPPORTED_TOOL); } // [Greater than N sys]
    2994:	87 e2       	ldi	r24, 0x27	; 39
    2996:	3c c0       	rjmp	.+120    	; 0x2a10 <gc_execute_line+0x1556>
				  }
      	      }
    	  break;

      	  case 2:
  	          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    2998:	84 e1       	ldi	r24, 0x14	; 20
    299a:	3a c0       	rjmp	.+116    	; 0x2a10 <gc_execute_line+0x1556>
      	  case 20:
      	      if (int_value > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    299c:	8d e1       	ldi	r24, 0x1D	; 29
    299e:	38 c0       	rjmp	.+112    	; 0x2a10 <gc_execute_line+0x1556>
      	      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));

      	      // Load EEPROM coordinate data and pre-calculate the new coordinate data.
      	      if (int_value > 0) { int_value--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      		  else { int_value = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      	      if (!settings_read_coord_data(int_value,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    29a0:	87 e0       	ldi	r24, 0x07	; 7
    29a2:	36 c0       	rjmp	.+108    	; 0x2a10 <gc_execute_line+0x1556>
      		FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    29a4:	8a e1       	ldi	r24, 0x1A	; 26
    29a6:	34 c0       	rjmp	.+104    	; 0x2a10 <gc_execute_line+0x1556>
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    29a8:	87 e0       	ldi	r24, 0x07	; 7
    29aa:	32 c0       	rjmp	.+100    	; 0x2a10 <gc_execute_line+0x1556>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    29ac:	87 e0       	ldi	r24, 0x07	; 7
    29ae:	30 c0       	rjmp	.+96     	; 0x2a10 <gc_execute_line+0x1556>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    29b0:	8e e1       	ldi	r24, 0x1E	; 30
    29b2:	2e c0       	rjmp	.+92     	; 0x2a10 <gc_execute_line+0x1556>
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    29b4:	8f e1       	ldi	r24, 0x1F	; 31
    29b6:	2c c0       	rjmp	.+88     	; 0x2a10 <gc_execute_line+0x1556>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    29b8:	86 e1       	ldi	r24, 0x16	; 22
    29ba:	2a c0       	rjmp	.+84     	; 0x2a10 <gc_execute_line+0x1556>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    29bc:	8a e1       	ldi	r24, 0x1A	; 26
    29be:	28 c0       	rjmp	.+80     	; 0x2a10 <gc_execute_line+0x1556>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    29c0:	80 e2       	ldi	r24, 0x20	; 32
    29c2:	26 c0       	rjmp	.+76     	; 0x2a10 <gc_execute_line+0x1556>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    29c4:	82 e2       	ldi	r24, 0x22	; 34
    29c6:	24 c0       	rjmp	.+72     	; 0x2a10 <gc_execute_line+0x1556>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    29c8:	83 e2       	ldi	r24, 0x23	; 35
    29ca:	22 c0       	rjmp	.+68     	; 0x2a10 <gc_execute_line+0x1556>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) { 
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    29cc:	81 e2       	ldi	r24, 0x21	; 33
    29ce:	20 c0       	rjmp	.+64     	; 0x2a10 <gc_execute_line+0x1556>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    29d0:	81 e2       	ldi	r24, 0x21	; 33
    29d2:	1e c0       	rjmp	.+60     	; 0x2a10 <gc_execute_line+0x1556>
          }
          break;
        case MOTION_MODE_PROBE:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    29d4:	8a e1       	ldi	r24, 0x1A	; 26
    29d6:	1c c0       	rjmp	.+56     	; 0x2a10 <gc_execute_line+0x1556>

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    29d8:	85 e2       	ldi	r24, 0x25	; 37
    29da:	1a c0       	rjmp	.+52     	; 0x2a10 <gc_execute_line+0x1556>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_COMPLETED) { mc_reset(); }
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; }
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
    29dc:	80 e0       	ldi	r24, 0x00	; 0
    29de:	18 c0       	rjmp	.+48     	; 0x2a10 <gc_execute_line+0x1556>
        case MOTION_MODE_PROBE:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
          if (probe_get_state()) { FAIL(STATUS_GCODE_PROBE_TRIGGERED); } // [Probe triggered]
    29e0:	84 e2       	ldi	r24, 0x24	; 36
    29e2:	16 c0       	rjmp	.+44     	; 0x2a10 <gc_execute_line+0x1556>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    29e4:	10 91 46 06 	lds	r17, 0x0646
    29e8:	15 30       	cpi	r17, 0x05	; 5
    29ea:	09 f0       	breq	.+2      	; 0x29ee <gc_execute_line+0x1534>
    29ec:	2e cb       	rjmp	.-2468   	; 0x204a <gc_execute_line+0xb90>
    29ee:	28 cb       	rjmp	.-2480   	; 0x2040 <gc_execute_line+0xb86>
          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    29f0:	80 91 48 06 	lds	r24, 0x0648
    29f4:	81 30       	cpi	r24, 0x01	; 1
    29f6:	09 f0       	breq	.+2      	; 0x29fa <gc_execute_line+0x1540>
    29f8:	04 cc       	rjmp	.-2040   	; 0x2202 <gc_execute_line+0xd48>
    29fa:	f1 cb       	rjmp	.-2078   	; 0x21de <gc_execute_line+0xd24>
        case MOTION_MODE_PROBE:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
          if (probe_get_state()) { FAIL(STATUS_GCODE_PROBE_TRIGGERED); } // [Probe triggered]
    29fc:	0e 94 8e 2f 	call	0x5f1c	; 0x5f1c <probe_get_state>
    2a00:	81 11       	cpse	r24, r1
    2a02:	ee cf       	rjmp	.-36     	; 0x29e0 <gc_execute_line+0x1526>
    2a04:	b3 cd       	rjmp	.-1178   	; 0x256c <gc_execute_line+0x10b2>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    2a06:	c1 01       	movw	r24, r2
    2a08:	8e 7b       	andi	r24, 0xBE	; 190
    2a0a:	99 7f       	andi	r25, 0xF9	; 249
    2a0c:	1b a2       	std	Y+35, r1	; 0x23
    2a0e:	b1 cd       	rjmp	.-1182   	; 0x2572 <gc_execute_line+0x10b8>
    else { gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; }
  }
    
  // TODO: % to denote start of program. Sets auto cycle start?
  return(STATUS_OK);
}
    2a10:	aa 96       	adiw	r28, 0x2a	; 42
    2a12:	0f b6       	in	r0, 0x3f	; 63
    2a14:	f8 94       	cli
    2a16:	de bf       	out	0x3e, r29	; 62
    2a18:	0f be       	out	0x3f, r0	; 63
    2a1a:	cd bf       	out	0x3d, r28	; 61
    2a1c:	df 91       	pop	r29
    2a1e:	cf 91       	pop	r28
    2a20:	1f 91       	pop	r17
    2a22:	0f 91       	pop	r16
    2a24:	ff 90       	pop	r15
    2a26:	ef 90       	pop	r14
    2a28:	df 90       	pop	r13
    2a2a:	cf 90       	pop	r12
    2a2c:	bf 90       	pop	r11
    2a2e:	af 90       	pop	r10
    2a30:	9f 90       	pop	r9
    2a32:	8f 90       	pop	r8
    2a34:	7f 90       	pop	r7
    2a36:	6f 90       	pop	r6
    2a38:	5f 90       	pop	r5
    2a3a:	4f 90       	pop	r4
    2a3c:	3f 90       	pop	r3
    2a3e:	2f 90       	pop	r2
    2a40:	08 95       	ret

00002a42 <spindle_stop>:
	#endif
	#else
	SPINDLE_ENABLE_PORT &= ~(1<<SPINDLE_ENABLE_BIT); // Set pin to low.
	#endif
#elif ( SPINDLE_CTRL == CTRL_I2C)
    TWI_buffer_out[0] = 0;
    2a42:	10 92 b3 05 	sts	0x05B3, r1
    TWI_master_start_write( 0x5c, 1);
    2a46:	61 e0       	ldi	r22, 0x01	; 1
    2a48:	70 e0       	ldi	r23, 0x00	; 0
    2a4a:	8c e5       	ldi	r24, 0x5C	; 92
    2a4c:	0e 94 9f 37 	call	0x6f3e	; 0x6f3e <TWI_master_start_write>
    2a50:	08 95       	ret

00002a52 <spindle_init>:
	#else
	SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
	#endif
	SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.  spindle_stop();
#endif
    spindle_stop();
    2a52:	0e 94 21 15 	call	0x2a42	; 0x2a42 <spindle_stop>
    2a56:	08 95       	ret

00002a58 <spindle_run>:
#endif
}


void spindle_run(uint8_t direction, float rpm) 
{
    2a58:	cf 92       	push	r12
    2a5a:	df 92       	push	r13
    2a5c:	ef 92       	push	r14
    2a5e:	ff 92       	push	r15
    2a60:	38 2f       	mov	r19, r24
    2a62:	cb 01       	movw	r24, r22
    2a64:	ba 01       	movw	r22, r20
  if (sys.state == STATE_CHECK_MODE) { return; }
    2a66:	20 91 84 05 	lds	r18, 0x0584
    2a6a:	22 30       	cpi	r18, 0x02	; 2
    2a6c:	21 f1       	breq	.+72     	; 0x2ab6 <spindle_run+0x5e>
  
  // Halt or set spindle direction and rpm. 
  if (direction == SPINDLE_DISABLE) {
    2a6e:	31 11       	cpse	r19, r1
    2a70:	03 c0       	rjmp	.+6      	; 0x2a78 <spindle_run+0x20>
    spindle_stop();
    2a72:	0e 94 21 15 	call	0x2a42	; 0x2a42 <spindle_stop>
    2a76:	1f c0       	rjmp	.+62     	; 0x2ab6 <spindle_run+0x5e>
	  #endif
	#else
	  SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
	#endif
#elif ( SPINDLE_CTRL == CTRL_I2C)
	uint8_t rpm_val = min( SPINDLE_RPM_STEPS, floor( rpm / SPINDLE_RPM_SCALE));
    2a78:	20 e0       	ldi	r18, 0x00	; 0
    2a7a:	30 e0       	ldi	r19, 0x00	; 0
    2a7c:	48 e8       	ldi	r20, 0x88	; 136
    2a7e:	52 e4       	ldi	r21, 0x42	; 66
    2a80:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    2a84:	0e 94 39 3a 	call	0x7472	; 0x7472 <floor>
    2a88:	6b 01       	movw	r12, r22
    2a8a:	7c 01       	movw	r14, r24
    2a8c:	20 e0       	ldi	r18, 0x00	; 0
    2a8e:	30 e0       	ldi	r19, 0x00	; 0
    2a90:	4a ef       	ldi	r20, 0xFA	; 250
    2a92:	52 e4       	ldi	r21, 0x42	; 66
    2a94:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    2a98:	18 16       	cp	r1, r24
    2a9a:	2c f0       	brlt	.+10     	; 0x2aa6 <spindle_run+0x4e>
    2a9c:	c7 01       	movw	r24, r14
    2a9e:	b6 01       	movw	r22, r12
    2aa0:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    2aa4:	01 c0       	rjmp	.+2      	; 0x2aa8 <spindle_run+0x50>
    2aa6:	6d e7       	ldi	r22, 0x7D	; 125
//	if ( rpm > SPINDLE_RPM_MAX) rpm_val = SPINDLE_RPM_STEPS;
//	else rpm_val = floor( rpm / SPINDLE_RPM_SCALE);

	TWI_buffer_out[0] = rpm_val;
    2aa8:	60 93 b3 05 	sts	0x05B3, r22
	TWI_master_start_write( 0x5c, 1);
    2aac:	61 e0       	ldi	r22, 0x01	; 1
    2aae:	70 e0       	ldi	r23, 0x00	; 0
    2ab0:	8c e5       	ldi	r24, 0x5C	; 92
    2ab2:	0e 94 9f 37 	call	0x6f3e	; 0x6f3e <TWI_master_start_write>
#endif
  }
}
    2ab6:	ff 90       	pop	r15
    2ab8:	ef 90       	pop	r14
    2aba:	df 90       	pop	r13
    2abc:	cf 90       	pop	r12
    2abe:	08 95       	ret

00002ac0 <coolant_init>:
	#ifdef ENABLE_M7
	COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
	#endif
#elif ( COOLANT_CTRL == CTRL_I2C)

	TWI_buffer_out[0] = COOLANT_DISABLE;
    2ac0:	10 92 b3 05 	sts	0x05B3, r1
    2ac4:	08 95       	ret

00002ac6 <coolant_stop>:
    2ac6:	10 92 b3 05 	sts	0x05B3, r1
    2aca:	08 95       	ret

00002acc <coolant_run>:
}


void coolant_run(uint8_t mode)
{
  if (sys.state == STATE_CHECK_MODE) { return; }
    2acc:	90 91 84 05 	lds	r25, 0x0584
    2ad0:	92 30       	cpi	r25, 0x02	; 2
    2ad2:	11 f0       	breq	.+4      	; 0x2ad8 <coolant_run+0xc>
	coolant_stop();
	}
#elif ( COOLANT_CTRL == CTRL_I2C)
	// COOLANT_FLOOD_ENABLE = 1
	// COOLANT_MIST_ENABLE = 2
	TWI_buffer_out[0] = mode;
    2ad4:	80 93 b3 05 	sts	0x05B3, r24
    2ad8:	08 95       	ret

00002ada <serial_get_rx_buffer_count>:
  

// Returns the number of bytes used in the RX serial buffer.
uint8_t serial_get_rx_buffer_count()
{
  uint8_t rtail = serial_rx_buffer_tail; // Copy to limit multiple calls to volatile
    2ada:	90 91 08 01 	lds	r25, 0x0108
  if (serial_rx_buffer_head >= rtail) { return(serial_rx_buffer_head-rtail); }
    2ade:	80 91 09 01 	lds	r24, 0x0109
    2ae2:	89 17       	cp	r24, r25
    2ae4:	10 f0       	brcs	.+4      	; 0x2aea <serial_get_rx_buffer_count+0x10>
    2ae6:	89 1b       	sub	r24, r25
    2ae8:	08 95       	ret
  return (RX_BUFFER_SIZE - (rtail-serial_rx_buffer_head));
    2aea:	80 58       	subi	r24, 0x80	; 128
    2aec:	89 1b       	sub	r24, r25
}
    2aee:	08 95       	ret

00002af0 <serial_init>:
  #if BAUD_RATE < 57600
    uint16_t UBRR0_value = ((F_CPU / (8L * BAUD_RATE)) - 1)/2 ;
    UCSR0A &= ~(1 << U2X0); // baud doubler off  - Only needed on Uno XXX
  #else
    uint16_t UBRR0_value = ((F_CPU / (4L * BAUD_RATE)) - 1)/2;
    UCSR0A |= (1 << U2X0);  // baud doubler on for high baud rates, i.e. 115200
    2af0:	e0 ec       	ldi	r30, 0xC0	; 192
    2af2:	f0 e0       	ldi	r31, 0x00	; 0
    2af4:	80 81       	ld	r24, Z
    2af6:	82 60       	ori	r24, 0x02	; 2
    2af8:	80 83       	st	Z, r24
  #endif
  UBRR0H = UBRR0_value >> 8;
    2afa:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = UBRR0_value;
    2afe:	80 e1       	ldi	r24, 0x10	; 16
    2b00:	80 93 c4 00 	sts	0x00C4, r24
            
  // enable rx and tx
  UCSR0B |= 1<<RXEN0;
    2b04:	e1 ec       	ldi	r30, 0xC1	; 193
    2b06:	f0 e0       	ldi	r31, 0x00	; 0
    2b08:	80 81       	ld	r24, Z
    2b0a:	80 61       	ori	r24, 0x10	; 16
    2b0c:	80 83       	st	Z, r24
  UCSR0B |= 1<<TXEN0;
    2b0e:	80 81       	ld	r24, Z
    2b10:	88 60       	ori	r24, 0x08	; 8
    2b12:	80 83       	st	Z, r24
	
  // enable interrupt on complete reception of a byte
  UCSR0B |= 1<<RXCIE0;
    2b14:	80 81       	ld	r24, Z
    2b16:	80 68       	ori	r24, 0x80	; 128
    2b18:	80 83       	st	Z, r24
    2b1a:	08 95       	ret

00002b1c <serial_write>:

// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    2b1c:	30 91 07 01 	lds	r19, 0x0107
    2b20:	21 e0       	ldi	r18, 0x01	; 1
    2b22:	23 0f       	add	r18, r19
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    2b24:	20 34       	cpi	r18, 0x40	; 64
    2b26:	31 f4       	brne	.+12     	; 0x2b34 <serial_write+0x18>
    2b28:	04 c0       	rjmp	.+8      	; 0x2b32 <serial_write+0x16>

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    if (sys.execute & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    2b2a:	90 81       	ld	r25, Z
    2b2c:	94 ff       	sbrs	r25, 4
    2b2e:	04 c0       	rjmp	.+8      	; 0x2b38 <serial_write+0x1c>
    2b30:	08 95       	ret
// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    2b32:	20 e0       	ldi	r18, 0x00	; 0

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    if (sys.execute & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    2b34:	e5 e8       	ldi	r30, 0x85	; 133
    2b36:	f5 e0       	ldi	r31, 0x05	; 5
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    2b38:	90 91 06 01 	lds	r25, 0x0106
    2b3c:	92 17       	cp	r25, r18
    2b3e:	a9 f3       	breq	.-22     	; 0x2b2a <serial_write+0xe>
    if (sys.execute & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    2b40:	e3 2f       	mov	r30, r19
    2b42:	f0 e0       	ldi	r31, 0x00	; 0
    2b44:	e0 58       	subi	r30, 0x80	; 128
    2b46:	f9 4f       	sbci	r31, 0xF9	; 249
    2b48:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    2b4a:	20 93 07 01 	sts	0x0107, r18
  
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  UCSR0B |=  (1 << UDRIE0); 
    2b4e:	e1 ec       	ldi	r30, 0xC1	; 193
    2b50:	f0 e0       	ldi	r31, 0x00	; 0
    2b52:	80 81       	ld	r24, Z
    2b54:	80 62       	ori	r24, 0x20	; 32
    2b56:	80 83       	st	Z, r24
    2b58:	08 95       	ret

00002b5a <__vector_19>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    2b5a:	1f 92       	push	r1
    2b5c:	0f 92       	push	r0
    2b5e:	0f b6       	in	r0, 0x3f	; 63
    2b60:	0f 92       	push	r0
    2b62:	11 24       	eor	r1, r1
    2b64:	8f 93       	push	r24
    2b66:	9f 93       	push	r25
    2b68:	ef 93       	push	r30
    2b6a:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    2b6c:	80 91 06 01 	lds	r24, 0x0106
      flow_ctrl = XON_SENT; 
    } else
  #endif
  { 
    // Send a byte from the buffer	
    UDR0 = serial_tx_buffer[tail];
    2b70:	e8 2f       	mov	r30, r24
    2b72:	f0 e0       	ldi	r31, 0x00	; 0
    2b74:	e0 58       	subi	r30, 0x80	; 128
    2b76:	f9 4f       	sbci	r31, 0xF9	; 249
    2b78:	90 81       	ld	r25, Z
    2b7a:	90 93 c6 00 	sts	0x00C6, r25
  
    // Update tail position
    tail++;
    2b7e:	8f 5f       	subi	r24, 0xFF	; 255
    if (tail == TX_BUFFER_SIZE) { tail = 0; }
    2b80:	80 34       	cpi	r24, 0x40	; 64
    2b82:	09 f4       	brne	.+2      	; 0x2b86 <__vector_19+0x2c>
    2b84:	80 e0       	ldi	r24, 0x00	; 0
  
    serial_tx_buffer_tail = tail;
    2b86:	80 93 06 01 	sts	0x0106, r24
  }
  
  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { UCSR0B &= ~(1 << UDRIE0); }
    2b8a:	90 91 07 01 	lds	r25, 0x0107
    2b8e:	89 13       	cpse	r24, r25
    2b90:	05 c0       	rjmp	.+10     	; 0x2b9c <__vector_19+0x42>
    2b92:	e1 ec       	ldi	r30, 0xC1	; 193
    2b94:	f0 e0       	ldi	r31, 0x00	; 0
    2b96:	80 81       	ld	r24, Z
    2b98:	8f 7d       	andi	r24, 0xDF	; 223
    2b9a:	80 83       	st	Z, r24
}
    2b9c:	ff 91       	pop	r31
    2b9e:	ef 91       	pop	r30
    2ba0:	9f 91       	pop	r25
    2ba2:	8f 91       	pop	r24
    2ba4:	0f 90       	pop	r0
    2ba6:	0f be       	out	0x3f, r0	; 63
    2ba8:	0f 90       	pop	r0
    2baa:	1f 90       	pop	r1
    2bac:	18 95       	reti

00002bae <serial_read>:


// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    2bae:	90 91 08 01 	lds	r25, 0x0108
  if (serial_rx_buffer_head == tail) {
    2bb2:	80 91 09 01 	lds	r24, 0x0109
    2bb6:	89 17       	cp	r24, r25
    2bb8:	61 f0       	breq	.+24     	; 0x2bd2 <serial_read+0x24>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    2bba:	e9 2f       	mov	r30, r25
    2bbc:	f0 e0       	ldi	r31, 0x00	; 0
    2bbe:	e0 54       	subi	r30, 0x40	; 64
    2bc0:	f9 4f       	sbci	r31, 0xF9	; 249
    2bc2:	80 81       	ld	r24, Z
    
    tail++;
    2bc4:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_BUFFER_SIZE) { tail = 0; }
    2bc6:	90 38       	cpi	r25, 0x80	; 128
    2bc8:	09 f4       	brne	.+2      	; 0x2bcc <serial_read+0x1e>
    2bca:	90 e0       	ldi	r25, 0x00	; 0
    serial_rx_buffer_tail = tail;
    2bcc:	90 93 08 01 	sts	0x0108, r25
        flow_ctrl = SEND_XON;
        UCSR0B |=  (1 << UDRIE0); // Force TX
      }
    #endif
    
    return data;
    2bd0:	08 95       	ret
// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    2bd2:	8f ef       	ldi	r24, 0xFF	; 255
      }
    #endif
    
    return data;
  }
}
    2bd4:	08 95       	ret

00002bd6 <__vector_18>:


ISR(SERIAL_RX)
{
    2bd6:	1f 92       	push	r1
    2bd8:	0f 92       	push	r0
    2bda:	0f b6       	in	r0, 0x3f	; 63
    2bdc:	0f 92       	push	r0
    2bde:	11 24       	eor	r1, r1
    2be0:	2f 93       	push	r18
    2be2:	3f 93       	push	r19
    2be4:	4f 93       	push	r20
    2be6:	5f 93       	push	r21
    2be8:	6f 93       	push	r22
    2bea:	7f 93       	push	r23
    2bec:	8f 93       	push	r24
    2bee:	9f 93       	push	r25
    2bf0:	af 93       	push	r26
    2bf2:	bf 93       	push	r27
    2bf4:	ef 93       	push	r30
    2bf6:	ff 93       	push	r31
  uint8_t data = UDR0;
    2bf8:	80 91 c6 00 	lds	r24, 0x00C6
  uint8_t next_head;
  
  // Pick off runtime command characters directly from the serial stream. These characters are
  // not passed into the buffer, but these set system state flag bits for runtime execution.
  switch (data) {
    2bfc:	81 32       	cpi	r24, 0x21	; 33
    2bfe:	d9 f0       	breq	.+54     	; 0x2c36 <__vector_18+0x60>
    2c00:	18 f4       	brcc	.+6      	; 0x2c08 <__vector_18+0x32>
    2c02:	88 31       	cpi	r24, 0x18	; 24
    2c04:	09 f1       	breq	.+66     	; 0x2c48 <__vector_18+0x72>
    2c06:	23 c0       	rjmp	.+70     	; 0x2c4e <__vector_18+0x78>
    2c08:	8f 33       	cpi	r24, 0x3F	; 63
    2c0a:	19 f0       	breq	.+6      	; 0x2c12 <__vector_18+0x3c>
    2c0c:	8e 37       	cpi	r24, 0x7E	; 126
    2c0e:	51 f0       	breq	.+20     	; 0x2c24 <__vector_18+0x4e>
    2c10:	1e c0       	rjmp	.+60     	; 0x2c4e <__vector_18+0x78>
    case CMD_STATUS_REPORT: bit_true_atomic(sys.execute, EXEC_STATUS_REPORT); break; // Set as true
    2c12:	8f b7       	in	r24, 0x3f	; 63
    2c14:	f8 94       	cli
    2c16:	e5 e8       	ldi	r30, 0x85	; 133
    2c18:	f5 e0       	ldi	r31, 0x05	; 5
    2c1a:	90 81       	ld	r25, Z
    2c1c:	91 60       	ori	r25, 0x01	; 1
    2c1e:	90 83       	st	Z, r25
    2c20:	8f bf       	out	0x3f, r24	; 63
    2c22:	26 c0       	rjmp	.+76     	; 0x2c70 <__vector_18+0x9a>
    case CMD_CYCLE_START:   bit_true_atomic(sys.execute, EXEC_CYCLE_START); break; // Set as true
    2c24:	8f b7       	in	r24, 0x3f	; 63
    2c26:	f8 94       	cli
    2c28:	e5 e8       	ldi	r30, 0x85	; 133
    2c2a:	f5 e0       	ldi	r31, 0x05	; 5
    2c2c:	90 81       	ld	r25, Z
    2c2e:	92 60       	ori	r25, 0x02	; 2
    2c30:	90 83       	st	Z, r25
    2c32:	8f bf       	out	0x3f, r24	; 63
    2c34:	1d c0       	rjmp	.+58     	; 0x2c70 <__vector_18+0x9a>
    case CMD_FEED_HOLD:     bit_true_atomic(sys.execute, EXEC_FEED_HOLD); break; // Set as true
    2c36:	8f b7       	in	r24, 0x3f	; 63
    2c38:	f8 94       	cli
    2c3a:	e5 e8       	ldi	r30, 0x85	; 133
    2c3c:	f5 e0       	ldi	r31, 0x05	; 5
    2c3e:	90 81       	ld	r25, Z
    2c40:	98 60       	ori	r25, 0x08	; 8
    2c42:	90 83       	st	Z, r25
    2c44:	8f bf       	out	0x3f, r24	; 63
    2c46:	14 c0       	rjmp	.+40     	; 0x2c70 <__vector_18+0x9a>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    2c48:	0e 94 d6 09 	call	0x13ac	; 0x13ac <mc_reset>
    2c4c:	11 c0       	rjmp	.+34     	; 0x2c70 <__vector_18+0x9a>
    default: // Write character to buffer    
      next_head = serial_rx_buffer_head + 1;
    2c4e:	e0 91 09 01 	lds	r30, 0x0109
    2c52:	91 e0       	ldi	r25, 0x01	; 1
    2c54:	9e 0f       	add	r25, r30
      if (next_head == RX_BUFFER_SIZE) { next_head = 0; }
    2c56:	90 38       	cpi	r25, 0x80	; 128
    2c58:	09 f4       	brne	.+2      	; 0x2c5c <__vector_18+0x86>
    2c5a:	90 e0       	ldi	r25, 0x00	; 0
    
      // Write data to buffer unless it is full.
      if (next_head != serial_rx_buffer_tail) {
    2c5c:	20 91 08 01 	lds	r18, 0x0108
    2c60:	92 17       	cp	r25, r18
    2c62:	31 f0       	breq	.+12     	; 0x2c70 <__vector_18+0x9a>
        serial_rx_buffer[serial_rx_buffer_head] = data;
    2c64:	f0 e0       	ldi	r31, 0x00	; 0
    2c66:	e0 54       	subi	r30, 0x40	; 64
    2c68:	f9 4f       	sbci	r31, 0xF9	; 249
    2c6a:	80 83       	st	Z, r24
        serial_rx_buffer_head = next_head;    
    2c6c:	90 93 09 01 	sts	0x0109, r25
        #endif
        
      }
      //TODO: else alarm on overflow?
  }
}
    2c70:	ff 91       	pop	r31
    2c72:	ef 91       	pop	r30
    2c74:	bf 91       	pop	r27
    2c76:	af 91       	pop	r26
    2c78:	9f 91       	pop	r25
    2c7a:	8f 91       	pop	r24
    2c7c:	7f 91       	pop	r23
    2c7e:	6f 91       	pop	r22
    2c80:	5f 91       	pop	r21
    2c82:	4f 91       	pop	r20
    2c84:	3f 91       	pop	r19
    2c86:	2f 91       	pop	r18
    2c88:	0f 90       	pop	r0
    2c8a:	0f be       	out	0x3f, r0	; 63
    2c8c:	0f 90       	pop	r0
    2c8e:	1f 90       	pop	r1
    2c90:	18 95       	reti

00002c92 <serial_reset_read_buffer>:


void serial_reset_read_buffer() 
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    2c92:	80 91 09 01 	lds	r24, 0x0109
    2c96:	80 93 08 01 	sts	0x0108, r24
    2c9a:	08 95       	ret

00002c9c <protocol_execute_runtime>:
// execute certain tasks without having two or more instances of the same task, such as the planner
// recalculating the buffer upon a feedhold or override.
// NOTE: The sys.execute variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_runtime()
{
    2c9c:	cf 93       	push	r28
  uint8_t rt_exec = sys.execute; // Copy to avoid calling volatile multiple times
    2c9e:	c0 91 85 05 	lds	r28, 0x0585
  if (rt_exec) { // Enter only if any bit flag is true
    2ca2:	cc 23       	and	r28, r28
    2ca4:	09 f4       	brne	.+2      	; 0x2ca8 <protocol_execute_runtime+0xc>
    2ca6:	87 c0       	rjmp	.+270    	; 0x2db6 <protocol_execute_runtime+0x11a>
    
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    if (rt_exec & (EXEC_ALARM | EXEC_CRIT_EVENT)) {      
    2ca8:	8c 2f       	mov	r24, r28
    2caa:	80 76       	andi	r24, 0x60	; 96
    2cac:	41 f1       	breq	.+80     	; 0x2cfe <protocol_execute_runtime+0x62>
      sys.state = STATE_ALARM; // Set system alarm state
    2cae:	81 e0       	ldi	r24, 0x01	; 1
    2cb0:	80 93 84 05 	sts	0x0584, r24

      // Critical events. Hard/soft limit events identified by both critical event and alarm exec
      // flags. Probe fail is identified by the critical event exec flag only.
      if (rt_exec & EXEC_CRIT_EVENT) {
    2cb4:	c6 ff       	sbrs	r28, 6
    2cb6:	18 c0       	rjmp	.+48     	; 0x2ce8 <protocol_execute_runtime+0x4c>
        if (rt_exec & EXEC_ALARM) { report_alarm_message(ALARM_LIMIT_ERROR); }
    2cb8:	c5 ff       	sbrs	r28, 5
    2cba:	04 c0       	rjmp	.+8      	; 0x2cc4 <protocol_execute_runtime+0x28>
    2cbc:	8f ef       	ldi	r24, 0xFF	; 255
    2cbe:	0e 94 19 30 	call	0x6032	; 0x6032 <report_alarm_message>
    2cc2:	03 c0       	rjmp	.+6      	; 0x2cca <protocol_execute_runtime+0x2e>
        else { report_alarm_message(ALARM_PROBE_FAIL); }
    2cc4:	8d ef       	ldi	r24, 0xFD	; 253
    2cc6:	0e 94 19 30 	call	0x6032	; 0x6032 <report_alarm_message>
        report_feedback_message(MESSAGE_CRITICAL_EVENT);
    2cca:	81 e0       	ldi	r24, 0x01	; 1
    2ccc:	0e 94 3e 30 	call	0x607c	; 0x607c <report_feedback_message>
        bit_false_atomic(sys.execute,EXEC_RESET); // Disable any existing reset
    2cd0:	8f b7       	in	r24, 0x3f	; 63
    2cd2:	f8 94       	cli
    2cd4:	e5 e8       	ldi	r30, 0x85	; 133
    2cd6:	f5 e0       	ldi	r31, 0x05	; 5
    2cd8:	90 81       	ld	r25, Z
    2cda:	9f 7e       	andi	r25, 0xEF	; 239
    2cdc:	90 83       	st	Z, r25
    2cde:	8f bf       	out	0x3f, r24	; 63
          // Nothing. Block EVERYTHING until user issues reset or power cycles. Hard limits
          // typically occur while unattended or not paying attention. Gives the user time
          // to do what is needed before resetting, like killing the incoming stream. The 
          // same could be said about soft limits. While the position is not lost, the incoming
          // stream could be still engaged and cause a serious crash if it continues afterwards.
        } while (bit_isfalse(sys.execute,EXEC_RESET));
    2ce0:	80 81       	ld	r24, Z
    2ce2:	84 ff       	sbrs	r24, 4
    2ce4:	fd cf       	rjmp	.-6      	; 0x2ce0 <protocol_execute_runtime+0x44>
    2ce6:	03 c0       	rjmp	.+6      	; 0x2cee <protocol_execute_runtime+0x52>
      // Standard alarm event. Only abort during motion qualifies.
      } else {
        // Runtime abort command issued during a cycle, feed hold, or homing cycle. Message the
        // user that position may have been lost and set alarm state to enable the alarm lockout
        // to indicate the possible severity of the problem.
        report_alarm_message(ALARM_ABORT_CYCLE);
    2ce8:	8e ef       	ldi	r24, 0xFE	; 254
    2cea:	0e 94 19 30 	call	0x6032	; 0x6032 <report_alarm_message>
      }
      bit_false_atomic(sys.execute,(EXEC_ALARM | EXEC_CRIT_EVENT));
    2cee:	8f b7       	in	r24, 0x3f	; 63
    2cf0:	f8 94       	cli
    2cf2:	e5 e8       	ldi	r30, 0x85	; 133
    2cf4:	f5 e0       	ldi	r31, 0x05	; 5
    2cf6:	90 81       	ld	r25, Z
    2cf8:	9f 79       	andi	r25, 0x9F	; 159
    2cfa:	90 83       	st	Z, r25
    2cfc:	8f bf       	out	0x3f, r24	; 63
    } 
  
    // Execute system abort. 
    if (rt_exec & EXEC_RESET) {
    2cfe:	c4 ff       	sbrs	r28, 4
    2d00:	04 c0       	rjmp	.+8      	; 0x2d0a <protocol_execute_runtime+0x6e>
      sys.abort = true;  // Only place this is set true.
    2d02:	81 e0       	ldi	r24, 0x01	; 1
    2d04:	80 93 83 05 	sts	0x0583, r24
      return; // Nothing else to do but exit.
    2d08:	5c c0       	rjmp	.+184    	; 0x2dc2 <protocol_execute_runtime+0x126>
    }
    
    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) { 
    2d0a:	c0 ff       	sbrs	r28, 0
    2d0c:	0a c0       	rjmp	.+20     	; 0x2d22 <protocol_execute_runtime+0x86>
      report_realtime_status();
    2d0e:	0e 94 12 34 	call	0x6824	; 0x6824 <report_realtime_status>
      bit_false_atomic(sys.execute,EXEC_STATUS_REPORT);
    2d12:	8f b7       	in	r24, 0x3f	; 63
    2d14:	f8 94       	cli
    2d16:	e5 e8       	ldi	r30, 0x85	; 133
    2d18:	f5 e0       	ldi	r31, 0x05	; 5
    2d1a:	90 81       	ld	r25, Z
    2d1c:	9e 7f       	andi	r25, 0xFE	; 254
    2d1e:	90 83       	st	Z, r25
    2d20:	8f bf       	out	0x3f, r24	; 63
    }
    
    // Execute a feed hold with deceleration, only during cycle.
    if (rt_exec & EXEC_FEED_HOLD) {
    2d22:	c3 ff       	sbrs	r28, 3
    2d24:	15 c0       	rjmp	.+42     	; 0x2d50 <protocol_execute_runtime+0xb4>
      // !!! During a cycle, the segment buffer has just been reloaded and full. So the math involved
      // with the feed hold should be fine for most, if not all, operational scenarios.
      if (sys.state == STATE_CYCLE) {
    2d26:	80 91 84 05 	lds	r24, 0x0584
    2d2a:	80 31       	cpi	r24, 0x10	; 16
    2d2c:	49 f4       	brne	.+18     	; 0x2d40 <protocol_execute_runtime+0xa4>
        sys.state = STATE_HOLD;
    2d2e:	80 e2       	ldi	r24, 0x20	; 32
    2d30:	80 93 84 05 	sts	0x0584, r24
        st_update_plan_block_parameters();
    2d34:	0e 94 c7 1a 	call	0x358e	; 0x358e <st_update_plan_block_parameters>
        st_prep_buffer();
    2d38:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <st_prep_buffer>
        sys.auto_start = false; // Disable planner auto start upon feed hold.
    2d3c:	10 92 93 05 	sts	0x0593, r1
      }
      bit_false_atomic(sys.execute,EXEC_FEED_HOLD);
    2d40:	8f b7       	in	r24, 0x3f	; 63
    2d42:	f8 94       	cli
    2d44:	e5 e8       	ldi	r30, 0x85	; 133
    2d46:	f5 e0       	ldi	r31, 0x05	; 5
    2d48:	90 81       	ld	r25, Z
    2d4a:	97 7f       	andi	r25, 0xF7	; 247
    2d4c:	90 83       	st	Z, r25
    2d4e:	8f bf       	out	0x3f, r24	; 63
    }
        
    // Execute a cycle start by starting the stepper interrupt begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) { 
    2d50:	c1 ff       	sbrs	r28, 1
    2d52:	1d c0       	rjmp	.+58     	; 0x2d8e <protocol_execute_runtime+0xf2>
      if (sys.state == STATE_QUEUED) {
    2d54:	80 91 84 05 	lds	r24, 0x0584
    2d58:	88 30       	cpi	r24, 0x08	; 8
    2d5a:	89 f4       	brne	.+34     	; 0x2d7e <protocol_execute_runtime+0xe2>
        sys.state = STATE_CYCLE;
    2d5c:	80 e1       	ldi	r24, 0x10	; 16
    2d5e:	80 93 84 05 	sts	0x0584, r24
        st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    2d62:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <st_prep_buffer>
        st_wake_up();
    2d66:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <st_wake_up>
        if (bit_istrue(settings.flags,BITFLAG_AUTO_START)) {
    2d6a:	80 91 7d 07 	lds	r24, 0x077D
    2d6e:	81 ff       	sbrs	r24, 1
    2d70:	04 c0       	rjmp	.+8      	; 0x2d7a <protocol_execute_runtime+0xde>
          sys.auto_start = true; // Re-enable auto start after feed hold.
    2d72:	81 e0       	ldi	r24, 0x01	; 1
    2d74:	80 93 93 05 	sts	0x0593, r24
    2d78:	02 c0       	rjmp	.+4      	; 0x2d7e <protocol_execute_runtime+0xe2>
        } else {
          sys.auto_start = false; // Reset auto start per settings.
    2d7a:	10 92 93 05 	sts	0x0593, r1
        }
      }    
      bit_false_atomic(sys.execute,EXEC_CYCLE_START);
    2d7e:	8f b7       	in	r24, 0x3f	; 63
    2d80:	f8 94       	cli
    2d82:	e5 e8       	ldi	r30, 0x85	; 133
    2d84:	f5 e0       	ldi	r31, 0x05	; 5
    2d86:	90 81       	ld	r25, Z
    2d88:	9d 7f       	andi	r25, 0xFD	; 253
    2d8a:	90 83       	st	Z, r25
    2d8c:	8f bf       	out	0x3f, r24	; 63
    // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by 
    // runtime command execution in the main program, ensuring that the planner re-plans safely.
    // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
    // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.   
    // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
    if (rt_exec & EXEC_CYCLE_STOP) {
    2d8e:	c2 ff       	sbrs	r28, 2
    2d90:	12 c0       	rjmp	.+36     	; 0x2db6 <protocol_execute_runtime+0x11a>
      if ( plan_get_current_block() ) { sys.state = STATE_QUEUED; }
    2d92:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <plan_get_current_block>
    2d96:	89 2b       	or	r24, r25
    2d98:	21 f0       	breq	.+8      	; 0x2da2 <protocol_execute_runtime+0x106>
    2d9a:	88 e0       	ldi	r24, 0x08	; 8
    2d9c:	80 93 84 05 	sts	0x0584, r24
    2da0:	02 c0       	rjmp	.+4      	; 0x2da6 <protocol_execute_runtime+0x10a>
      else { sys.state = STATE_IDLE; }
    2da2:	10 92 84 05 	sts	0x0584, r1
      bit_false_atomic(sys.execute,EXEC_CYCLE_STOP);
    2da6:	8f b7       	in	r24, 0x3f	; 63
    2da8:	f8 94       	cli
    2daa:	e5 e8       	ldi	r30, 0x85	; 133
    2dac:	f5 e0       	ldi	r31, 0x05	; 5
    2dae:	90 81       	ld	r25, Z
    2db0:	9b 7f       	andi	r25, 0xFB	; 251
    2db2:	90 83       	st	Z, r25
    2db4:	8f bf       	out	0x3f, r24	; 63
  
  // Overrides flag byte (sys.override) and execution should be installed here, since they 
  // are runtime and require a direct and controlled interface to the main stepper program.

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_HOMING)) { st_prep_buffer(); }  
    2db6:	80 91 84 05 	lds	r24, 0x0584
    2dba:	84 73       	andi	r24, 0x34	; 52
    2dbc:	11 f0       	breq	.+4      	; 0x2dc2 <protocol_execute_runtime+0x126>
    2dbe:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <st_prep_buffer>
  
}  
    2dc2:	cf 91       	pop	r28
    2dc4:	08 95       	ret

00002dc6 <protocol_auto_cycle_start>:
// manually issuing a cycle start command whenever the user is ready and there is a valid motion 
// command in the planner queue.
// NOTE: This function is called from the main loop and mc_line() only and executes when one of
// two conditions exist respectively: There are no more blocks sent (i.e. streaming is finished, 
// single commands), or the planner buffer is full and ready to go.
void protocol_auto_cycle_start() { if (sys.auto_start) { bit_true_atomic(sys.execute, EXEC_CYCLE_START); } } 
    2dc6:	80 91 93 05 	lds	r24, 0x0593
    2dca:	88 23       	and	r24, r24
    2dcc:	41 f0       	breq	.+16     	; 0x2dde <protocol_auto_cycle_start+0x18>
    2dce:	8f b7       	in	r24, 0x3f	; 63
    2dd0:	f8 94       	cli
    2dd2:	e5 e8       	ldi	r30, 0x85	; 133
    2dd4:	f5 e0       	ldi	r31, 0x05	; 5
    2dd6:	90 81       	ld	r25, Z
    2dd8:	92 60       	ori	r25, 0x02	; 2
    2dda:	90 83       	st	Z, r25
    2ddc:	8f bf       	out	0x3f, r24	; 63
    2dde:	08 95       	ret

00002de0 <protocol_main_loop>:

/* 
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    2de0:	af 92       	push	r10
    2de2:	bf 92       	push	r11
    2de4:	cf 92       	push	r12
    2de6:	df 92       	push	r13
    2de8:	ef 92       	push	r14
    2dea:	ff 92       	push	r15
    2dec:	0f 93       	push	r16
    2dee:	1f 93       	push	r17
    2df0:	cf 93       	push	r28
    2df2:	df 93       	push	r29
  // ------------------------------------------------------------
  // Complete initialization procedures upon a power-up or reset.
  // ------------------------------------------------------------
  
  // Print welcome message   
  report_init_message();
    2df4:	0e 94 6f 30 	call	0x60de	; 0x60de <report_init_message>

  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    2df8:	80 91 84 05 	lds	r24, 0x0584
    2dfc:	81 30       	cpi	r24, 0x01	; 1
    2dfe:	99 f4       	brne	.+38     	; 0x2e26 <protocol_main_loop+0x46>
    report_feedback_message(MESSAGE_ALARM_LOCK); 
    2e00:	82 e0       	ldi	r24, 0x02	; 2
    2e02:	0e 94 3e 30 	call	0x607c	; 0x607c <report_feedback_message>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            iscomment = true;
    2e06:	a1 2c       	mov	r10, r1
    2e08:	b1 2c       	mov	r11, r1
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_runtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    2e0a:	c3 e8       	ldi	r28, 0x83	; 131
    2e0c:	d5 e0       	ldi	r29, 0x05	; 5
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
        char_counter = 0;
    2e0e:	d1 2c       	mov	r13, r1
static void protocol_execute_line(char *line) 
{      
  protocol_execute_runtime(); // Runtime command check point.
  if (sys.abort) { return; } // Bail to calling function upon system abort  

  if (line[0] == 0) {
    2e10:	0a e0       	ldi	r16, 0x0A	; 10
    2e12:	11 e0       	ldi	r17, 0x01	; 1

  } else if (line[0] == '$') {
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    
  } else if (sys.state == STATE_ALARM) {
    2e14:	0f 2e       	mov	r0, r31
    2e16:	f4 e8       	ldi	r31, 0x84	; 132
    2e18:	ef 2e       	mov	r14, r31
    2e1a:	f5 e0       	ldi	r31, 0x05	; 5
    2e1c:	ff 2e       	mov	r15, r31
    2e1e:	f0 2d       	mov	r31, r0
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            iscomment = true;
    2e20:	cc 24       	eor	r12, r12
    2e22:	c3 94       	inc	r12
    2e24:	67 c0       	rjmp	.+206    	; 0x2ef4 <protocol_main_loop+0x114>
  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    report_feedback_message(MESSAGE_ALARM_LOCK); 
  } else {
    // All systems go!
    sys.state = STATE_IDLE; // Set system to ready. Clear all state flags.
    2e26:	10 92 84 05 	sts	0x0584, r1
    system_execute_startup(line); // Execute startup script.
    2e2a:	8a e0       	ldi	r24, 0x0A	; 10
    2e2c:	91 e0       	ldi	r25, 0x01	; 1
    2e2e:	0e 94 72 35 	call	0x6ae4	; 0x6ae4 <system_execute_startup>
    2e32:	e9 cf       	rjmp	.-46     	; 0x2e06 <protocol_main_loop+0x26>
    // exceed 256 characters, but the Arduino Uno does not have the memory space for this.
    // With a better processor, it would be very easy to pull this initial parsing out as a 
    // seperate task to be shared by the g-code parser and Grbl's system commands.
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
    2e34:	8a 30       	cpi	r24, 0x0A	; 10
    2e36:	11 f0       	breq	.+4      	; 0x2e3c <protocol_main_loop+0x5c>
    2e38:	8d 30       	cpi	r24, 0x0D	; 13
    2e3a:	81 f5       	brne	.+96     	; 0x2e9c <protocol_main_loop+0xbc>
        line[char_counter] = 0; // Set string termination character.
    2e3c:	ea 2d       	mov	r30, r10
    2e3e:	f0 e0       	ldi	r31, 0x00	; 0
    2e40:	e6 5f       	subi	r30, 0xF6	; 246
    2e42:	fe 4f       	sbci	r31, 0xFE	; 254
    2e44:	10 82       	st	Z, r1
// Directs and executes one line of formatted input from protocol_process. While mostly
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_runtime(); // Runtime command check point.
    2e46:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    2e4a:	88 81       	ld	r24, Y
    2e4c:	81 11       	cpse	r24, r1
    2e4e:	4c c0       	rjmp	.+152    	; 0x2ee8 <protocol_main_loop+0x108>

  if (line[0] == 0) {
    2e50:	f8 01       	movw	r30, r16
    2e52:	80 81       	ld	r24, Z
    2e54:	81 11       	cpse	r24, r1
    2e56:	06 c0       	rjmp	.+12     	; 0x2e64 <protocol_main_loop+0x84>
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);
    2e58:	8d 2d       	mov	r24, r13
    2e5a:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
        char_counter = 0;
    2e5e:	ad 2c       	mov	r10, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
    2e60:	bd 2c       	mov	r11, r13
    2e62:	48 c0       	rjmp	.+144    	; 0x2ef4 <protocol_main_loop+0x114>

  if (line[0] == 0) {
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);

  } else if (line[0] == '$') {
    2e64:	84 32       	cpi	r24, 0x24	; 36
    2e66:	41 f4       	brne	.+16     	; 0x2e78 <protocol_main_loop+0x98>
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    2e68:	c8 01       	movw	r24, r16
    2e6a:	0e 94 93 35 	call	0x6b26	; 0x6b26 <system_execute_line>
    2e6e:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
        char_counter = 0;
    2e72:	ad 2c       	mov	r10, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
    2e74:	bd 2c       	mov	r11, r13
    2e76:	3e c0       	rjmp	.+124    	; 0x2ef4 <protocol_main_loop+0x114>

  } else if (line[0] == '$') {
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    
  } else if (sys.state == STATE_ALARM) {
    2e78:	f7 01       	movw	r30, r14
    2e7a:	80 81       	ld	r24, Z
    2e7c:	81 30       	cpi	r24, 0x01	; 1
    2e7e:	31 f4       	brne	.+12     	; 0x2e8c <protocol_main_loop+0xac>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);
    2e80:	89 e0       	ldi	r24, 0x09	; 9
    2e82:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
        char_counter = 0;
    2e86:	ad 2c       	mov	r10, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
    2e88:	bd 2c       	mov	r11, r13
    2e8a:	34 c0       	rjmp	.+104    	; 0x2ef4 <protocol_main_loop+0x114>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);

  } else {
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
    2e8c:	c8 01       	movw	r24, r16
    2e8e:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <gc_execute_line>
    2e92:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
        char_counter = 0;
    2e96:	ad 2c       	mov	r10, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
    2e98:	bd 2c       	mov	r11, r13
    2e9a:	2c c0       	rjmp	.+88     	; 0x2ef4 <protocol_main_loop+0x114>
        char_counter = 0;
      } else {
        if (iscomment) {
    2e9c:	bb 20       	and	r11, r11
    2e9e:	19 f0       	breq	.+6      	; 0x2ea6 <protocol_main_loop+0xc6>
          // Throw away all comment characters
          if (c == ')') {
    2ea0:	89 32       	cpi	r24, 0x29	; 41
    2ea2:	41 f5       	brne	.+80     	; 0x2ef4 <protocol_main_loop+0x114>
    2ea4:	24 c0       	rjmp	.+72     	; 0x2eee <protocol_main_loop+0x10e>
            // End of comment. Resume line.
            iscomment = false;
          }
        } else {
          if (c <= ' ') { 
    2ea6:	81 32       	cpi	r24, 0x21	; 33
    2ea8:	28 f1       	brcs	.+74     	; 0x2ef4 <protocol_main_loop+0x114>
            // Throw away whitepace and control characters  
          } else if (c == '/') { 
    2eaa:	8f 32       	cpi	r24, 0x2F	; 47
    2eac:	19 f1       	breq	.+70     	; 0x2ef4 <protocol_main_loop+0x114>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    2eae:	88 32       	cpi	r24, 0x28	; 40
    2eb0:	01 f1       	breq	.+64     	; 0x2ef2 <protocol_main_loop+0x112>
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute 
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.

          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    2eb2:	fe e4       	ldi	r31, 0x4E	; 78
    2eb4:	fa 15       	cp	r31, r10
    2eb6:	28 f4       	brcc	.+10     	; 0x2ec2 <protocol_main_loop+0xe2>
            // Detect line buffer overflow. Report error and reset line buffer.
            report_status_message(STATUS_OVERFLOW);
    2eb8:	8b e0       	ldi	r24, 0x0B	; 11
    2eba:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
            iscomment = false;
            char_counter = 0;
    2ebe:	ad 2c       	mov	r10, r13
    2ec0:	19 c0       	rjmp	.+50     	; 0x2ef4 <protocol_main_loop+0x114>
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    2ec2:	9f e9       	ldi	r25, 0x9F	; 159
    2ec4:	98 0f       	add	r25, r24
    2ec6:	9a 31       	cpi	r25, 0x1A	; 26
    2ec8:	40 f4       	brcc	.+16     	; 0x2eda <protocol_main_loop+0xfa>
            line[char_counter++] = c-'a'+'A';
    2eca:	aa 2d       	mov	r26, r10
    2ecc:	b0 e0       	ldi	r27, 0x00	; 0
    2ece:	a6 5f       	subi	r26, 0xF6	; 246
    2ed0:	be 4f       	sbci	r27, 0xFE	; 254
    2ed2:	80 52       	subi	r24, 0x20	; 32
    2ed4:	8c 93       	st	X, r24
    2ed6:	a3 94       	inc	r10
    2ed8:	0d c0       	rjmp	.+26     	; 0x2ef4 <protocol_main_loop+0x114>
          } else {
            line[char_counter++] = c;
    2eda:	aa 2d       	mov	r26, r10
    2edc:	b0 e0       	ldi	r27, 0x00	; 0
    2ede:	a6 5f       	subi	r26, 0xF6	; 246
    2ee0:	be 4f       	sbci	r27, 0xFE	; 254
    2ee2:	8c 93       	st	X, r24
    2ee4:	a3 94       	inc	r10
    2ee6:	06 c0       	rjmp	.+12     	; 0x2ef4 <protocol_main_loop+0x114>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
        char_counter = 0;
    2ee8:	ad 2c       	mov	r10, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        iscomment = false;
    2eea:	bd 2c       	mov	r11, r13
    2eec:	03 c0       	rjmp	.+6      	; 0x2ef4 <protocol_main_loop+0x114>
      } else {
        if (iscomment) {
          // Throw away all comment characters
          if (c == ')') {
            // End of comment. Resume line.
            iscomment = false;
    2eee:	bd 2c       	mov	r11, r13
    2ef0:	01 c0       	rjmp	.+2      	; 0x2ef4 <protocol_main_loop+0x114>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            iscomment = true;
    2ef2:	bc 2c       	mov	r11, r12
    // line buffer, which is limited in size. The g-code standard actually states a line can't
    // exceed 256 characters, but the Arduino Uno does not have the memory space for this.
    // With a better processor, it would be very easy to pull this initial parsing out as a 
    // seperate task to be shared by the g-code parser and Grbl's system commands.
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
    2ef4:	0e 94 d7 15 	call	0x2bae	; 0x2bae <serial_read>
    2ef8:	8f 3f       	cpi	r24, 0xFF	; 255
    2efa:	09 f0       	breq	.+2      	; 0x2efe <protocol_main_loop+0x11e>
    2efc:	9b cf       	rjmp	.-202    	; 0x2e34 <protocol_main_loop+0x54>
    }
    
    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    2efe:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <protocol_auto_cycle_start>

    protocol_execute_runtime();  // Runtime command check point.
    2f02:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    2f06:	88 81       	ld	r24, Y
    2f08:	88 23       	and	r24, r24
    2f0a:	a1 f3       	breq	.-24     	; 0x2ef4 <protocol_main_loop+0x114>
              
  }
  
  return; /* Never reached */
}
    2f0c:	df 91       	pop	r29
    2f0e:	cf 91       	pop	r28
    2f10:	1f 91       	pop	r17
    2f12:	0f 91       	pop	r16
    2f14:	ff 90       	pop	r15
    2f16:	ef 90       	pop	r14
    2f18:	df 90       	pop	r13
    2f1a:	cf 90       	pop	r12
    2f1c:	bf 90       	pop	r11
    2f1e:	af 90       	pop	r10
    2f20:	08 95       	ret

00002f22 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    2f22:	0f 93       	push	r16
    2f24:	1f 93       	push	r17
    2f26:	cf 93       	push	r28
    2f28:	df 93       	push	r29
  // Check and set auto start to resume cycle after synchronize and caller completes.
  if (sys.state == STATE_CYCLE) { sys.auto_start = true; }
    2f2a:	80 91 84 05 	lds	r24, 0x0584
    2f2e:	80 31       	cpi	r24, 0x10	; 16
    2f30:	21 f4       	brne	.+8      	; 0x2f3a <protocol_buffer_synchronize+0x18>
    2f32:	81 e0       	ldi	r24, 0x01	; 1
    2f34:	80 93 93 05 	sts	0x0593, r24
    2f38:	0b c0       	rjmp	.+22     	; 0x2f50 <protocol_buffer_synchronize+0x2e>
  if (sys.state == STATE_QUEUED) { protocol_auto_cycle_start(); }
    2f3a:	88 30       	cpi	r24, 0x08	; 8
    2f3c:	49 f4       	brne	.+18     	; 0x2f50 <protocol_buffer_synchronize+0x2e>
    2f3e:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <protocol_auto_cycle_start>
    2f42:	06 c0       	rjmp	.+12     	; 0x2f50 <protocol_buffer_synchronize+0x2e>

  while (plan_get_current_block() || (sys.state == STATE_CYCLE)) { 
    protocol_execute_runtime();   // Check and execute run-time commands
    2f44:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
    if (sys.abort) { return; } // Check for system abort
    2f48:	88 81       	ld	r24, Y
    2f4a:	88 23       	and	r24, r24
    2f4c:	29 f0       	breq	.+10     	; 0x2f58 <protocol_buffer_synchronize+0x36>
    2f4e:	0c c0       	rjmp	.+24     	; 0x2f68 <protocol_buffer_synchronize+0x46>
{
  // Check and set auto start to resume cycle after synchronize and caller completes.
  if (sys.state == STATE_CYCLE) { sys.auto_start = true; }
  if (sys.state == STATE_QUEUED) { protocol_auto_cycle_start(); }

  while (plan_get_current_block() || (sys.state == STATE_CYCLE)) { 
    2f50:	04 e8       	ldi	r16, 0x84	; 132
    2f52:	15 e0       	ldi	r17, 0x05	; 5
    protocol_execute_runtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    2f54:	c3 e8       	ldi	r28, 0x83	; 131
    2f56:	d5 e0       	ldi	r29, 0x05	; 5
{
  // Check and set auto start to resume cycle after synchronize and caller completes.
  if (sys.state == STATE_CYCLE) { sys.auto_start = true; }
  if (sys.state == STATE_QUEUED) { protocol_auto_cycle_start(); }

  while (plan_get_current_block() || (sys.state == STATE_CYCLE)) { 
    2f58:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <plan_get_current_block>
    2f5c:	89 2b       	or	r24, r25
    2f5e:	91 f7       	brne	.-28     	; 0x2f44 <protocol_buffer_synchronize+0x22>
    2f60:	f8 01       	movw	r30, r16
    2f62:	80 81       	ld	r24, Z
    2f64:	80 31       	cpi	r24, 0x10	; 16
    2f66:	71 f3       	breq	.-36     	; 0x2f44 <protocol_buffer_synchronize+0x22>
    protocol_execute_runtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
  }    
}
    2f68:	df 91       	pop	r29
    2f6a:	cf 91       	pop	r28
    2f6c:	1f 91       	pop	r17
    2f6e:	0f 91       	pop	r16
    2f70:	08 95       	ret

00002f72 <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up() 
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    2f72:	80 91 7d 07 	lds	r24, 0x077D
    2f76:	82 ff       	sbrs	r24, 2
    2f78:	02 c0       	rjmp	.+4      	; 0x2f7e <st_wake_up+0xc>
    2f7a:	28 9a       	sbi	0x05, 0	; 5
    2f7c:	01 c0       	rjmp	.+2      	; 0x2f80 <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    2f7e:	28 98       	cbi	0x05, 0	; 5

  if (sys.state & (STATE_CYCLE | STATE_HOMING)){
    2f80:	80 91 84 05 	lds	r24, 0x0584
    2f84:	84 71       	andi	r24, 0x14	; 20
    2f86:	a1 f0       	breq	.+40     	; 0x2fb0 <st_wake_up+0x3e>
    // Initialize stepper output bits
    st.dir_outbits = dir_port_invert_mask; 
    2f88:	80 91 8a 01 	lds	r24, 0x018A
    2f8c:	80 93 9e 01 	sts	0x019E, r24
    st.step_outbits = step_port_invert_mask;
    2f90:	80 91 8b 01 	lds	r24, 0x018B
    2f94:	80 93 9d 01 	sts	0x019D, r24
      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
      // Set delay between direction pin write and step command.
      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    #else // Normal operation
      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    2f98:	80 91 70 07 	lds	r24, 0x0770
    2f9c:	88 0f       	add	r24, r24
    2f9e:	84 50       	subi	r24, 0x04	; 4
    2fa0:	81 95       	neg	r24
    2fa2:	80 93 9c 01 	sts	0x019C, r24
    #endif

    // Enable Stepper Driver Interrupt
    TIMSK1 |= (1<<OCIE1A);
    2fa6:	ef e6       	ldi	r30, 0x6F	; 111
    2fa8:	f0 e0       	ldi	r31, 0x00	; 0
    2faa:	80 81       	ld	r24, Z
    2fac:	82 60       	ori	r24, 0x02	; 2
    2fae:	80 83       	st	Z, r24
    2fb0:	08 95       	ret

00002fb2 <st_go_idle>:

// Stepper shutdown
void st_go_idle() 
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    2fb2:	ef e6       	ldi	r30, 0x6F	; 111
    2fb4:	f0 e0       	ldi	r31, 0x00	; 0
    2fb6:	80 81       	ld	r24, Z
    2fb8:	8d 7f       	andi	r24, 0xFD	; 253
    2fba:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    2fbc:	e1 e8       	ldi	r30, 0x81	; 129
    2fbe:	f0 e0       	ldi	r31, 0x00	; 0
    2fc0:	80 81       	ld	r24, Z
    2fc2:	88 7f       	andi	r24, 0xF8	; 248
    2fc4:	81 60       	ori	r24, 0x01	; 1
    2fc6:	80 83       	st	Z, r24
  busy = false;
    2fc8:	10 92 89 01 	sts	0x0189, r1
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || bit_istrue(sys.execute,EXEC_ALARM)) && sys.state != STATE_HOMING) {
    2fcc:	80 91 73 07 	lds	r24, 0x0773
    2fd0:	8f 3f       	cpi	r24, 0xFF	; 255
    2fd2:	21 f4       	brne	.+8      	; 0x2fdc <st_go_idle+0x2a>
    2fd4:	90 91 85 05 	lds	r25, 0x0585
    2fd8:	95 ff       	sbrs	r25, 5
    2fda:	09 c0       	rjmp	.+18     	; 0x2fee <st_go_idle+0x3c>
    2fdc:	90 91 84 05 	lds	r25, 0x0584
    2fe0:	94 30       	cpi	r25, 0x04	; 4
    2fe2:	39 f0       	breq	.+14     	; 0x2ff2 <st_go_idle+0x40>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
    2fe6:	0e 94 e6 2a 	call	0x55cc	; 0x55cc <delay_ms>
    pin_state = true; // Override. Disable steppers.
    2fea:	81 e0       	ldi	r24, 0x01	; 1
    2fec:	03 c0       	rjmp	.+6      	; 0x2ff4 <st_go_idle+0x42>
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
  busy = false;
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
    2fee:	80 e0       	ldi	r24, 0x00	; 0
    2ff0:	01 c0       	rjmp	.+2      	; 0x2ff4 <st_go_idle+0x42>
    2ff2:	80 e0       	ldi	r24, 0x00	; 0
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    2ff4:	90 91 7d 07 	lds	r25, 0x077D
    2ff8:	92 ff       	sbrs	r25, 2
    2ffa:	02 c0       	rjmp	.+4      	; 0x3000 <st_go_idle+0x4e>
    2ffc:	91 e0       	ldi	r25, 0x01	; 1
    2ffe:	89 27       	eor	r24, r25
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    3000:	88 23       	and	r24, r24
    3002:	11 f0       	breq	.+4      	; 0x3008 <st_go_idle+0x56>
    3004:	28 9a       	sbi	0x05, 0	; 5
    3006:	08 95       	ret
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    3008:	28 98       	cbi	0x05, 0	; 5
    300a:	08 95       	ret

0000300c <__vector_11>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated 
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{        
    300c:	1f 92       	push	r1
    300e:	0f 92       	push	r0
    3010:	0f b6       	in	r0, 0x3f	; 63
    3012:	0f 92       	push	r0
    3014:	11 24       	eor	r1, r1
    3016:	2f 93       	push	r18
    3018:	3f 93       	push	r19
    301a:	4f 93       	push	r20
    301c:	5f 93       	push	r21
    301e:	6f 93       	push	r22
    3020:	7f 93       	push	r23
    3022:	8f 93       	push	r24
    3024:	9f 93       	push	r25
    3026:	af 93       	push	r26
    3028:	bf 93       	push	r27
    302a:	cf 93       	push	r28
    302c:	df 93       	push	r29
    302e:	ef 93       	push	r30
    3030:	ff 93       	push	r31
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    3032:	80 91 89 01 	lds	r24, 0x0189
    3036:	81 11       	cpse	r24, r1
    3038:	ec c1       	rjmp	.+984    	; 0x3412 <__vector_11+0x406>
  
  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    303a:	8b b1       	in	r24, 0x0b	; 11
    303c:	90 91 9e 01 	lds	r25, 0x019E
    3040:	90 7e       	andi	r25, 0xE0	; 224
    3042:	8f 71       	andi	r24, 0x1F	; 31
    3044:	89 2b       	or	r24, r25
    3046:	8b b9       	out	0x0b, r24	; 11

  // Then pulse the stepping pins
  #ifdef STEP_PULSE_DELAY
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    3048:	8b b1       	in	r24, 0x0b	; 11
    304a:	83 7e       	andi	r24, 0xE3	; 227
    304c:	90 91 9d 01 	lds	r25, 0x019D
    3050:	89 2b       	or	r24, r25
    3052:	8b b9       	out	0x0b, r24	; 11
  #endif  

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    3054:	80 91 9c 01 	lds	r24, 0x019C
    3058:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    305a:	82 e0       	ldi	r24, 0x02	; 2
    305c:	85 bd       	out	0x25, r24	; 37

  busy = true;
    305e:	81 e0       	ldi	r24, 0x01	; 1
    3060:	80 93 89 01 	sts	0x0189, r24
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. 
    3064:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.
    
  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    3066:	80 91 b0 01 	lds	r24, 0x01B0
    306a:	90 91 b1 01 	lds	r25, 0x01B1
    306e:	89 2b       	or	r24, r25
    3070:	09 f0       	breq	.+2      	; 0x3074 <__vector_11+0x68>
    3072:	a9 c0       	rjmp	.+338    	; 0x31c6 <__vector_11+0x1ba>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    3074:	80 91 8e 01 	lds	r24, 0x018E
    3078:	90 91 8d 01 	lds	r25, 0x018D
    307c:	98 17       	cp	r25, r24
    307e:	09 f4       	brne	.+2      	; 0x3082 <__vector_11+0x76>
    3080:	97 c0       	rjmp	.+302    	; 0x31b0 <__vector_11+0x1a4>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    3082:	80 91 8e 01 	lds	r24, 0x018E
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	fc 01       	movw	r30, r24
    308a:	ee 0f       	add	r30, r30
    308c:	ff 1f       	adc	r31, r31
    308e:	8e 0f       	add	r24, r30
    3090:	9f 1f       	adc	r25, r31
    3092:	fc 01       	movw	r30, r24
    3094:	ee 0f       	add	r30, r30
    3096:	ff 1f       	adc	r31, r31
    3098:	ee 54       	subi	r30, 0x4E	; 78
    309a:	fe 4f       	sbci	r31, 0xFE	; 254
    309c:	f0 93 b1 01 	sts	0x01B1, r31
    30a0:	e0 93 b0 01 	sts	0x01B0, r30
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    30a4:	83 81       	ldd	r24, Z+3	; 0x03
    30a6:	94 81       	ldd	r25, Z+4	; 0x04
    30a8:	90 93 89 00 	sts	0x0089, r25
    30ac:	80 93 88 00 	sts	0x0088, r24
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    30b0:	80 81       	ld	r24, Z
    30b2:	91 81       	ldd	r25, Z+1	; 0x01
    30b4:	90 93 ac 01 	sts	0x01AC, r25
    30b8:	80 93 ab 01 	sts	0x01AB, r24
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    30bc:	a2 81       	ldd	r26, Z+2	; 0x02
    30be:	80 91 ad 01 	lds	r24, 0x01AD
    30c2:	8a 17       	cp	r24, r26
    30c4:	71 f1       	breq	.+92     	; 0x3122 <__vector_11+0x116>
        st.exec_block_index = st.exec_segment->st_block_index;
    30c6:	a0 93 ad 01 	sts	0x01AD, r26
        st.exec_block = &st_block_buffer[st.exec_block_index];
    30ca:	81 e1       	ldi	r24, 0x11	; 17
    30cc:	a8 9f       	mul	r26, r24
    30ce:	d0 01       	movw	r26, r0
    30d0:	11 24       	eor	r1, r1
    30d2:	aa 52       	subi	r26, 0x2A	; 42
    30d4:	be 4f       	sbci	r27, 0xFE	; 254
    30d6:	b0 93 af 01 	sts	0x01AF, r27
    30da:	a0 93 ae 01 	sts	0x01AE, r26
        
        // Initialize Bresenham line and distance counters
        st.counter_x = (st.exec_block->step_event_count >> 1);
    30de:	1d 96       	adiw	r26, 0x0d	; 13
    30e0:	8d 91       	ld	r24, X+
    30e2:	9d 91       	ld	r25, X+
    30e4:	0d 90       	ld	r0, X+
    30e6:	bc 91       	ld	r27, X
    30e8:	a0 2d       	mov	r26, r0
    30ea:	b6 95       	lsr	r27
    30ec:	a7 95       	ror	r26
    30ee:	97 95       	ror	r25
    30f0:	87 95       	ror	r24
    30f2:	80 93 8f 01 	sts	0x018F, r24
    30f6:	90 93 90 01 	sts	0x0190, r25
    30fa:	a0 93 91 01 	sts	0x0191, r26
    30fe:	b0 93 92 01 	sts	0x0192, r27
        st.counter_y = st.counter_x;
    3102:	80 93 93 01 	sts	0x0193, r24
    3106:	90 93 94 01 	sts	0x0194, r25
    310a:	a0 93 95 01 	sts	0x0195, r26
    310e:	b0 93 96 01 	sts	0x0196, r27
        st.counter_z = st.counter_x;        
    3112:	80 93 97 01 	sts	0x0197, r24
    3116:	90 93 98 01 	sts	0x0198, r25
    311a:	a0 93 99 01 	sts	0x0199, r26
    311e:	b0 93 9a 01 	sts	0x019A, r27
      }

      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask; 
    3122:	c0 91 ae 01 	lds	r28, 0x01AE
    3126:	d0 91 af 01 	lds	r29, 0x01AF
    312a:	90 91 8a 01 	lds	r25, 0x018A
    312e:	88 81       	ld	r24, Y
    3130:	89 27       	eor	r24, r25
    3132:	80 93 9e 01 	sts	0x019E, r24

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    3136:	89 81       	ldd	r24, Y+1	; 0x01
    3138:	9a 81       	ldd	r25, Y+2	; 0x02
    313a:	ab 81       	ldd	r26, Y+3	; 0x03
    313c:	bc 81       	ldd	r27, Y+4	; 0x04
    313e:	05 80       	ldd	r0, Z+5	; 0x05
    3140:	04 c0       	rjmp	.+8      	; 0x314a <__vector_11+0x13e>
    3142:	b6 95       	lsr	r27
    3144:	a7 95       	ror	r26
    3146:	97 95       	ror	r25
    3148:	87 95       	ror	r24
    314a:	0a 94       	dec	r0
    314c:	d2 f7       	brpl	.-12     	; 0x3142 <__vector_11+0x136>
    314e:	80 93 9f 01 	sts	0x019F, r24
    3152:	90 93 a0 01 	sts	0x01A0, r25
    3156:	a0 93 a1 01 	sts	0x01A1, r26
    315a:	b0 93 a2 01 	sts	0x01A2, r27
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    315e:	8d 81       	ldd	r24, Y+5	; 0x05
    3160:	9e 81       	ldd	r25, Y+6	; 0x06
    3162:	af 81       	ldd	r26, Y+7	; 0x07
    3164:	b8 85       	ldd	r27, Y+8	; 0x08
    3166:	05 80       	ldd	r0, Z+5	; 0x05
    3168:	04 c0       	rjmp	.+8      	; 0x3172 <__vector_11+0x166>
    316a:	b6 95       	lsr	r27
    316c:	a7 95       	ror	r26
    316e:	97 95       	ror	r25
    3170:	87 95       	ror	r24
    3172:	0a 94       	dec	r0
    3174:	d2 f7       	brpl	.-12     	; 0x316a <__vector_11+0x15e>
    3176:	80 93 a3 01 	sts	0x01A3, r24
    317a:	90 93 a4 01 	sts	0x01A4, r25
    317e:	a0 93 a5 01 	sts	0x01A5, r26
    3182:	b0 93 a6 01 	sts	0x01A6, r27
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    3186:	89 85       	ldd	r24, Y+9	; 0x09
    3188:	9a 85       	ldd	r25, Y+10	; 0x0a
    318a:	ab 85       	ldd	r26, Y+11	; 0x0b
    318c:	bc 85       	ldd	r27, Y+12	; 0x0c
    318e:	05 80       	ldd	r0, Z+5	; 0x05
    3190:	04 c0       	rjmp	.+8      	; 0x319a <__vector_11+0x18e>
    3192:	b6 95       	lsr	r27
    3194:	a7 95       	ror	r26
    3196:	97 95       	ror	r25
    3198:	87 95       	ror	r24
    319a:	0a 94       	dec	r0
    319c:	d2 f7       	brpl	.-12     	; 0x3192 <__vector_11+0x186>
    319e:	80 93 a7 01 	sts	0x01A7, r24
    31a2:	90 93 a8 01 	sts	0x01A8, r25
    31a6:	a0 93 a9 01 	sts	0x01A9, r26
    31aa:	b0 93 aa 01 	sts	0x01AA, r27
    31ae:	0b c0       	rjmp	.+22     	; 0x31c6 <__vector_11+0x1ba>
      #endif
      
    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    31b0:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <st_go_idle>
      bit_true_atomic(sys.execute,EXEC_CYCLE_STOP); // Flag main program for cycle end
    31b4:	8f b7       	in	r24, 0x3f	; 63
    31b6:	f8 94       	cli
    31b8:	e5 e8       	ldi	r30, 0x85	; 133
    31ba:	f5 e0       	ldi	r31, 0x05	; 5
    31bc:	90 81       	ld	r25, Z
    31be:	94 60       	ori	r25, 0x04	; 4
    31c0:	90 83       	st	Z, r25
    31c2:	8f bf       	out	0x3f, r24	; 63
      return; // Nothing to do but exit.
    31c4:	26 c1       	rjmp	.+588    	; 0x3412 <__vector_11+0x406>
    }  
  }
  
  
  // Check probing state.
  probe_state_monitor();
    31c6:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <probe_state_monitor>
   
  // Reset step out bits.
  st.step_outbits = 0; 
    31ca:	10 92 9d 01 	sts	0x019D, r1

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    31ce:	ef e8       	ldi	r30, 0x8F	; 143
    31d0:	f1 e0       	ldi	r31, 0x01	; 1
    31d2:	40 91 9f 01 	lds	r20, 0x019F
    31d6:	50 91 a0 01 	lds	r21, 0x01A0
    31da:	60 91 a1 01 	lds	r22, 0x01A1
    31de:	70 91 a2 01 	lds	r23, 0x01A2
    31e2:	80 81       	ld	r24, Z
    31e4:	91 81       	ldd	r25, Z+1	; 0x01
    31e6:	a2 81       	ldd	r26, Z+2	; 0x02
    31e8:	b3 81       	ldd	r27, Z+3	; 0x03
    31ea:	84 0f       	add	r24, r20
    31ec:	95 1f       	adc	r25, r21
    31ee:	a6 1f       	adc	r26, r22
    31f0:	b7 1f       	adc	r27, r23
    31f2:	80 83       	st	Z, r24
    31f4:	91 83       	std	Z+1, r25	; 0x01
    31f6:	a2 83       	std	Z+2, r26	; 0x02
    31f8:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif  
  if (st.counter_x > st.exec_block->step_event_count) {
    31fa:	e0 91 ae 01 	lds	r30, 0x01AE
    31fe:	f0 91 af 01 	lds	r31, 0x01AF
    3202:	45 85       	ldd	r20, Z+13	; 0x0d
    3204:	56 85       	ldd	r21, Z+14	; 0x0e
    3206:	67 85       	ldd	r22, Z+15	; 0x0f
    3208:	70 89       	ldd	r23, Z+16	; 0x10
    320a:	48 17       	cp	r20, r24
    320c:	59 07       	cpc	r21, r25
    320e:	6a 07       	cpc	r22, r26
    3210:	7b 07       	cpc	r23, r27
    3212:	88 f5       	brcc	.+98     	; 0x3276 <__vector_11+0x26a>
    st.step_outbits |= (1<<X_STEP_BIT);
    3214:	24 e0       	ldi	r18, 0x04	; 4
    3216:	20 93 9d 01 	sts	0x019D, r18
    st.counter_x -= st.exec_block->step_event_count;
    321a:	45 85       	ldd	r20, Z+13	; 0x0d
    321c:	56 85       	ldd	r21, Z+14	; 0x0e
    321e:	67 85       	ldd	r22, Z+15	; 0x0f
    3220:	70 89       	ldd	r23, Z+16	; 0x10
    3222:	84 1b       	sub	r24, r20
    3224:	95 0b       	sbc	r25, r21
    3226:	a6 0b       	sbc	r26, r22
    3228:	b7 0b       	sbc	r27, r23
    322a:	80 93 8f 01 	sts	0x018F, r24
    322e:	90 93 90 01 	sts	0x0190, r25
    3232:	a0 93 91 01 	sts	0x0191, r26
    3236:	b0 93 92 01 	sts	0x0192, r27
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys.position[X_AXIS]--; }
    323a:	80 81       	ld	r24, Z
    323c:	85 ff       	sbrs	r24, 5
    323e:	0e c0       	rjmp	.+28     	; 0x325c <__vector_11+0x250>
    3240:	c7 e8       	ldi	r28, 0x87	; 135
    3242:	d5 e0       	ldi	r29, 0x05	; 5
    3244:	88 81       	ld	r24, Y
    3246:	99 81       	ldd	r25, Y+1	; 0x01
    3248:	aa 81       	ldd	r26, Y+2	; 0x02
    324a:	bb 81       	ldd	r27, Y+3	; 0x03
    324c:	01 97       	sbiw	r24, 0x01	; 1
    324e:	a1 09       	sbc	r26, r1
    3250:	b1 09       	sbc	r27, r1
    3252:	88 83       	st	Y, r24
    3254:	99 83       	std	Y+1, r25	; 0x01
    3256:	aa 83       	std	Y+2, r26	; 0x02
    3258:	bb 83       	std	Y+3, r27	; 0x03
    325a:	0d c0       	rjmp	.+26     	; 0x3276 <__vector_11+0x26a>
    else { sys.position[X_AXIS]++; }
    325c:	c7 e8       	ldi	r28, 0x87	; 135
    325e:	d5 e0       	ldi	r29, 0x05	; 5
    3260:	88 81       	ld	r24, Y
    3262:	99 81       	ldd	r25, Y+1	; 0x01
    3264:	aa 81       	ldd	r26, Y+2	; 0x02
    3266:	bb 81       	ldd	r27, Y+3	; 0x03
    3268:	01 96       	adiw	r24, 0x01	; 1
    326a:	a1 1d       	adc	r26, r1
    326c:	b1 1d       	adc	r27, r1
    326e:	88 83       	st	Y, r24
    3270:	99 83       	std	Y+1, r25	; 0x01
    3272:	aa 83       	std	Y+2, r26	; 0x02
    3274:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    3276:	c3 e9       	ldi	r28, 0x93	; 147
    3278:	d1 e0       	ldi	r29, 0x01	; 1
    327a:	40 91 a3 01 	lds	r20, 0x01A3
    327e:	50 91 a4 01 	lds	r21, 0x01A4
    3282:	60 91 a5 01 	lds	r22, 0x01A5
    3286:	70 91 a6 01 	lds	r23, 0x01A6
    328a:	88 81       	ld	r24, Y
    328c:	99 81       	ldd	r25, Y+1	; 0x01
    328e:	aa 81       	ldd	r26, Y+2	; 0x02
    3290:	bb 81       	ldd	r27, Y+3	; 0x03
    3292:	84 0f       	add	r24, r20
    3294:	95 1f       	adc	r25, r21
    3296:	a6 1f       	adc	r26, r22
    3298:	b7 1f       	adc	r27, r23
    329a:	88 83       	st	Y, r24
    329c:	99 83       	std	Y+1, r25	; 0x01
    329e:	aa 83       	std	Y+2, r26	; 0x02
    32a0:	bb 83       	std	Y+3, r27	; 0x03
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif    
  if (st.counter_y > st.exec_block->step_event_count) {
    32a2:	45 85       	ldd	r20, Z+13	; 0x0d
    32a4:	56 85       	ldd	r21, Z+14	; 0x0e
    32a6:	67 85       	ldd	r22, Z+15	; 0x0f
    32a8:	70 89       	ldd	r23, Z+16	; 0x10
    32aa:	48 17       	cp	r20, r24
    32ac:	59 07       	cpc	r21, r25
    32ae:	6a 07       	cpc	r22, r26
    32b0:	7b 07       	cpc	r23, r27
    32b2:	98 f5       	brcc	.+102    	; 0x331a <__vector_11+0x30e>
    st.step_outbits |= (1<<Y_STEP_BIT);
    32b4:	cd e9       	ldi	r28, 0x9D	; 157
    32b6:	d1 e0       	ldi	r29, 0x01	; 1
    32b8:	28 81       	ld	r18, Y
    32ba:	28 60       	ori	r18, 0x08	; 8
    32bc:	28 83       	st	Y, r18
    st.counter_y -= st.exec_block->step_event_count;
    32be:	45 85       	ldd	r20, Z+13	; 0x0d
    32c0:	56 85       	ldd	r21, Z+14	; 0x0e
    32c2:	67 85       	ldd	r22, Z+15	; 0x0f
    32c4:	70 89       	ldd	r23, Z+16	; 0x10
    32c6:	84 1b       	sub	r24, r20
    32c8:	95 0b       	sbc	r25, r21
    32ca:	a6 0b       	sbc	r26, r22
    32cc:	b7 0b       	sbc	r27, r23
    32ce:	80 93 93 01 	sts	0x0193, r24
    32d2:	90 93 94 01 	sts	0x0194, r25
    32d6:	a0 93 95 01 	sts	0x0195, r26
    32da:	b0 93 96 01 	sts	0x0196, r27
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys.position[Y_AXIS]--; }
    32de:	80 81       	ld	r24, Z
    32e0:	86 ff       	sbrs	r24, 6
    32e2:	0e c0       	rjmp	.+28     	; 0x3300 <__vector_11+0x2f4>
    32e4:	cb e8       	ldi	r28, 0x8B	; 139
    32e6:	d5 e0       	ldi	r29, 0x05	; 5
    32e8:	88 81       	ld	r24, Y
    32ea:	99 81       	ldd	r25, Y+1	; 0x01
    32ec:	aa 81       	ldd	r26, Y+2	; 0x02
    32ee:	bb 81       	ldd	r27, Y+3	; 0x03
    32f0:	01 97       	sbiw	r24, 0x01	; 1
    32f2:	a1 09       	sbc	r26, r1
    32f4:	b1 09       	sbc	r27, r1
    32f6:	88 83       	st	Y, r24
    32f8:	99 83       	std	Y+1, r25	; 0x01
    32fa:	aa 83       	std	Y+2, r26	; 0x02
    32fc:	bb 83       	std	Y+3, r27	; 0x03
    32fe:	0d c0       	rjmp	.+26     	; 0x331a <__vector_11+0x30e>
    else { sys.position[Y_AXIS]++; }
    3300:	cb e8       	ldi	r28, 0x8B	; 139
    3302:	d5 e0       	ldi	r29, 0x05	; 5
    3304:	88 81       	ld	r24, Y
    3306:	99 81       	ldd	r25, Y+1	; 0x01
    3308:	aa 81       	ldd	r26, Y+2	; 0x02
    330a:	bb 81       	ldd	r27, Y+3	; 0x03
    330c:	01 96       	adiw	r24, 0x01	; 1
    330e:	a1 1d       	adc	r26, r1
    3310:	b1 1d       	adc	r27, r1
    3312:	88 83       	st	Y, r24
    3314:	99 83       	std	Y+1, r25	; 0x01
    3316:	aa 83       	std	Y+2, r26	; 0x02
    3318:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    331a:	c7 e9       	ldi	r28, 0x97	; 151
    331c:	d1 e0       	ldi	r29, 0x01	; 1
    331e:	40 91 a7 01 	lds	r20, 0x01A7
    3322:	50 91 a8 01 	lds	r21, 0x01A8
    3326:	60 91 a9 01 	lds	r22, 0x01A9
    332a:	70 91 aa 01 	lds	r23, 0x01AA
    332e:	88 81       	ld	r24, Y
    3330:	99 81       	ldd	r25, Y+1	; 0x01
    3332:	aa 81       	ldd	r26, Y+2	; 0x02
    3334:	bb 81       	ldd	r27, Y+3	; 0x03
    3336:	84 0f       	add	r24, r20
    3338:	95 1f       	adc	r25, r21
    333a:	a6 1f       	adc	r26, r22
    333c:	b7 1f       	adc	r27, r23
    333e:	88 83       	st	Y, r24
    3340:	99 83       	std	Y+1, r25	; 0x01
    3342:	aa 83       	std	Y+2, r26	; 0x02
    3344:	bb 83       	std	Y+3, r27	; 0x03
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif  
  if (st.counter_z > st.exec_block->step_event_count) {
    3346:	45 85       	ldd	r20, Z+13	; 0x0d
    3348:	56 85       	ldd	r21, Z+14	; 0x0e
    334a:	67 85       	ldd	r22, Z+15	; 0x0f
    334c:	70 89       	ldd	r23, Z+16	; 0x10
    334e:	48 17       	cp	r20, r24
    3350:	59 07       	cpc	r21, r25
    3352:	6a 07       	cpc	r22, r26
    3354:	7b 07       	cpc	r23, r27
    3356:	98 f5       	brcc	.+102    	; 0x33be <__vector_11+0x3b2>
    st.step_outbits |= (1<<Z_STEP_BIT);
    3358:	cd e9       	ldi	r28, 0x9D	; 157
    335a:	d1 e0       	ldi	r29, 0x01	; 1
    335c:	28 81       	ld	r18, Y
    335e:	20 61       	ori	r18, 0x10	; 16
    3360:	28 83       	st	Y, r18
    st.counter_z -= st.exec_block->step_event_count;
    3362:	45 85       	ldd	r20, Z+13	; 0x0d
    3364:	56 85       	ldd	r21, Z+14	; 0x0e
    3366:	67 85       	ldd	r22, Z+15	; 0x0f
    3368:	70 89       	ldd	r23, Z+16	; 0x10
    336a:	84 1b       	sub	r24, r20
    336c:	95 0b       	sbc	r25, r21
    336e:	a6 0b       	sbc	r26, r22
    3370:	b7 0b       	sbc	r27, r23
    3372:	80 93 97 01 	sts	0x0197, r24
    3376:	90 93 98 01 	sts	0x0198, r25
    337a:	a0 93 99 01 	sts	0x0199, r26
    337e:	b0 93 9a 01 	sts	0x019A, r27
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys.position[Z_AXIS]--; }
    3382:	80 81       	ld	r24, Z
    3384:	88 23       	and	r24, r24
    3386:	74 f4       	brge	.+28     	; 0x33a4 <__vector_11+0x398>
    3388:	ef e8       	ldi	r30, 0x8F	; 143
    338a:	f5 e0       	ldi	r31, 0x05	; 5
    338c:	80 81       	ld	r24, Z
    338e:	91 81       	ldd	r25, Z+1	; 0x01
    3390:	a2 81       	ldd	r26, Z+2	; 0x02
    3392:	b3 81       	ldd	r27, Z+3	; 0x03
    3394:	01 97       	sbiw	r24, 0x01	; 1
    3396:	a1 09       	sbc	r26, r1
    3398:	b1 09       	sbc	r27, r1
    339a:	80 83       	st	Z, r24
    339c:	91 83       	std	Z+1, r25	; 0x01
    339e:	a2 83       	std	Z+2, r26	; 0x02
    33a0:	b3 83       	std	Z+3, r27	; 0x03
    33a2:	0d c0       	rjmp	.+26     	; 0x33be <__vector_11+0x3b2>
    else { sys.position[Z_AXIS]++; }
    33a4:	ef e8       	ldi	r30, 0x8F	; 143
    33a6:	f5 e0       	ldi	r31, 0x05	; 5
    33a8:	80 81       	ld	r24, Z
    33aa:	91 81       	ldd	r25, Z+1	; 0x01
    33ac:	a2 81       	ldd	r26, Z+2	; 0x02
    33ae:	b3 81       	ldd	r27, Z+3	; 0x03
    33b0:	01 96       	adiw	r24, 0x01	; 1
    33b2:	a1 1d       	adc	r26, r1
    33b4:	b1 1d       	adc	r27, r1
    33b6:	80 83       	st	Z, r24
    33b8:	91 83       	std	Z+1, r25	; 0x01
    33ba:	a2 83       	std	Z+2, r26	; 0x02
    33bc:	b3 83       	std	Z+3, r27	; 0x03
  }  

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }   
    33be:	80 91 84 05 	lds	r24, 0x0584
    33c2:	84 30       	cpi	r24, 0x04	; 4
    33c4:	39 f4       	brne	.+14     	; 0x33d4 <__vector_11+0x3c8>
    33c6:	ed e9       	ldi	r30, 0x9D	; 157
    33c8:	f1 e0       	ldi	r31, 0x01	; 1
    33ca:	90 91 86 05 	lds	r25, 0x0586
    33ce:	80 81       	ld	r24, Z
    33d0:	89 23       	and	r24, r25
    33d2:	80 83       	st	Z, r24

  st.step_count--; // Decrement step events count 
    33d4:	eb ea       	ldi	r30, 0xAB	; 171
    33d6:	f1 e0       	ldi	r31, 0x01	; 1
    33d8:	80 81       	ld	r24, Z
    33da:	91 81       	ldd	r25, Z+1	; 0x01
    33dc:	01 97       	sbiw	r24, 0x01	; 1
    33de:	91 83       	std	Z+1, r25	; 0x01
    33e0:	80 83       	st	Z, r24
  if (st.step_count == 0) {
    33e2:	89 2b       	or	r24, r25
    33e4:	69 f4       	brne	.+26     	; 0x3400 <__vector_11+0x3f4>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    33e6:	10 92 b1 01 	sts	0x01B1, r1
    33ea:	10 92 b0 01 	sts	0x01B0, r1
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    33ee:	80 91 8e 01 	lds	r24, 0x018E
    33f2:	8f 5f       	subi	r24, 0xFF	; 255
    33f4:	80 93 8e 01 	sts	0x018E, r24
    33f8:	86 30       	cpi	r24, 0x06	; 6
    33fa:	11 f4       	brne	.+4      	; 0x3400 <__vector_11+0x3f4>
    33fc:	10 92 8e 01 	sts	0x018E, r1
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask    
    3400:	ed e9       	ldi	r30, 0x9D	; 157
    3402:	f1 e0       	ldi	r31, 0x01	; 1
    3404:	90 91 8b 01 	lds	r25, 0x018B
    3408:	80 81       	ld	r24, Z
    340a:	89 27       	eor	r24, r25
    340c:	80 83       	st	Z, r24
  busy = false;
    340e:	10 92 89 01 	sts	0x0189, r1
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
}
    3412:	ff 91       	pop	r31
    3414:	ef 91       	pop	r30
    3416:	df 91       	pop	r29
    3418:	cf 91       	pop	r28
    341a:	bf 91       	pop	r27
    341c:	af 91       	pop	r26
    341e:	9f 91       	pop	r25
    3420:	8f 91       	pop	r24
    3422:	7f 91       	pop	r23
    3424:	6f 91       	pop	r22
    3426:	5f 91       	pop	r21
    3428:	4f 91       	pop	r20
    342a:	3f 91       	pop	r19
    342c:	2f 91       	pop	r18
    342e:	0f 90       	pop	r0
    3430:	0f be       	out	0x3f, r0	; 63
    3432:	0f 90       	pop	r0
    3434:	1f 90       	pop	r1
    3436:	18 95       	reti

00003438 <__vector_16>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) 
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    3438:	1f 92       	push	r1
    343a:	0f 92       	push	r0
    343c:	0f b6       	in	r0, 0x3f	; 63
    343e:	0f 92       	push	r0
    3440:	11 24       	eor	r1, r1
    3442:	8f 93       	push	r24
    3444:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK); 
    3446:	8b b1       	in	r24, 0x0b	; 11
    3448:	90 91 8b 01 	lds	r25, 0x018B
    344c:	9c 71       	andi	r25, 0x1C	; 28
    344e:	83 7e       	andi	r24, 0xE3	; 227
    3450:	89 2b       	or	r24, r25
    3452:	8b b9       	out	0x0b, r24	; 11
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed. 
    3454:	15 bc       	out	0x25, r1	; 37
}
    3456:	9f 91       	pop	r25
    3458:	8f 91       	pop	r24
    345a:	0f 90       	pop	r0
    345c:	0f be       	out	0x3f, r0	; 63
    345e:	0f 90       	pop	r0
    3460:	1f 90       	pop	r1
    3462:	18 95       	reti

00003464 <st_reset>:
#endif


// Reset and clear stepper subsystem variables
void st_reset()
{
    3464:	cf 92       	push	r12
    3466:	df 92       	push	r13
    3468:	ef 92       	push	r14
    346a:	ff 92       	push	r15
    346c:	0f 93       	push	r16
    346e:	1f 93       	push	r17
    3470:	cf 93       	push	r28
    3472:	df 93       	push	r29
  // Initialize stepper driver idle state.
  st_go_idle();
    3474:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <st_go_idle>
  
  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(prep));
    3478:	8b e2       	ldi	r24, 0x2B	; 43
    347a:	ea e5       	ldi	r30, 0x5A	; 90
    347c:	f1 e0       	ldi	r31, 0x01	; 1
    347e:	df 01       	movw	r26, r30
    3480:	1d 92       	st	X+, r1
    3482:	8a 95       	dec	r24
    3484:	e9 f7       	brne	.-6      	; 0x3480 <st_reset+0x1c>
  memset(&st, 0, sizeof(st));
    3486:	83 e2       	ldi	r24, 0x23	; 35
    3488:	ef e8       	ldi	r30, 0x8F	; 143
    348a:	f1 e0       	ldi	r31, 0x01	; 1
    348c:	df 01       	movw	r26, r30
    348e:	1d 92       	st	X+, r1
    3490:	8a 95       	dec	r24
    3492:	e9 f7       	brne	.-6      	; 0x348e <st_reset+0x2a>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    3494:	10 92 88 01 	sts	0x0188, r1
    3498:	10 92 87 01 	sts	0x0187, r1
  segment_buffer_tail = 0;
    349c:	10 92 8e 01 	sts	0x018E, r1
  segment_buffer_head = 0; // empty = tail
    34a0:	10 92 8d 01 	sts	0x018D, r1
  segment_next_head = 1;
    34a4:	81 e0       	ldi	r24, 0x01	; 1
    34a6:	80 93 8c 01 	sts	0x018C, r24
  busy = false;
    34aa:	10 92 89 01 	sts	0x0189, r1
  
  // Setup step and direction port invert masks.
  uint8_t idx;
  step_port_invert_mask = 0;
    34ae:	10 92 8b 01 	sts	0x018B, r1
  dir_port_invert_mask = 0;
    34b2:	10 92 8a 01 	sts	0x018A, r1
    34b6:	c0 e0       	ldi	r28, 0x00	; 0
    34b8:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    34ba:	0f 2e       	mov	r0, r31
    34bc:	f1 e7       	ldi	r31, 0x71	; 113
    34be:	ef 2e       	mov	r14, r31
    34c0:	f7 e0       	ldi	r31, 0x07	; 7
    34c2:	ff 2e       	mov	r15, r31
    34c4:	f0 2d       	mov	r31, r0
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    34c6:	02 e7       	ldi	r16, 0x72	; 114
    34c8:	17 e0       	ldi	r17, 0x07	; 7
    34ca:	cc 2e       	mov	r12, r28
  // Setup step and direction port invert masks.
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    34cc:	dc 2e       	mov	r13, r28
    34ce:	f7 01       	movw	r30, r14
    34d0:	40 81       	ld	r20, Z
    34d2:	50 e0       	ldi	r21, 0x00	; 0
    34d4:	0c 2e       	mov	r0, r28
    34d6:	02 c0       	rjmp	.+4      	; 0x34dc <st_reset+0x78>
    34d8:	55 95       	asr	r21
    34da:	47 95       	ror	r20
    34dc:	0a 94       	dec	r0
    34de:	e2 f7       	brpl	.-8      	; 0x34d8 <st_reset+0x74>
    34e0:	40 ff       	sbrs	r20, 0
    34e2:	08 c0       	rjmp	.+16     	; 0x34f4 <st_reset+0x90>
    34e4:	8c 2f       	mov	r24, r28
    34e6:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <get_step_pin_mask>
    34ea:	90 91 8b 01 	lds	r25, 0x018B
    34ee:	89 2b       	or	r24, r25
    34f0:	80 93 8b 01 	sts	0x018B, r24
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    34f4:	d8 01       	movw	r26, r16
    34f6:	2c 91       	ld	r18, X
    34f8:	30 e0       	ldi	r19, 0x00	; 0
    34fa:	02 c0       	rjmp	.+4      	; 0x3500 <st_reset+0x9c>
    34fc:	35 95       	asr	r19
    34fe:	27 95       	ror	r18
    3500:	da 94       	dec	r13
    3502:	e2 f7       	brpl	.-8      	; 0x34fc <st_reset+0x98>
    3504:	20 ff       	sbrs	r18, 0
    3506:	08 c0       	rjmp	.+16     	; 0x3518 <st_reset+0xb4>
    3508:	8c 2d       	mov	r24, r12
    350a:	0e 94 55 25 	call	0x4aaa	; 0x4aaa <get_direction_pin_mask>
    350e:	90 91 8a 01 	lds	r25, 0x018A
    3512:	89 2b       	or	r24, r25
    3514:	80 93 8a 01 	sts	0x018A, r24
    3518:	21 96       	adiw	r28, 0x01	; 1
  
  // Setup step and direction port invert masks.
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    351a:	c3 30       	cpi	r28, 0x03	; 3
    351c:	d1 05       	cpc	r29, r1
    351e:	a9 f6       	brne	.-86     	; 0x34ca <st_reset+0x66>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
  }
      
  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    3520:	8b b1       	in	r24, 0x0b	; 11
    3522:	83 7e       	andi	r24, 0xE3	; 227
    3524:	90 91 8b 01 	lds	r25, 0x018B
    3528:	89 2b       	or	r24, r25
    352a:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    352c:	8b b1       	in	r24, 0x0b	; 11
    352e:	8f 71       	andi	r24, 0x1F	; 31
    3530:	90 91 8a 01 	lds	r25, 0x018A
    3534:	89 2b       	or	r24, r25
    3536:	8b b9       	out	0x0b, r24	; 11
}
    3538:	df 91       	pop	r29
    353a:	cf 91       	pop	r28
    353c:	1f 91       	pop	r17
    353e:	0f 91       	pop	r16
    3540:	ff 90       	pop	r15
    3542:	ef 90       	pop	r14
    3544:	df 90       	pop	r13
    3546:	cf 90       	pop	r12
    3548:	08 95       	ret

0000354a <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    354a:	8a b1       	in	r24, 0x0a	; 10
    354c:	8c 61       	ori	r24, 0x1C	; 28
    354e:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    3550:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    3552:	8a b1       	in	r24, 0x0a	; 10
    3554:	80 6e       	ori	r24, 0xE0	; 224
    3556:	8a b9       	out	0x0a, r24	; 10

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    3558:	e1 e8       	ldi	r30, 0x81	; 129
    355a:	f0 e0       	ldi	r31, 0x00	; 0
    355c:	80 81       	ld	r24, Z
    355e:	8f 7e       	andi	r24, 0xEF	; 239
    3560:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    3562:	80 81       	ld	r24, Z
    3564:	88 60       	ori	r24, 0x08	; 8
    3566:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10)); 
    3568:	e0 e8       	ldi	r30, 0x80	; 128
    356a:	f0 e0       	ldi	r31, 0x00	; 0
    356c:	80 81       	ld	r24, Z
    356e:	8c 7f       	andi	r24, 0xFC	; 252
    3570:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    3572:	80 81       	ld	r24, Z
    3574:	8f 70       	andi	r24, 0x0F	; 15
    3576:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().
  
  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    3578:	ee e6       	ldi	r30, 0x6E	; 110
    357a:	f0 e0       	ldi	r31, 0x00	; 0
    357c:	80 81       	ld	r24, Z
    357e:	88 7f       	andi	r24, 0xF8	; 248
    3580:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    3582:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    3584:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    3586:	80 81       	ld	r24, Z
    3588:	81 60       	ori	r24, 0x01	; 1
    358a:	80 83       	st	Z, r24
    358c:	08 95       	ret

0000358e <st_update_plan_block_parameters>:
}
  

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{ 
    358e:	cf 93       	push	r28
    3590:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    3592:	c0 91 87 01 	lds	r28, 0x0187
    3596:	d0 91 88 01 	lds	r29, 0x0188
    359a:	20 97       	sbiw	r28, 0x00	; 0
    359c:	b9 f0       	breq	.+46     	; 0x35cc <st_update_plan_block_parameters+0x3e>
    prep.flag_partial_block = true;
    359e:	81 e0       	ldi	r24, 0x01	; 1
    35a0:	80 93 5b 01 	sts	0x015B, r24
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    35a4:	60 91 71 01 	lds	r22, 0x0171
    35a8:	70 91 72 01 	lds	r23, 0x0172
    35ac:	80 91 73 01 	lds	r24, 0x0173
    35b0:	90 91 74 01 	lds	r25, 0x0174
    35b4:	9b 01       	movw	r18, r22
    35b6:	ac 01       	movw	r20, r24
    35b8:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    35bc:	69 8b       	std	Y+17, r22	; 0x11
    35be:	7a 8b       	std	Y+18, r23	; 0x12
    35c0:	8b 8b       	std	Y+19, r24	; 0x13
    35c2:	9c 8b       	std	Y+20, r25	; 0x14
    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.
    35c4:	10 92 88 01 	sts	0x0188, r1
    35c8:	10 92 87 01 	sts	0x0187, r1
  }
}
    35cc:	df 91       	pop	r29
    35ce:	cf 91       	pop	r28
    35d0:	08 95       	ret

000035d2 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it. 
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    35d2:	2f 92       	push	r2
    35d4:	3f 92       	push	r3
    35d6:	4f 92       	push	r4
    35d8:	5f 92       	push	r5
    35da:	6f 92       	push	r6
    35dc:	7f 92       	push	r7
    35de:	8f 92       	push	r8
    35e0:	9f 92       	push	r9
    35e2:	af 92       	push	r10
    35e4:	bf 92       	push	r11
    35e6:	cf 92       	push	r12
    35e8:	df 92       	push	r13
    35ea:	ef 92       	push	r14
    35ec:	ff 92       	push	r15
    35ee:	0f 93       	push	r16
    35f0:	1f 93       	push	r17
    35f2:	cf 93       	push	r28
    35f4:	df 93       	push	r29
    35f6:	cd b7       	in	r28, 0x3d	; 61
    35f8:	de b7       	in	r29, 0x3e	; 62
    35fa:	e6 97       	sbiw	r28, 0x36	; 54
    35fc:	0f b6       	in	r0, 0x3f	; 63
    35fe:	f8 94       	cli
    3600:	de bf       	out	0x3e, r29	; 62
    3602:	0f be       	out	0x3f, r0	; 63
    3604:	cd bf       	out	0x3d, r28	; 61
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    3606:	64 c6       	rjmp	.+3272   	; 0x42d0 <st_prep_buffer+0xcfe>

    // Determine if we need to load a new planner block or if the block has been replanned. 
    if (pl_block == NULL) {
    3608:	80 91 87 01 	lds	r24, 0x0187
    360c:	90 91 88 01 	lds	r25, 0x0188
    3610:	89 2b       	or	r24, r25
    3612:	09 f0       	breq	.+2      	; 0x3616 <st_prep_buffer+0x44>
    3614:	6c c2       	rjmp	.+1240   	; 0x3aee <st_prep_buffer+0x51c>
      pl_block = plan_get_current_block(); // Query planner for a queued block
    3616:	0e 94 c1 26 	call	0x4d82	; 0x4d82 <plan_get_current_block>
    361a:	8c 01       	movw	r16, r24
    361c:	90 93 88 01 	sts	0x0188, r25
    3620:	80 93 87 01 	sts	0x0187, r24
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    3624:	00 97       	sbiw	r24, 0x00	; 0
    3626:	09 f4       	brne	.+2      	; 0x362a <st_prep_buffer+0x58>
    3628:	59 c6       	rjmp	.+3250   	; 0x42dc <st_prep_buffer+0xd0a>
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    362a:	ab e5       	ldi	r26, 0x5B	; 91
    362c:	b1 e0       	ldi	r27, 0x01	; 1
    362e:	8c 91       	ld	r24, X
    3630:	88 23       	and	r24, r24
    3632:	11 f0       	breq	.+4      	; 0x3638 <st_prep_buffer+0x66>
        prep.flag_partial_block = false; // Reset flag
    3634:	1c 92       	st	X, r1
    3636:	dc c0       	rjmp	.+440    	; 0x37f0 <st_prep_buffer+0x21e>
      } else {
        // Increment stepper common data index to store new planner block data. 
        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
    3638:	ea e5       	ldi	r30, 0x5A	; 90
    363a:	f1 e0       	ldi	r31, 0x01	; 1
    363c:	80 81       	ld	r24, Z
    363e:	8f 5f       	subi	r24, 0xFF	; 255
    3640:	85 30       	cpi	r24, 0x05	; 5
    3642:	11 f0       	breq	.+4      	; 0x3648 <st_prep_buffer+0x76>
    3644:	80 83       	st	Z, r24
    3646:	03 c0       	rjmp	.+6      	; 0x364e <st_prep_buffer+0x7c>
    3648:	aa e5       	ldi	r26, 0x5A	; 90
    364a:	b1 e0       	ldi	r27, 0x01	; 1
    364c:	1c 92       	st	X, r1
        
        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the 
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. 
        st_prep_block = &st_block_buffer[prep.st_block_index];
    364e:	aa e5       	ldi	r26, 0x5A	; 90
    3650:	b1 e0       	ldi	r27, 0x01	; 1
    3652:	ec 91       	ld	r30, X
    3654:	b1 e1       	ldi	r27, 0x11	; 17
    3656:	eb 9f       	mul	r30, r27
    3658:	f0 01       	movw	r30, r0
    365a:	11 24       	eor	r1, r1
    365c:	ea 52       	subi	r30, 0x2A	; 42
    365e:	fe 4f       	sbci	r31, 0xFE	; 254
    3660:	f0 93 86 01 	sts	0x0186, r31
    3664:	e0 93 85 01 	sts	0x0185, r30
        st_prep_block->direction_bits = pl_block->direction_bits;
    3668:	d8 01       	movw	r26, r16
    366a:	8c 91       	ld	r24, X
    366c:	80 83       	st	Z, r24
          st_prep_block->step_event_count = pl_block->step_event_count;
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS 
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS] << MAX_AMASS_LEVEL;
    366e:	11 96       	adiw	r26, 0x01	; 1
    3670:	4d 91       	ld	r20, X+
    3672:	5d 91       	ld	r21, X+
    3674:	6d 91       	ld	r22, X+
    3676:	7c 91       	ld	r23, X
    3678:	14 97       	sbiw	r26, 0x04	; 4
    367a:	db 01       	movw	r26, r22
    367c:	ca 01       	movw	r24, r20
    367e:	88 0f       	add	r24, r24
    3680:	99 1f       	adc	r25, r25
    3682:	aa 1f       	adc	r26, r26
    3684:	bb 1f       	adc	r27, r27
    3686:	88 0f       	add	r24, r24
    3688:	99 1f       	adc	r25, r25
    368a:	aa 1f       	adc	r26, r26
    368c:	bb 1f       	adc	r27, r27
    368e:	88 0f       	add	r24, r24
    3690:	99 1f       	adc	r25, r25
    3692:	aa 1f       	adc	r26, r26
    3694:	bb 1f       	adc	r27, r27
    3696:	81 83       	std	Z+1, r24	; 0x01
    3698:	92 83       	std	Z+2, r25	; 0x02
    369a:	a3 83       	std	Z+3, r26	; 0x03
    369c:	b4 83       	std	Z+4, r27	; 0x04
          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS] << MAX_AMASS_LEVEL;
    369e:	d8 01       	movw	r26, r16
    36a0:	15 96       	adiw	r26, 0x05	; 5
    36a2:	4d 91       	ld	r20, X+
    36a4:	5d 91       	ld	r21, X+
    36a6:	6d 91       	ld	r22, X+
    36a8:	7c 91       	ld	r23, X
    36aa:	18 97       	sbiw	r26, 0x08	; 8
    36ac:	db 01       	movw	r26, r22
    36ae:	ca 01       	movw	r24, r20
    36b0:	88 0f       	add	r24, r24
    36b2:	99 1f       	adc	r25, r25
    36b4:	aa 1f       	adc	r26, r26
    36b6:	bb 1f       	adc	r27, r27
    36b8:	88 0f       	add	r24, r24
    36ba:	99 1f       	adc	r25, r25
    36bc:	aa 1f       	adc	r26, r26
    36be:	bb 1f       	adc	r27, r27
    36c0:	88 0f       	add	r24, r24
    36c2:	99 1f       	adc	r25, r25
    36c4:	aa 1f       	adc	r26, r26
    36c6:	bb 1f       	adc	r27, r27
    36c8:	85 83       	std	Z+5, r24	; 0x05
    36ca:	96 83       	std	Z+6, r25	; 0x06
    36cc:	a7 83       	std	Z+7, r26	; 0x07
    36ce:	b0 87       	std	Z+8, r27	; 0x08
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;
    36d0:	d8 01       	movw	r26, r16
    36d2:	19 96       	adiw	r26, 0x09	; 9
    36d4:	4d 91       	ld	r20, X+
    36d6:	5d 91       	ld	r21, X+
    36d8:	6d 91       	ld	r22, X+
    36da:	7c 91       	ld	r23, X
    36dc:	1c 97       	sbiw	r26, 0x0c	; 12
    36de:	db 01       	movw	r26, r22
    36e0:	ca 01       	movw	r24, r20
    36e2:	88 0f       	add	r24, r24
    36e4:	99 1f       	adc	r25, r25
    36e6:	aa 1f       	adc	r26, r26
    36e8:	bb 1f       	adc	r27, r27
    36ea:	88 0f       	add	r24, r24
    36ec:	99 1f       	adc	r25, r25
    36ee:	aa 1f       	adc	r26, r26
    36f0:	bb 1f       	adc	r27, r27
    36f2:	88 0f       	add	r24, r24
    36f4:	99 1f       	adc	r25, r25
    36f6:	aa 1f       	adc	r26, r26
    36f8:	bb 1f       	adc	r27, r27
    36fa:	81 87       	std	Z+9, r24	; 0x09
    36fc:	92 87       	std	Z+10, r25	; 0x0a
    36fe:	a3 87       	std	Z+11, r26	; 0x0b
    3700:	b4 87       	std	Z+12, r27	; 0x0c
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    3702:	d8 01       	movw	r26, r16
    3704:	1d 96       	adiw	r26, 0x0d	; 13
    3706:	4d 91       	ld	r20, X+
    3708:	5d 91       	ld	r21, X+
    370a:	6d 91       	ld	r22, X+
    370c:	7c 91       	ld	r23, X
    370e:	50 97       	sbiw	r26, 0x10	; 16
    3710:	44 0f       	add	r20, r20
    3712:	55 1f       	adc	r21, r21
    3714:	66 1f       	adc	r22, r22
    3716:	77 1f       	adc	r23, r23
    3718:	44 0f       	add	r20, r20
    371a:	55 1f       	adc	r21, r21
    371c:	66 1f       	adc	r22, r22
    371e:	77 1f       	adc	r23, r23
    3720:	44 0f       	add	r20, r20
    3722:	55 1f       	adc	r21, r21
    3724:	66 1f       	adc	r22, r22
    3726:	77 1f       	adc	r23, r23
    3728:	45 87       	std	Z+13, r20	; 0x0d
    372a:	56 87       	std	Z+14, r21	; 0x0e
    372c:	67 87       	std	Z+15, r22	; 0x0f
    372e:	70 8b       	std	Z+16, r23	; 0x10
        #endif
        
        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = pl_block->step_event_count;
    3730:	1d 96       	adiw	r26, 0x0d	; 13
    3732:	6d 91       	ld	r22, X+
    3734:	7d 91       	ld	r23, X+
    3736:	8d 91       	ld	r24, X+
    3738:	9c 91       	ld	r25, X
    373a:	50 97       	sbiw	r26, 0x10	; 16
    373c:	0e 94 fc 39 	call	0x73f8	; 0x73f8 <__floatunsisf>
    3740:	ec e5       	ldi	r30, 0x5C	; 92
    3742:	f1 e0       	ldi	r31, 0x01	; 1
    3744:	60 83       	st	Z, r22
    3746:	71 83       	std	Z+1, r23	; 0x01
    3748:	82 83       	std	Z+2, r24	; 0x02
    374a:	93 83       	std	Z+3, r25	; 0x03
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    374c:	d8 01       	movw	r26, r16
    374e:	95 96       	adiw	r26, 0x25	; 37
    3750:	2d 91       	ld	r18, X+
    3752:	3d 91       	ld	r19, X+
    3754:	4d 91       	ld	r20, X+
    3756:	5c 91       	ld	r21, X
    3758:	98 97       	sbiw	r26, 0x28	; 40
    375a:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    375e:	9b 01       	movw	r18, r22
    3760:	ac 01       	movw	r20, r24
    3762:	e0 e6       	ldi	r30, 0x60	; 96
    3764:	f1 e0       	ldi	r31, 0x01	; 1
    3766:	60 83       	st	Z, r22
    3768:	71 83       	std	Z+1, r23	; 0x01
    376a:	82 83       	std	Z+2, r24	; 0x02
    376c:	93 83       	std	Z+3, r25	; 0x03
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    376e:	60 e0       	ldi	r22, 0x00	; 0
    3770:	70 e0       	ldi	r23, 0x00	; 0
    3772:	80 ea       	ldi	r24, 0xA0	; 160
    3774:	9f e3       	ldi	r25, 0x3F	; 63
    3776:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    377a:	60 93 64 01 	sts	0x0164, r22
    377e:	70 93 65 01 	sts	0x0165, r23
    3782:	80 93 66 01 	sts	0x0166, r24
    3786:	90 93 67 01 	sts	0x0167, r25
        
        prep.dt_remainder = 0.0; // Reset for new planner block
    378a:	10 92 68 01 	sts	0x0168, r1
    378e:	10 92 69 01 	sts	0x0169, r1
    3792:	10 92 6a 01 	sts	0x016A, r1
    3796:	10 92 6b 01 	sts	0x016B, r1

        if (sys.state == STATE_HOLD) {
    379a:	a4 e8       	ldi	r26, 0x84	; 132
    379c:	b5 e0       	ldi	r27, 0x05	; 5
    379e:	8c 91       	ld	r24, X
    37a0:	80 32       	cpi	r24, 0x20	; 32
    37a2:	b9 f4       	brne	.+46     	; 0x37d2 <st_prep_buffer+0x200>
          // Override planner block entry speed and enforce deceleration during feed hold.
          prep.current_speed = prep.exit_speed; 
    37a4:	e9 e7       	ldi	r30, 0x79	; 121
    37a6:	f1 e0       	ldi	r31, 0x01	; 1
    37a8:	60 81       	ld	r22, Z
    37aa:	71 81       	ldd	r23, Z+1	; 0x01
    37ac:	82 81       	ldd	r24, Z+2	; 0x02
    37ae:	93 81       	ldd	r25, Z+3	; 0x03
    37b0:	a1 e7       	ldi	r26, 0x71	; 113
    37b2:	b1 e0       	ldi	r27, 0x01	; 1
    37b4:	6d 93       	st	X+, r22
    37b6:	7d 93       	st	X+, r23
    37b8:	8d 93       	st	X+, r24
    37ba:	9c 93       	st	X, r25
    37bc:	13 97       	sbiw	r26, 0x03	; 3
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; 
    37be:	9b 01       	movw	r18, r22
    37c0:	ac 01       	movw	r20, r24
    37c2:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    37c6:	f8 01       	movw	r30, r16
    37c8:	61 8b       	std	Z+17, r22	; 0x11
    37ca:	72 8b       	std	Z+18, r23	; 0x12
    37cc:	83 8b       	std	Z+19, r24	; 0x13
    37ce:	94 8b       	std	Z+20, r25	; 0x14
    37d0:	0f c0       	rjmp	.+30     	; 0x37f0 <st_prep_buffer+0x21e>
        }
        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }
    37d2:	d8 01       	movw	r26, r16
    37d4:	51 96       	adiw	r26, 0x11	; 17
    37d6:	6d 91       	ld	r22, X+
    37d8:	7d 91       	ld	r23, X+
    37da:	8d 91       	ld	r24, X+
    37dc:	9c 91       	ld	r25, X
    37de:	54 97       	sbiw	r26, 0x14	; 20
    37e0:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    37e4:	e1 e7       	ldi	r30, 0x71	; 113
    37e6:	f1 e0       	ldi	r31, 0x01	; 1
    37e8:	60 83       	st	Z, r22
    37ea:	71 83       	std	Z+1, r23	; 0x01
    37ec:	82 83       	std	Z+2, r24	; 0x02
    37ee:	93 83       	std	Z+3, r25	; 0x03
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
      */
      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    37f0:	ad e6       	ldi	r26, 0x6D	; 109
    37f2:	b1 e0       	ldi	r27, 0x01	; 1
    37f4:	1d 92       	st	X+, r1
    37f6:	1d 92       	st	X+, r1
    37f8:	1d 92       	st	X+, r1
    37fa:	1c 92       	st	X, r1
    37fc:	13 97       	sbiw	r26, 0x03	; 3
      float inv_2_accel = 0.5/pl_block->acceleration;
    37fe:	00 91 87 01 	lds	r16, 0x0187
    3802:	10 91 88 01 	lds	r17, 0x0188
    3806:	f8 01       	movw	r30, r16
    3808:	c1 a0       	ldd	r12, Z+33	; 0x21
    380a:	d2 a0       	ldd	r13, Z+34	; 0x22
    380c:	e3 a0       	ldd	r14, Z+35	; 0x23
    380e:	f4 a0       	ldd	r15, Z+36	; 0x24
    3810:	a7 01       	movw	r20, r14
    3812:	96 01       	movw	r18, r12
    3814:	60 e0       	ldi	r22, 0x00	; 0
    3816:	70 e0       	ldi	r23, 0x00	; 0
    3818:	80 e0       	ldi	r24, 0x00	; 0
    381a:	9f e3       	ldi	r25, 0x3F	; 63
    381c:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    3820:	2b 01       	movw	r4, r22
    3822:	3c 01       	movw	r6, r24
      if (sys.state == STATE_HOLD) { // [Forced Deceleration to Zero Velocity]
    3824:	a4 e8       	ldi	r26, 0x84	; 132
    3826:	b5 e0       	ldi	r27, 0x05	; 5
    3828:	8c 91       	ld	r24, X
    382a:	80 32       	cpi	r24, 0x20	; 32
    382c:	09 f0       	breq	.+2      	; 0x3830 <st_prep_buffer+0x25e>
    382e:	57 c0       	rjmp	.+174    	; 0x38de <st_prep_buffer+0x30c>
        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
        // the planner block profile, enforcing a deceleration to zero speed.
        prep.ramp_type = RAMP_DECEL;
    3830:	82 e0       	ldi	r24, 0x02	; 2
    3832:	ec e6       	ldi	r30, 0x6C	; 108
    3834:	f1 e0       	ldi	r31, 0x01	; 1
    3836:	80 83       	st	Z, r24
        // Compute decelerate distance relative to end of block.
        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    3838:	d8 01       	movw	r26, r16
    383a:	95 96       	adiw	r26, 0x25	; 37
    383c:	8d 90       	ld	r8, X+
    383e:	9d 90       	ld	r9, X+
    3840:	ad 90       	ld	r10, X+
    3842:	bc 90       	ld	r11, X
    3844:	98 97       	sbiw	r26, 0x28	; 40
    3846:	51 96       	adiw	r26, 0x11	; 17
    3848:	2d 91       	ld	r18, X+
    384a:	3d 91       	ld	r19, X+
    384c:	4d 91       	ld	r20, X+
    384e:	5c 91       	ld	r21, X
    3850:	54 97       	sbiw	r26, 0x14	; 20
    3852:	29 83       	std	Y+1, r18	; 0x01
    3854:	3a 83       	std	Y+2, r19	; 0x02
    3856:	4b 83       	std	Y+3, r20	; 0x03
    3858:	5c 83       	std	Y+4, r21	; 0x04
    385a:	a3 01       	movw	r20, r6
    385c:	92 01       	movw	r18, r4
    385e:	69 81       	ldd	r22, Y+1	; 0x01
    3860:	7a 81       	ldd	r23, Y+2	; 0x02
    3862:	8b 81       	ldd	r24, Y+3	; 0x03
    3864:	9c 81       	ldd	r25, Y+4	; 0x04
    3866:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    386a:	9b 01       	movw	r18, r22
    386c:	ac 01       	movw	r20, r24
    386e:	c5 01       	movw	r24, r10
    3870:	b4 01       	movw	r22, r8
    3872:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3876:	2b 01       	movw	r4, r22
    3878:	3c 01       	movw	r6, r24
        if (decel_dist < 0.0) {
    387a:	20 e0       	ldi	r18, 0x00	; 0
    387c:	30 e0       	ldi	r19, 0x00	; 0
    387e:	a9 01       	movw	r20, r18
    3880:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    3884:	88 23       	and	r24, r24
    3886:	ec f4       	brge	.+58     	; 0x38c2 <st_prep_buffer+0x2f0>
          // Deceleration through entire planner block. End of feed hold is not in this block.
          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3888:	a7 01       	movw	r20, r14
    388a:	96 01       	movw	r18, r12
    388c:	c7 01       	movw	r24, r14
    388e:	b6 01       	movw	r22, r12
    3890:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3894:	9b 01       	movw	r18, r22
    3896:	ac 01       	movw	r20, r24
    3898:	c5 01       	movw	r24, r10
    389a:	b4 01       	movw	r22, r8
    389c:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    38a0:	9b 01       	movw	r18, r22
    38a2:	ac 01       	movw	r20, r24
    38a4:	69 81       	ldd	r22, Y+1	; 0x01
    38a6:	7a 81       	ldd	r23, Y+2	; 0x02
    38a8:	8b 81       	ldd	r24, Y+3	; 0x03
    38aa:	9c 81       	ldd	r25, Y+4	; 0x04
    38ac:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    38b0:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    38b4:	e9 e7       	ldi	r30, 0x79	; 121
    38b6:	f1 e0       	ldi	r31, 0x01	; 1
    38b8:	60 83       	st	Z, r22
    38ba:	71 83       	std	Z+1, r23	; 0x01
    38bc:	82 83       	std	Z+2, r24	; 0x02
    38be:	93 83       	std	Z+3, r25	; 0x03
    38c0:	16 c1       	rjmp	.+556    	; 0x3aee <st_prep_buffer+0x51c>
        } else {
          prep.mm_complete = decel_dist; // End of feed hold.
    38c2:	ad e6       	ldi	r26, 0x6D	; 109
    38c4:	b1 e0       	ldi	r27, 0x01	; 1
    38c6:	4d 92       	st	X+, r4
    38c8:	5d 92       	st	X+, r5
    38ca:	6d 92       	st	X+, r6
    38cc:	7c 92       	st	X, r7
    38ce:	13 97       	sbiw	r26, 0x03	; 3
          prep.exit_speed = 0.0;
    38d0:	e9 e7       	ldi	r30, 0x79	; 121
    38d2:	f1 e0       	ldi	r31, 0x01	; 1
    38d4:	10 82       	st	Z, r1
    38d6:	11 82       	std	Z+1, r1	; 0x01
    38d8:	12 82       	std	Z+2, r1	; 0x02
    38da:	13 82       	std	Z+3, r1	; 0x03
    38dc:	08 c1       	rjmp	.+528    	; 0x3aee <st_prep_buffer+0x51c>
        }
      } else { // [Normal Operation]
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    38de:	ac e6       	ldi	r26, 0x6C	; 108
    38e0:	b1 e0       	ldi	r27, 0x01	; 1
    38e2:	1c 92       	st	X, r1
        prep.accelerate_until = pl_block->millimeters; 
    38e4:	f8 01       	movw	r30, r16
    38e6:	85 a1       	ldd	r24, Z+37	; 0x25
    38e8:	96 a1       	ldd	r25, Z+38	; 0x26
    38ea:	a7 a1       	ldd	r26, Z+39	; 0x27
    38ec:	b0 a5       	ldd	r27, Z+40	; 0x28
    38ee:	ed e7       	ldi	r30, 0x7D	; 125
    38f0:	f1 e0       	ldi	r31, 0x01	; 1
    38f2:	80 83       	st	Z, r24
    38f4:	91 83       	std	Z+1, r25	; 0x01
    38f6:	a2 83       	std	Z+2, r26	; 0x02
    38f8:	b3 83       	std	Z+3, r27	; 0x03
        prep.exit_speed = plan_get_exec_block_exit_speed();   
    38fa:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <plan_get_exec_block_exit_speed>
    38fe:	6b 01       	movw	r12, r22
    3900:	7c 01       	movw	r14, r24
    3902:	a9 e7       	ldi	r26, 0x79	; 121
    3904:	b1 e0       	ldi	r27, 0x01	; 1
    3906:	6d 93       	st	X+, r22
    3908:	7d 93       	st	X+, r23
    390a:	8d 93       	st	X+, r24
    390c:	9c 93       	st	X, r25
    390e:	13 97       	sbiw	r26, 0x03	; 3
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
    3910:	9b 01       	movw	r18, r22
    3912:	ac 01       	movw	r20, r24
    3914:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3918:	69 83       	std	Y+1, r22	; 0x01
    391a:	7a 83       	std	Y+2, r23	; 0x02
    391c:	8b 83       	std	Y+3, r24	; 0x03
    391e:	9c 83       	std	Y+4, r25	; 0x04
        float intersect_distance =
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    3920:	00 91 87 01 	lds	r16, 0x0187
    3924:	10 91 88 01 	lds	r17, 0x0188
    3928:	d8 01       	movw	r26, r16
    392a:	95 96       	adiw	r26, 0x25	; 37
    392c:	2d 91       	ld	r18, X+
    392e:	3d 91       	ld	r19, X+
    3930:	4d 91       	ld	r20, X+
    3932:	5c 91       	ld	r21, X
    3934:	98 97       	sbiw	r26, 0x28	; 40
    3936:	2d 83       	std	Y+5, r18	; 0x05
    3938:	3e 83       	std	Y+6, r19	; 0x06
    393a:	4f 83       	std	Y+7, r20	; 0x07
    393c:	58 87       	std	Y+8, r21	; 0x08
    393e:	9b 01       	movw	r18, r22
    3940:	ac 01       	movw	r20, r24
    3942:	51 96       	adiw	r26, 0x11	; 17
    3944:	6d 91       	ld	r22, X+
    3946:	7d 91       	ld	r23, X+
    3948:	8d 91       	ld	r24, X+
    394a:	9c 91       	ld	r25, X
    394c:	54 97       	sbiw	r26, 0x14	; 20
    394e:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3952:	a3 01       	movw	r20, r6
    3954:	92 01       	movw	r18, r4
    3956:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    395a:	9b 01       	movw	r18, r22
    395c:	ac 01       	movw	r20, r24
    395e:	6d 81       	ldd	r22, Y+5	; 0x05
    3960:	7e 81       	ldd	r23, Y+6	; 0x06
    3962:	8f 81       	ldd	r24, Y+7	; 0x07
    3964:	98 85       	ldd	r25, Y+8	; 0x08
    3966:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
        prep.accelerate_until = pl_block->millimeters; 
        prep.exit_speed = plan_get_exec_block_exit_speed();   
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
        float intersect_distance =
    396a:	20 e0       	ldi	r18, 0x00	; 0
    396c:	30 e0       	ldi	r19, 0x00	; 0
    396e:	40 e0       	ldi	r20, 0x00	; 0
    3970:	5f e3       	ldi	r21, 0x3F	; 63
    3972:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3976:	4b 01       	movw	r8, r22
    3978:	5c 01       	movw	r10, r24
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
        if (intersect_distance > 0.0) {
    397a:	20 e0       	ldi	r18, 0x00	; 0
    397c:	30 e0       	ldi	r19, 0x00	; 0
    397e:	a9 01       	movw	r20, r18
    3980:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    3984:	18 16       	cp	r1, r24
    3986:	0c f0       	brlt	.+2      	; 0x398a <st_prep_buffer+0x3b8>
    3988:	a5 c0       	rjmp	.+330    	; 0x3ad4 <st_prep_buffer+0x502>
          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    398a:	a5 01       	movw	r20, r10
    398c:	94 01       	movw	r18, r8
    398e:	6d 81       	ldd	r22, Y+5	; 0x05
    3990:	7e 81       	ldd	r23, Y+6	; 0x06
    3992:	8f 81       	ldd	r24, Y+7	; 0x07
    3994:	98 85       	ldd	r25, Y+8	; 0x08
    3996:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    399a:	18 16       	cp	r1, r24
    399c:	0c f0       	brlt	.+2      	; 0x39a0 <st_prep_buffer+0x3ce>
    399e:	89 c0       	rjmp	.+274    	; 0x3ab2 <st_prep_buffer+0x4e0>
            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);
    39a0:	29 81       	ldd	r18, Y+1	; 0x01
    39a2:	3a 81       	ldd	r19, Y+2	; 0x02
    39a4:	4b 81       	ldd	r20, Y+3	; 0x03
    39a6:	5c 81       	ldd	r21, Y+4	; 0x04
    39a8:	f8 01       	movw	r30, r16
    39aa:	65 8d       	ldd	r22, Z+29	; 0x1d
    39ac:	76 8d       	ldd	r23, Z+30	; 0x1e
    39ae:	87 8d       	ldd	r24, Z+31	; 0x1f
    39b0:	90 a1       	ldd	r25, Z+32	; 0x20
    39b2:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    39b6:	a3 01       	movw	r20, r6
    39b8:	92 01       	movw	r18, r4
    39ba:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    39be:	9b 01       	movw	r18, r22
    39c0:	ac 01       	movw	r20, r24
    39c2:	a1 e8       	ldi	r26, 0x81	; 129
    39c4:	b1 e0       	ldi	r27, 0x01	; 1
    39c6:	6d 93       	st	X+, r22
    39c8:	7d 93       	st	X+, r23
    39ca:	8d 93       	st	X+, r24
    39cc:	9c 93       	st	X, r25
    39ce:	13 97       	sbiw	r26, 0x03	; 3
            if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    39d0:	c5 01       	movw	r24, r10
    39d2:	b4 01       	movw	r22, r8
    39d4:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    39d8:	18 16       	cp	r1, r24
    39da:	0c f0       	brlt	.+2      	; 0x39de <st_prep_buffer+0x40c>
    39dc:	40 c0       	rjmp	.+128    	; 0x3a5e <st_prep_buffer+0x48c>
              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);
    39de:	f8 01       	movw	r30, r16
    39e0:	65 8d       	ldd	r22, Z+29	; 0x1d
    39e2:	76 8d       	ldd	r23, Z+30	; 0x1e
    39e4:	87 8d       	ldd	r24, Z+31	; 0x1f
    39e6:	90 a1       	ldd	r25, Z+32	; 0x20
    39e8:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    39ec:	a5 e7       	ldi	r26, 0x75	; 117
    39ee:	b1 e0       	ldi	r27, 0x01	; 1
    39f0:	6d 93       	st	X+, r22
    39f2:	7d 93       	st	X+, r23
    39f4:	8d 93       	st	X+, r24
    39f6:	9c 93       	st	X, r25
    39f8:	13 97       	sbiw	r26, 0x03	; 3
              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { 
    39fa:	f8 01       	movw	r30, r16
    39fc:	81 88       	ldd	r8, Z+17	; 0x11
    39fe:	92 88       	ldd	r9, Z+18	; 0x12
    3a00:	a3 88       	ldd	r10, Z+19	; 0x13
    3a02:	b4 88       	ldd	r11, Z+20	; 0x14
    3a04:	c5 8c       	ldd	r12, Z+29	; 0x1d
    3a06:	d6 8c       	ldd	r13, Z+30	; 0x1e
    3a08:	e7 8c       	ldd	r14, Z+31	; 0x1f
    3a0a:	f0 a0       	ldd	r15, Z+32	; 0x20
    3a0c:	a7 01       	movw	r20, r14
    3a0e:	96 01       	movw	r18, r12
    3a10:	c5 01       	movw	r24, r10
    3a12:	b4 01       	movw	r22, r8
    3a14:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    3a18:	81 11       	cpse	r24, r1
    3a1a:	05 c0       	rjmp	.+10     	; 0x3a26 <st_prep_buffer+0x454>
                // Cruise-deceleration or cruise-only type.
                prep.ramp_type = RAMP_CRUISE;
    3a1c:	81 e0       	ldi	r24, 0x01	; 1
    3a1e:	ac e6       	ldi	r26, 0x6C	; 108
    3a20:	b1 e0       	ldi	r27, 0x01	; 1
    3a22:	8c 93       	st	X, r24
    3a24:	64 c0       	rjmp	.+200    	; 0x3aee <st_prep_buffer+0x51c>
              } else {
                // Full-trapezoid or acceleration-cruise types
                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); 
    3a26:	a5 01       	movw	r20, r10
    3a28:	94 01       	movw	r18, r8
    3a2a:	c7 01       	movw	r24, r14
    3a2c:	b6 01       	movw	r22, r12
    3a2e:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3a32:	a3 01       	movw	r20, r6
    3a34:	92 01       	movw	r18, r4
    3a36:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3a3a:	9b 01       	movw	r18, r22
    3a3c:	ac 01       	movw	r20, r24
    3a3e:	ed e7       	ldi	r30, 0x7D	; 125
    3a40:	f1 e0       	ldi	r31, 0x01	; 1
    3a42:	60 81       	ld	r22, Z
    3a44:	71 81       	ldd	r23, Z+1	; 0x01
    3a46:	82 81       	ldd	r24, Z+2	; 0x02
    3a48:	93 81       	ldd	r25, Z+3	; 0x03
    3a4a:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3a4e:	ad e7       	ldi	r26, 0x7D	; 125
    3a50:	b1 e0       	ldi	r27, 0x01	; 1
    3a52:	6d 93       	st	X+, r22
    3a54:	7d 93       	st	X+, r23
    3a56:	8d 93       	st	X+, r24
    3a58:	9c 93       	st	X, r25
    3a5a:	13 97       	sbiw	r26, 0x03	; 3
    3a5c:	48 c0       	rjmp	.+144    	; 0x3aee <st_prep_buffer+0x51c>
              }
            } else { // Triangle type
              prep.accelerate_until = intersect_distance;
    3a5e:	ed e7       	ldi	r30, 0x7D	; 125
    3a60:	f1 e0       	ldi	r31, 0x01	; 1
    3a62:	80 82       	st	Z, r8
    3a64:	91 82       	std	Z+1, r9	; 0x01
    3a66:	a2 82       	std	Z+2, r10	; 0x02
    3a68:	b3 82       	std	Z+3, r11	; 0x03
              prep.decelerate_after = intersect_distance;
    3a6a:	a1 e8       	ldi	r26, 0x81	; 129
    3a6c:	b1 e0       	ldi	r27, 0x01	; 1
    3a6e:	8d 92       	st	X+, r8
    3a70:	9d 92       	st	X+, r9
    3a72:	ad 92       	st	X+, r10
    3a74:	bc 92       	st	X, r11
    3a76:	13 97       	sbiw	r26, 0x03	; 3
              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    3a78:	f8 01       	movw	r30, r16
    3a7a:	61 a1       	ldd	r22, Z+33	; 0x21
    3a7c:	72 a1       	ldd	r23, Z+34	; 0x22
    3a7e:	83 a1       	ldd	r24, Z+35	; 0x23
    3a80:	94 a1       	ldd	r25, Z+36	; 0x24
    3a82:	9b 01       	movw	r18, r22
    3a84:	ac 01       	movw	r20, r24
    3a86:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3a8a:	a5 01       	movw	r20, r10
    3a8c:	94 01       	movw	r18, r8
    3a8e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3a92:	29 81       	ldd	r18, Y+1	; 0x01
    3a94:	3a 81       	ldd	r19, Y+2	; 0x02
    3a96:	4b 81       	ldd	r20, Y+3	; 0x03
    3a98:	5c 81       	ldd	r21, Y+4	; 0x04
    3a9a:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3a9e:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    3aa2:	a5 e7       	ldi	r26, 0x75	; 117
    3aa4:	b1 e0       	ldi	r27, 0x01	; 1
    3aa6:	6d 93       	st	X+, r22
    3aa8:	7d 93       	st	X+, r23
    3aaa:	8d 93       	st	X+, r24
    3aac:	9c 93       	st	X, r25
    3aae:	13 97       	sbiw	r26, 0x03	; 3
    3ab0:	1e c0       	rjmp	.+60     	; 0x3aee <st_prep_buffer+0x51c>
            }          
          } else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    3ab2:	82 e0       	ldi	r24, 0x02	; 2
    3ab4:	ec e6       	ldi	r30, 0x6C	; 108
    3ab6:	f1 e0       	ldi	r31, 0x01	; 1
    3ab8:	80 83       	st	Z, r24
            // prep.decelerate_after = pl_block->millimeters;
            prep.maximum_speed = prep.current_speed;
    3aba:	e1 e7       	ldi	r30, 0x71	; 113
    3abc:	f1 e0       	ldi	r31, 0x01	; 1
    3abe:	80 81       	ld	r24, Z
    3ac0:	91 81       	ldd	r25, Z+1	; 0x01
    3ac2:	a2 81       	ldd	r26, Z+2	; 0x02
    3ac4:	b3 81       	ldd	r27, Z+3	; 0x03
    3ac6:	e5 e7       	ldi	r30, 0x75	; 117
    3ac8:	f1 e0       	ldi	r31, 0x01	; 1
    3aca:	80 83       	st	Z, r24
    3acc:	91 83       	std	Z+1, r25	; 0x01
    3ace:	a2 83       	std	Z+2, r26	; 0x02
    3ad0:	b3 83       	std	Z+3, r27	; 0x03
    3ad2:	0d c0       	rjmp	.+26     	; 0x3aee <st_prep_buffer+0x51c>
          }
        } else { // Acceleration-only type
          prep.accelerate_until = 0.0;
    3ad4:	ad e7       	ldi	r26, 0x7D	; 125
    3ad6:	b1 e0       	ldi	r27, 0x01	; 1
    3ad8:	1d 92       	st	X+, r1
    3ada:	1d 92       	st	X+, r1
    3adc:	1d 92       	st	X+, r1
    3ade:	1c 92       	st	X, r1
    3ae0:	13 97       	sbiw	r26, 0x03	; 3
          // prep.decelerate_after = 0.0;
          prep.maximum_speed = prep.exit_speed;
    3ae2:	e5 e7       	ldi	r30, 0x75	; 117
    3ae4:	f1 e0       	ldi	r31, 0x01	; 1
    3ae6:	c0 82       	st	Z, r12
    3ae8:	d1 82       	std	Z+1, r13	; 0x01
    3aea:	e2 82       	std	Z+2, r14	; 0x02
    3aec:	f3 82       	std	Z+3, r15	; 0x03
      }  
          
    }

    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    3aee:	80 91 8d 01 	lds	r24, 0x018D
    3af2:	90 e0       	ldi	r25, 0x00	; 0
    3af4:	9c 01       	movw	r18, r24
    3af6:	22 0f       	add	r18, r18
    3af8:	33 1f       	adc	r19, r19
    3afa:	82 0f       	add	r24, r18
    3afc:	93 1f       	adc	r25, r19
    3afe:	88 0f       	add	r24, r24
    3b00:	99 1f       	adc	r25, r25
    3b02:	9c 01       	movw	r18, r24
    3b04:	2e 54       	subi	r18, 0x4E	; 78
    3b06:	3e 4f       	sbci	r19, 0xFE	; 254
    3b08:	3c a7       	std	Y+44, r19	; 0x2c
    3b0a:	2b a7       	std	Y+43, r18	; 0x2b

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    3b0c:	aa e5       	ldi	r26, 0x5A	; 90
    3b0e:	b1 e0       	ldi	r27, 0x01	; 1
    3b10:	8c 91       	ld	r24, X
    3b12:	f9 01       	movw	r30, r18
    3b14:	82 83       	std	Z+2, r24	; 0x02
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable   
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    3b16:	20 91 87 01 	lds	r18, 0x0187
    3b1a:	30 91 88 01 	lds	r19, 0x0188
    3b1e:	3e 8b       	std	Y+22, r19	; 0x16
    3b20:	2d 8b       	std	Y+21, r18	; 0x15
    3b22:	d9 01       	movw	r26, r18
    3b24:	95 96       	adiw	r26, 0x25	; 37
    3b26:	bc 91       	ld	r27, X
    3b28:	bd a7       	std	Y+45, r27	; 0x2d
    3b2a:	f9 01       	movw	r30, r18
    3b2c:	f6 a1       	ldd	r31, Z+38	; 0x26
    3b2e:	fe a7       	std	Y+46, r31	; 0x2e
    3b30:	d9 01       	movw	r26, r18
    3b32:	97 96       	adiw	r26, 0x27	; 39
    3b34:	bc 91       	ld	r27, X
    3b36:	bf a7       	std	Y+47, r27	; 0x2f
    3b38:	f9 01       	movw	r30, r18
    3b3a:	f0 a5       	ldd	r31, Z+40	; 0x28
    3b3c:	f8 ab       	std	Y+48, r31	; 0x30
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    3b3e:	20 91 64 01 	lds	r18, 0x0164
    3b42:	30 91 65 01 	lds	r19, 0x0165
    3b46:	40 91 66 01 	lds	r20, 0x0166
    3b4a:	50 91 67 01 	lds	r21, 0x0167
    3b4e:	6d a5       	ldd	r22, Y+45	; 0x2d
    3b50:	7e a5       	ldd	r23, Y+46	; 0x2e
    3b52:	8b 2f       	mov	r24, r27
    3b54:	9f 2f       	mov	r25, r31
    3b56:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3b5a:	6b a3       	std	Y+35, r22	; 0x23
    3b5c:	7c a3       	std	Y+36, r23	; 0x24
    3b5e:	8d a3       	std	Y+37, r24	; 0x25
    3b60:	9e a3       	std	Y+38, r25	; 0x26
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    3b62:	20 e0       	ldi	r18, 0x00	; 0
    3b64:	30 e0       	ldi	r19, 0x00	; 0
    3b66:	a9 01       	movw	r20, r18
    3b68:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    3b6c:	88 23       	and	r24, r24
    3b6e:	24 f4       	brge	.+8      	; 0x3b78 <st_prep_buffer+0x5a6>
    3b70:	1b a2       	std	Y+35, r1	; 0x23
    3b72:	1c a2       	std	Y+36, r1	; 0x24
    3b74:	1d a2       	std	Y+37, r1	; 0x25
    3b76:	1e a2       	std	Y+38, r1	; 0x26
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    3b78:	ad e7       	ldi	r26, 0x7D	; 125
    3b7a:	b1 e0       	ldi	r27, 0x01	; 1
    3b7c:	bc 91       	ld	r27, X
    3b7e:	bf 8b       	std	Y+23, r27	; 0x17
    3b80:	e0 91 7e 01 	lds	r30, 0x017E
    3b84:	e8 8f       	std	Y+24, r30	; 0x18
    3b86:	f0 91 7f 01 	lds	r31, 0x017F
    3b8a:	f9 8f       	std	Y+25, r31	; 0x19
    3b8c:	20 91 80 01 	lds	r18, 0x0180
    3b90:	2a 8f       	std	Y+26, r18	; 0x1a
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    3b92:	a5 e7       	ldi	r26, 0x75	; 117
    3b94:	b1 e0       	ldi	r27, 0x01	; 1
    3b96:	bc 91       	ld	r27, X
    3b98:	bb 8f       	std	Y+27, r27	; 0x1b
    3b9a:	e0 91 76 01 	lds	r30, 0x0176
    3b9e:	ec 8f       	std	Y+28, r30	; 0x1c
    3ba0:	f0 91 77 01 	lds	r31, 0x0177
    3ba4:	fd 8f       	std	Y+29, r31	; 0x1d
    3ba6:	20 91 78 01 	lds	r18, 0x0178
    3baa:	2e 8f       	std	Y+30, r18	; 0x1e
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3bac:	a1 e8       	ldi	r26, 0x81	; 129
    3bae:	b1 e0       	ldi	r27, 0x01	; 1
    3bb0:	bc 91       	ld	r27, X
    3bb2:	bf 8f       	std	Y+31, r27	; 0x1f
    3bb4:	e0 91 82 01 	lds	r30, 0x0182
    3bb8:	e8 a3       	std	Y+32, r30	; 0x20
    3bba:	f0 91 83 01 	lds	r31, 0x0183
    3bbe:	f9 a3       	std	Y+33, r31	; 0x21
    3bc0:	20 91 84 01 	lds	r18, 0x0184
    3bc4:	2a a3       	std	Y+34, r18	; 0x22
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
    3bc6:	ad e6       	ldi	r26, 0x6D	; 109
    3bc8:	b1 e0       	ldi	r27, 0x01	; 1
    3bca:	bc 91       	ld	r27, X
    3bcc:	b9 8b       	std	Y+17, r27	; 0x11
    3bce:	e0 91 6e 01 	lds	r30, 0x016E
    3bd2:	ea 8b       	std	Y+18, r30	; 0x12
    3bd4:	f0 91 6f 01 	lds	r31, 0x016F
    3bd8:	fb 8b       	std	Y+19, r31	; 0x13
    3bda:	20 91 70 01 	lds	r18, 0x0170
    3bde:	2c 8b       	std	Y+20, r18	; 0x14
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    3be0:	a9 e7       	ldi	r26, 0x79	; 121
    3be2:	b1 e0       	ldi	r27, 0x01	; 1
    3be4:	8d 91       	ld	r24, X+
    3be6:	9d 91       	ld	r25, X+
    3be8:	0d 90       	ld	r0, X+
    3bea:	bc 91       	ld	r27, X
    3bec:	a0 2d       	mov	r26, r0
    3bee:	89 ab       	std	Y+49, r24	; 0x31
    3bf0:	9a ab       	std	Y+50, r25	; 0x32
    3bf2:	ab ab       	std	Y+51, r26	; 0x33
    3bf4:	bc ab       	std	Y+52, r27	; 0x34
    3bf6:	e1 e7       	ldi	r30, 0x71	; 113
    3bf8:	f1 e0       	ldi	r31, 0x01	; 1
    3bfa:	f0 81       	ld	r31, Z
    3bfc:	fd 87       	std	Y+13, r31	; 0x0d
    3bfe:	20 91 72 01 	lds	r18, 0x0172
    3c02:	2e 87       	std	Y+14, r18	; 0x0e
    3c04:	30 91 73 01 	lds	r19, 0x0173
    3c08:	3f 87       	std	Y+15, r19	; 0x0f
    3c0a:	40 91 74 01 	lds	r20, 0x0174
    3c0e:	48 8b       	std	Y+16, r20	; 0x10
    3c10:	ac e6       	ldi	r26, 0x6C	; 108
    3c12:	b1 e0       	ldi	r27, 0x01	; 1
    3c14:	bc 91       	ld	r27, X
    3c16:	b9 87       	std	Y+9, r27	; 0x09
    3c18:	ed a5       	ldd	r30, Y+45	; 0x2d
    3c1a:	fe a5       	ldd	r31, Y+46	; 0x2e
    3c1c:	ff a3       	std	Y+39, r31	; 0x27
    3c1e:	0f a5       	ldd	r16, Y+47	; 0x2f
    3c20:	18 a9       	ldd	r17, Y+48	; 0x30
    3c22:	0f 2e       	mov	r0, r31
    3c24:	fe e3       	ldi	r31, 0x3E	; 62
    3c26:	2f 2e       	mov	r2, r31
    3c28:	f0 2d       	mov	r31, r0
    3c2a:	0f 2e       	mov	r0, r31
    3c2c:	f3 ec       	ldi	r31, 0xC3	; 195
    3c2e:	6f 2e       	mov	r6, r31
    3c30:	f0 2d       	mov	r31, r0
    3c32:	0f 2e       	mov	r0, r31
    3c34:	fe e2       	ldi	r31, 0x2E	; 46
    3c36:	7f 2e       	mov	r7, r31
    3c38:	f0 2d       	mov	r31, r0
    3c3a:	0f 2e       	mov	r0, r31
    3c3c:	f9 e3       	ldi	r31, 0x39	; 57
    3c3e:	3f 2e       	mov	r3, r31
    3c40:	f0 2d       	mov	r31, r0
    3c42:	c1 2c       	mov	r12, r1
    3c44:	d1 2c       	mov	r13, r1
    3c46:	76 01       	movw	r14, r12
    3c48:	0f 2e       	mov	r0, r31
    3c4a:	fe e3       	ldi	r31, 0x3E	; 62
    3c4c:	4f 2e       	mov	r4, r31
    3c4e:	f0 2d       	mov	r31, r0
    3c50:	0f 2e       	mov	r0, r31
    3c52:	f3 ec       	ldi	r31, 0xC3	; 195
    3c54:	5f 2e       	mov	r5, r31
    3c56:	f0 2d       	mov	r31, r0
    3c58:	2e e2       	ldi	r18, 0x2E	; 46
    3c5a:	29 83       	std	Y+1, r18	; 0x01
    3c5c:	39 e3       	ldi	r19, 0x39	; 57
    3c5e:	3d 83       	std	Y+5, r19	; 0x05
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
    3c60:	ed ab       	std	Y+53, r30	; 0x35
    3c62:	fe ab       	std	Y+54, r31	; 0x36
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    3c64:	49 85       	ldd	r20, Y+9	; 0x09
    3c66:	44 23       	and	r20, r20
    3c68:	21 f0       	breq	.+8      	; 0x3c72 <st_prep_buffer+0x6a0>
    3c6a:	41 30       	cpi	r20, 0x01	; 1
    3c6c:	09 f4       	brne	.+2      	; 0x3c70 <st_prep_buffer+0x69e>
    3c6e:	8a c0       	rjmp	.+276    	; 0x3d84 <st_prep_buffer+0x7b2>
    3c70:	c9 c0       	rjmp	.+402    	; 0x3e04 <st_prep_buffer+0x832>
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    3c72:	ad 89       	ldd	r26, Y+21	; 0x15
    3c74:	be 89       	ldd	r27, Y+22	; 0x16
    3c76:	91 96       	adiw	r26, 0x21	; 33
    3c78:	2d 91       	ld	r18, X+
    3c7a:	3d 91       	ld	r19, X+
    3c7c:	4d 91       	ld	r20, X+
    3c7e:	5c 91       	ld	r21, X
    3c80:	94 97       	sbiw	r26, 0x24	; 36
    3c82:	62 2d       	mov	r22, r2
    3c84:	76 2d       	mov	r23, r6
    3c86:	87 2d       	mov	r24, r7
    3c88:	93 2d       	mov	r25, r3
    3c8a:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3c8e:	4b 01       	movw	r8, r22
    3c90:	5c 01       	movw	r10, r24
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    3c92:	20 e0       	ldi	r18, 0x00	; 0
    3c94:	30 e0       	ldi	r19, 0x00	; 0
    3c96:	40 e0       	ldi	r20, 0x00	; 0
    3c98:	5f e3       	ldi	r21, 0x3F	; 63
    3c9a:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3c9e:	2d 85       	ldd	r18, Y+13	; 0x0d
    3ca0:	3e 85       	ldd	r19, Y+14	; 0x0e
    3ca2:	4f 85       	ldd	r20, Y+15	; 0x0f
    3ca4:	58 89       	ldd	r21, Y+16	; 0x10
    3ca6:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3caa:	22 2d       	mov	r18, r2
    3cac:	36 2d       	mov	r19, r6
    3cae:	47 2d       	mov	r20, r7
    3cb0:	53 2d       	mov	r21, r3
    3cb2:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3cb6:	9b 01       	movw	r18, r22
    3cb8:	ac 01       	movw	r20, r24
    3cba:	6d a9       	ldd	r22, Y+53	; 0x35
    3cbc:	7e a9       	ldd	r23, Y+54	; 0x36
    3cbe:	80 2f       	mov	r24, r16
    3cc0:	91 2f       	mov	r25, r17
    3cc2:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3cc6:	6d ab       	std	Y+53, r22	; 0x35
    3cc8:	7e ab       	std	Y+54, r23	; 0x36
    3cca:	08 2f       	mov	r16, r24
    3ccc:	19 2f       	mov	r17, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    3cce:	2f 89       	ldd	r18, Y+23	; 0x17
    3cd0:	38 8d       	ldd	r19, Y+24	; 0x18
    3cd2:	49 8d       	ldd	r20, Y+25	; 0x19
    3cd4:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3cd6:	91 2f       	mov	r25, r17
    3cd8:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    3cdc:	88 23       	and	r24, r24
    3cde:	0c f0       	brlt	.+2      	; 0x3ce2 <st_prep_buffer+0x710>
    3ce0:	44 c0       	rjmp	.+136    	; 0x3d6a <st_prep_buffer+0x798>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    3ce2:	2f 89       	ldd	r18, Y+23	; 0x17
    3ce4:	38 8d       	ldd	r19, Y+24	; 0x18
    3ce6:	49 8d       	ldd	r20, Y+25	; 0x19
    3ce8:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3cea:	6d a5       	ldd	r22, Y+45	; 0x2d
    3cec:	7e a5       	ldd	r23, Y+46	; 0x2e
    3cee:	8f a5       	ldd	r24, Y+47	; 0x2f
    3cf0:	98 a9       	ldd	r25, Y+48	; 0x30
    3cf2:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3cf6:	9b 01       	movw	r18, r22
    3cf8:	ac 01       	movw	r20, r24
    3cfa:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3cfe:	4b 01       	movw	r8, r22
    3d00:	5c 01       	movw	r10, r24
    3d02:	2d 85       	ldd	r18, Y+13	; 0x0d
    3d04:	3e 85       	ldd	r19, Y+14	; 0x0e
    3d06:	4f 85       	ldd	r20, Y+15	; 0x0f
    3d08:	58 89       	ldd	r21, Y+16	; 0x10
    3d0a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    3d0c:	7c 8d       	ldd	r23, Y+28	; 0x1c
    3d0e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3d10:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3d12:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3d16:	9b 01       	movw	r18, r22
    3d18:	ac 01       	movw	r20, r24
    3d1a:	c5 01       	movw	r24, r10
    3d1c:	b4 01       	movw	r22, r8
    3d1e:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    3d22:	26 2e       	mov	r2, r22
    3d24:	67 2e       	mov	r6, r23
    3d26:	78 2e       	mov	r7, r24
    3d28:	39 2e       	mov	r3, r25
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3d2a:	2f 8d       	ldd	r18, Y+31	; 0x1f
    3d2c:	38 a1       	ldd	r19, Y+32	; 0x20
    3d2e:	49 a1       	ldd	r20, Y+33	; 0x21
    3d30:	5a a1       	ldd	r21, Y+34	; 0x22
    3d32:	6f 89       	ldd	r22, Y+23	; 0x17
    3d34:	78 8d       	ldd	r23, Y+24	; 0x18
    3d36:	89 8d       	ldd	r24, Y+25	; 0x19
    3d38:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3d3a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    3d3e:	88 23       	and	r24, r24
    3d40:	19 f0       	breq	.+6      	; 0x3d48 <st_prep_buffer+0x776>
            else { prep.ramp_type = RAMP_CRUISE; }
    3d42:	b1 e0       	ldi	r27, 0x01	; 1
    3d44:	b9 87       	std	Y+9, r27	; 0x09
    3d46:	02 c0       	rjmp	.+4      	; 0x3d4c <st_prep_buffer+0x77a>
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3d48:	e2 e0       	ldi	r30, 0x02	; 2
    3d4a:	e9 87       	std	Y+9, r30	; 0x09
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    3d4c:	fb 8d       	ldd	r31, Y+27	; 0x1b
    3d4e:	fd 87       	std	Y+13, r31	; 0x0d
    3d50:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3d52:	2e 87       	std	Y+14, r18	; 0x0e
    3d54:	3d 8d       	ldd	r19, Y+29	; 0x1d
    3d56:	3f 87       	std	Y+15, r19	; 0x0f
    3d58:	4e 8d       	ldd	r20, Y+30	; 0x1e
    3d5a:	48 8b       	std	Y+16, r20	; 0x10
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    3d5c:	5f 89       	ldd	r21, Y+23	; 0x17
    3d5e:	5d ab       	std	Y+53, r21	; 0x35
    3d60:	88 8d       	ldd	r24, Y+24	; 0x18
    3d62:	8e ab       	std	Y+54, r24	; 0x36
    3d64:	09 8d       	ldd	r16, Y+25	; 0x19
    3d66:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3d68:	d1 c0       	rjmp	.+418    	; 0x3f0c <st_prep_buffer+0x93a>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only. 
            prep.current_speed += speed_var;
    3d6a:	2d 85       	ldd	r18, Y+13	; 0x0d
    3d6c:	3e 85       	ldd	r19, Y+14	; 0x0e
    3d6e:	4f 85       	ldd	r20, Y+15	; 0x0f
    3d70:	58 89       	ldd	r21, Y+16	; 0x10
    3d72:	c5 01       	movw	r24, r10
    3d74:	b4 01       	movw	r22, r8
    3d76:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3d7a:	6d 87       	std	Y+13, r22	; 0x0d
    3d7c:	7e 87       	std	Y+14, r23	; 0x0e
    3d7e:	8f 87       	std	Y+15, r24	; 0x0f
    3d80:	98 8b       	std	Y+16, r25	; 0x10
    3d82:	c4 c0       	rjmp	.+392    	; 0x3f0c <st_prep_buffer+0x93a>
          }
          break;
        case RAMP_CRUISE: 
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    3d84:	2b 8d       	ldd	r18, Y+27	; 0x1b
    3d86:	3c 8d       	ldd	r19, Y+28	; 0x1c
    3d88:	4d 8d       	ldd	r20, Y+29	; 0x1d
    3d8a:	5e 8d       	ldd	r21, Y+30	; 0x1e
    3d8c:	62 2d       	mov	r22, r2
    3d8e:	76 2d       	mov	r23, r6
    3d90:	87 2d       	mov	r24, r7
    3d92:	93 2d       	mov	r25, r3
    3d94:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3d98:	9b 01       	movw	r18, r22
    3d9a:	ac 01       	movw	r20, r24
    3d9c:	6d a9       	ldd	r22, Y+53	; 0x35
    3d9e:	7e a9       	ldd	r23, Y+54	; 0x36
    3da0:	80 2f       	mov	r24, r16
    3da2:	91 2f       	mov	r25, r17
    3da4:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3da8:	a6 2e       	mov	r10, r22
    3daa:	b7 2e       	mov	r11, r23
    3dac:	88 2e       	mov	r8, r24
    3dae:	99 2e       	mov	r9, r25
          if (mm_var < prep.decelerate_after) { // End of cruise. 
    3db0:	26 2f       	mov	r18, r22
    3db2:	37 2f       	mov	r19, r23
    3db4:	48 2f       	mov	r20, r24
    3db6:	59 2f       	mov	r21, r25
    3db8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3dba:	78 a1       	ldd	r23, Y+32	; 0x20
    3dbc:	89 a1       	ldd	r24, Y+33	; 0x21
    3dbe:	9a a1       	ldd	r25, Y+34	; 0x22
    3dc0:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    3dc4:	18 16       	cp	r1, r24
    3dc6:	0c f0       	brlt	.+2      	; 0x3dca <st_prep_buffer+0x7f8>
    3dc8:	9d c0       	rjmp	.+314    	; 0x3f04 <st_prep_buffer+0x932>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    3dca:	2f 8d       	ldd	r18, Y+31	; 0x1f
    3dcc:	38 a1       	ldd	r19, Y+32	; 0x20
    3dce:	49 a1       	ldd	r20, Y+33	; 0x21
    3dd0:	5a a1       	ldd	r21, Y+34	; 0x22
    3dd2:	6d a9       	ldd	r22, Y+53	; 0x35
    3dd4:	7e a9       	ldd	r23, Y+54	; 0x36
    3dd6:	80 2f       	mov	r24, r16
    3dd8:	91 2f       	mov	r25, r17
    3dda:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3dde:	2b 8d       	ldd	r18, Y+27	; 0x1b
    3de0:	3c 8d       	ldd	r19, Y+28	; 0x1c
    3de2:	4d 8d       	ldd	r20, Y+29	; 0x1d
    3de4:	5e 8d       	ldd	r21, Y+30	; 0x1e
    3de6:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    3dea:	26 2e       	mov	r2, r22
    3dec:	67 2e       	mov	r6, r23
    3dee:	78 2e       	mov	r7, r24
    3df0:	39 2e       	mov	r3, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    3df2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3df4:	9d ab       	std	Y+53, r25	; 0x35
    3df6:	a8 a1       	ldd	r26, Y+32	; 0x20
    3df8:	ae ab       	std	Y+54, r26	; 0x36
    3dfa:	09 a1       	ldd	r16, Y+33	; 0x21
    3dfc:	1a a1       	ldd	r17, Y+34	; 0x22
            prep.ramp_type = RAMP_DECEL;
    3dfe:	b2 e0       	ldi	r27, 0x02	; 2
    3e00:	b9 87       	std	Y+9, r27	; 0x09
    3e02:	84 c0       	rjmp	.+264    	; 0x3f0c <st_prep_buffer+0x93a>
            mm_remaining = mm_var; 
          } 
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    3e04:	ed 89       	ldd	r30, Y+21	; 0x15
    3e06:	fe 89       	ldd	r31, Y+22	; 0x16
    3e08:	21 a1       	ldd	r18, Z+33	; 0x21
    3e0a:	32 a1       	ldd	r19, Z+34	; 0x22
    3e0c:	43 a1       	ldd	r20, Z+35	; 0x23
    3e0e:	54 a1       	ldd	r21, Z+36	; 0x24
    3e10:	62 2d       	mov	r22, r2
    3e12:	76 2d       	mov	r23, r6
    3e14:	87 2d       	mov	r24, r7
    3e16:	93 2d       	mov	r25, r3
    3e18:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3e1c:	4b 01       	movw	r8, r22
    3e1e:	5c 01       	movw	r10, r24
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    3e20:	9b 01       	movw	r18, r22
    3e22:	ac 01       	movw	r20, r24
    3e24:	6d 85       	ldd	r22, Y+13	; 0x0d
    3e26:	7e 85       	ldd	r23, Y+14	; 0x0e
    3e28:	8f 85       	ldd	r24, Y+15	; 0x0f
    3e2a:	98 89       	ldd	r25, Y+16	; 0x10
    3e2c:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    3e30:	18 16       	cp	r1, r24
    3e32:	ec f5       	brge	.+122    	; 0x3eae <st_prep_buffer+0x8dc>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    3e34:	20 e0       	ldi	r18, 0x00	; 0
    3e36:	30 e0       	ldi	r19, 0x00	; 0
    3e38:	40 e0       	ldi	r20, 0x00	; 0
    3e3a:	5f e3       	ldi	r21, 0x3F	; 63
    3e3c:	c5 01       	movw	r24, r10
    3e3e:	b4 01       	movw	r22, r8
    3e40:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3e44:	9b 01       	movw	r18, r22
    3e46:	ac 01       	movw	r20, r24
    3e48:	6d 85       	ldd	r22, Y+13	; 0x0d
    3e4a:	7e 85       	ldd	r23, Y+14	; 0x0e
    3e4c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3e4e:	98 89       	ldd	r25, Y+16	; 0x10
    3e50:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3e54:	22 2d       	mov	r18, r2
    3e56:	36 2d       	mov	r19, r6
    3e58:	47 2d       	mov	r20, r7
    3e5a:	53 2d       	mov	r21, r3
    3e5c:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    3e60:	9b 01       	movw	r18, r22
    3e62:	ac 01       	movw	r20, r24
    3e64:	6d a9       	ldd	r22, Y+53	; 0x35
    3e66:	7e a9       	ldd	r23, Y+54	; 0x36
    3e68:	80 2f       	mov	r24, r16
    3e6a:	91 2f       	mov	r25, r17
    3e6c:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3e70:	6f a3       	std	Y+39, r22	; 0x27
    3e72:	78 a7       	std	Y+40, r23	; 0x28
    3e74:	89 a7       	std	Y+41, r24	; 0x29
    3e76:	9a a7       	std	Y+42, r25	; 0x2a
            if (mm_var > prep.mm_complete) { // Deceleration only.
    3e78:	29 89       	ldd	r18, Y+17	; 0x11
    3e7a:	3a 89       	ldd	r19, Y+18	; 0x12
    3e7c:	4b 89       	ldd	r20, Y+19	; 0x13
    3e7e:	5c 89       	ldd	r21, Y+20	; 0x14
    3e80:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    3e84:	18 16       	cp	r1, r24
    3e86:	9c f4       	brge	.+38     	; 0x3eae <st_prep_buffer+0x8dc>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    3e88:	a5 01       	movw	r20, r10
    3e8a:	94 01       	movw	r18, r8
    3e8c:	6d 85       	ldd	r22, Y+13	; 0x0d
    3e8e:	7e 85       	ldd	r23, Y+14	; 0x0e
    3e90:	8f 85       	ldd	r24, Y+15	; 0x0f
    3e92:	98 89       	ldd	r25, Y+16	; 0x10
    3e94:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3e98:	6d 87       	std	Y+13, r22	; 0x0d
    3e9a:	7e 87       	std	Y+14, r23	; 0x0e
    3e9c:	8f 87       	std	Y+15, r24	; 0x0f
    3e9e:	98 8b       	std	Y+16, r25	; 0x10
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
              mm_remaining = mm_var;
    3ea0:	ff a1       	ldd	r31, Y+39	; 0x27
    3ea2:	fd ab       	std	Y+53, r31	; 0x35
    3ea4:	28 a5       	ldd	r18, Y+40	; 0x28
    3ea6:	2e ab       	std	Y+54, r18	; 0x36
    3ea8:	09 a5       	ldd	r16, Y+41	; 0x29
    3eaa:	1a a5       	ldd	r17, Y+42	; 0x2a
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    3eac:	2f c0       	rjmp	.+94     	; 0x3f0c <st_prep_buffer+0x93a>
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    3eae:	29 89       	ldd	r18, Y+17	; 0x11
    3eb0:	3a 89       	ldd	r19, Y+18	; 0x12
    3eb2:	4b 89       	ldd	r20, Y+19	; 0x13
    3eb4:	5c 89       	ldd	r21, Y+20	; 0x14
    3eb6:	6d a9       	ldd	r22, Y+53	; 0x35
    3eb8:	7e a9       	ldd	r23, Y+54	; 0x36
    3eba:	80 2f       	mov	r24, r16
    3ebc:	91 2f       	mov	r25, r17
    3ebe:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3ec2:	9b 01       	movw	r18, r22
    3ec4:	ac 01       	movw	r20, r24
    3ec6:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3eca:	4b 01       	movw	r8, r22
    3ecc:	5c 01       	movw	r10, r24
    3ece:	29 a9       	ldd	r18, Y+49	; 0x31
    3ed0:	3a a9       	ldd	r19, Y+50	; 0x32
    3ed2:	4b a9       	ldd	r20, Y+51	; 0x33
    3ed4:	5c a9       	ldd	r21, Y+52	; 0x34
    3ed6:	6d 85       	ldd	r22, Y+13	; 0x0d
    3ed8:	7e 85       	ldd	r23, Y+14	; 0x0e
    3eda:	8f 85       	ldd	r24, Y+15	; 0x0f
    3edc:	98 89       	ldd	r25, Y+16	; 0x10
    3ede:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3ee2:	9b 01       	movw	r18, r22
    3ee4:	ac 01       	movw	r20, r24
    3ee6:	c5 01       	movw	r24, r10
    3ee8:	b4 01       	movw	r22, r8
    3eea:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    3eee:	26 2e       	mov	r2, r22
    3ef0:	67 2e       	mov	r6, r23
    3ef2:	78 2e       	mov	r7, r24
    3ef4:	39 2e       	mov	r3, r25
          mm_remaining = prep.mm_complete; 
    3ef6:	39 89       	ldd	r19, Y+17	; 0x11
    3ef8:	3d ab       	std	Y+53, r19	; 0x35
    3efa:	4a 89       	ldd	r20, Y+18	; 0x12
    3efc:	4e ab       	std	Y+54, r20	; 0x36
    3efe:	0b 89       	ldd	r16, Y+19	; 0x13
    3f00:	1c 89       	ldd	r17, Y+20	; 0x14
    3f02:	04 c0       	rjmp	.+8      	; 0x3f0c <st_prep_buffer+0x93a>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.         
            mm_remaining = mm_var; 
    3f04:	ad aa       	std	Y+53, r10	; 0x35
    3f06:	be aa       	std	Y+54, r11	; 0x36
    3f08:	08 2d       	mov	r16, r8
    3f0a:	19 2d       	mov	r17, r9
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete; 
      }
      dt += time_var; // Add computed ramp time to total segment time.
    3f0c:	22 2d       	mov	r18, r2
    3f0e:	36 2d       	mov	r19, r6
    3f10:	47 2d       	mov	r20, r7
    3f12:	53 2d       	mov	r21, r3
    3f14:	c7 01       	movw	r24, r14
    3f16:	b6 01       	movw	r22, r12
    3f18:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3f1c:	6b 01       	movw	r12, r22
    3f1e:	7c 01       	movw	r14, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    3f20:	9b 01       	movw	r18, r22
    3f22:	ac 01       	movw	r20, r24
    3f24:	64 2d       	mov	r22, r4
    3f26:	75 2d       	mov	r23, r5
    3f28:	89 81       	ldd	r24, Y+1	; 0x01
    3f2a:	9d 81       	ldd	r25, Y+5	; 0x05
    3f2c:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    3f30:	18 16       	cp	r1, r24
    3f32:	6c f4       	brge	.+26     	; 0x3f4e <st_prep_buffer+0x97c>
    3f34:	a7 01       	movw	r20, r14
    3f36:	96 01       	movw	r18, r12
    3f38:	64 2d       	mov	r22, r4
    3f3a:	75 2d       	mov	r23, r5
    3f3c:	89 81       	ldd	r24, Y+1	; 0x01
    3f3e:	9d 81       	ldd	r25, Y+5	; 0x05
    3f40:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3f44:	26 2e       	mov	r2, r22
    3f46:	67 2e       	mov	r6, r23
    3f48:	78 2e       	mov	r7, r24
    3f4a:	39 2e       	mov	r3, r25
    3f4c:	33 c0       	rjmp	.+102    	; 0x3fb4 <st_prep_buffer+0x9e2>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    3f4e:	2b a1       	ldd	r18, Y+35	; 0x23
    3f50:	3c a1       	ldd	r19, Y+36	; 0x24
    3f52:	4d a1       	ldd	r20, Y+37	; 0x25
    3f54:	5e a1       	ldd	r21, Y+38	; 0x26
    3f56:	6d a9       	ldd	r22, Y+53	; 0x35
    3f58:	7e a9       	ldd	r23, Y+54	; 0x36
    3f5a:	80 2f       	mov	r24, r16
    3f5c:	91 2f       	mov	r25, r17
    3f5e:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    3f62:	18 16       	cp	r1, r24
    3f64:	8c f0       	brlt	.+34     	; 0x3f88 <st_prep_buffer+0x9b6>
    3f66:	8e a9       	ldd	r24, Y+54	; 0x36
    3f68:	8f a3       	std	Y+39, r24	; 0x27
    3f6a:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f6c:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f6e:	af 85       	ldd	r26, Y+15	; 0x0f
    3f70:	b8 89       	ldd	r27, Y+16	; 0x10
    3f72:	e1 e7       	ldi	r30, 0x71	; 113
    3f74:	f1 e0       	ldi	r31, 0x01	; 1
    3f76:	80 83       	st	Z, r24
    3f78:	91 83       	std	Z+1, r25	; 0x01
    3f7a:	a2 83       	std	Z+2, r26	; 0x02
    3f7c:	b3 83       	std	Z+3, r27	; 0x03
    3f7e:	e9 85       	ldd	r30, Y+9	; 0x09
    3f80:	ac e6       	ldi	r26, 0x6C	; 108
    3f82:	b1 e0       	ldi	r27, 0x01	; 1
    3f84:	ec 93       	st	X, r30
    3f86:	33 c0       	rjmp	.+102    	; 0x3fee <st_prep_buffer+0xa1c>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    3f88:	2e e3       	ldi	r18, 0x3E	; 62
    3f8a:	33 ec       	ldi	r19, 0xC3	; 195
    3f8c:	4e e2       	ldi	r20, 0x2E	; 46
    3f8e:	59 e3       	ldi	r21, 0x39	; 57
    3f90:	64 2d       	mov	r22, r4
    3f92:	75 2d       	mov	r23, r5
    3f94:	89 81       	ldd	r24, Y+1	; 0x01
    3f96:	9d 81       	ldd	r25, Y+5	; 0x05
    3f98:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    3f9c:	46 2e       	mov	r4, r22
    3f9e:	57 2e       	mov	r5, r23
    3fa0:	89 83       	std	Y+1, r24	; 0x01
    3fa2:	9d 83       	std	Y+5, r25	; 0x05
          time_var = dt_max - dt;
    3fa4:	a7 01       	movw	r20, r14
    3fa6:	96 01       	movw	r18, r12
    3fa8:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    3fac:	26 2e       	mov	r2, r22
    3fae:	67 2e       	mov	r6, r23
    3fb0:	78 2e       	mov	r7, r24
    3fb2:	39 2e       	mov	r3, r25
        } else { 
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    3fb4:	29 89       	ldd	r18, Y+17	; 0x11
    3fb6:	3a 89       	ldd	r19, Y+18	; 0x12
    3fb8:	4b 89       	ldd	r20, Y+19	; 0x13
    3fba:	5c 89       	ldd	r21, Y+20	; 0x14
    3fbc:	6d a9       	ldd	r22, Y+53	; 0x35
    3fbe:	7e a9       	ldd	r23, Y+54	; 0x36
    3fc0:	80 2f       	mov	r24, r16
    3fc2:	91 2f       	mov	r25, r17
    3fc4:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    3fc8:	18 16       	cp	r1, r24
    3fca:	0c f4       	brge	.+2      	; 0x3fce <st_prep_buffer+0x9fc>
    3fcc:	4b ce       	rjmp	.-874    	; 0x3c64 <st_prep_buffer+0x692>
    3fce:	8e a9       	ldd	r24, Y+54	; 0x36
    3fd0:	8f a3       	std	Y+39, r24	; 0x27
    3fd2:	8d 85       	ldd	r24, Y+13	; 0x0d
    3fd4:	9e 85       	ldd	r25, Y+14	; 0x0e
    3fd6:	af 85       	ldd	r26, Y+15	; 0x0f
    3fd8:	b8 89       	ldd	r27, Y+16	; 0x10
    3fda:	e1 e7       	ldi	r30, 0x71	; 113
    3fdc:	f1 e0       	ldi	r31, 0x01	; 1
    3fde:	80 83       	st	Z, r24
    3fe0:	91 83       	std	Z+1, r25	; 0x01
    3fe2:	a2 83       	std	Z+2, r26	; 0x02
    3fe4:	b3 83       	std	Z+3, r27	; 0x03
    3fe6:	e9 85       	ldd	r30, Y+9	; 0x09
    3fe8:	ac e6       	ldi	r26, 0x6C	; 108
    3fea:	b1 e0       	ldi	r27, 0x01	; 1
    3fec:	ec 93       	st	X, r30
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    3fee:	a0 e6       	ldi	r26, 0x60	; 96
    3ff0:	b1 e0       	ldi	r27, 0x01	; 1
    3ff2:	2d 91       	ld	r18, X+
    3ff4:	3d 91       	ld	r19, X+
    3ff6:	4d 91       	ld	r20, X+
    3ff8:	5c 91       	ld	r21, X
    3ffa:	29 87       	std	Y+9, r18	; 0x09
    3ffc:	3a 87       	std	Y+10, r19	; 0x0a
    3ffe:	4b 87       	std	Y+11, r20	; 0x0b
    4000:	5c 87       	std	Y+12, r21	; 0x0c
    4002:	2d a9       	ldd	r18, Y+53	; 0x35
    4004:	3f a1       	ldd	r19, Y+39	; 0x27
    4006:	40 2f       	mov	r20, r16
    4008:	51 2f       	mov	r21, r17
    400a:	69 85       	ldd	r22, Y+9	; 0x09
    400c:	7a 85       	ldd	r23, Y+10	; 0x0a
    400e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4010:	9c 85       	ldd	r25, Y+12	; 0x0c
    4012:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    4016:	2b 01       	movw	r4, r22
    4018:	3c 01       	movw	r6, r24
    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining
    401a:	0e 94 49 39 	call	0x7292	; 0x7292 <ceil>
    401e:	6d 83       	std	Y+5, r22	; 0x05
    4020:	7e 83       	std	Y+6, r23	; 0x06
    4022:	8f 83       	std	Y+7, r24	; 0x07
    4024:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    4026:	ec e5       	ldi	r30, 0x5C	; 92
    4028:	f1 e0       	ldi	r31, 0x01	; 1
    402a:	60 81       	ld	r22, Z
    402c:	71 81       	ldd	r23, Z+1	; 0x01
    402e:	82 81       	ldd	r24, Z+2	; 0x02
    4030:	93 81       	ldd	r25, Z+3	; 0x03
    4032:	0e 94 49 39 	call	0x7292	; 0x7292 <ceil>
    4036:	4b 01       	movw	r8, r22
    4038:	5c 01       	movw	r10, r24
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    403a:	2d 81       	ldd	r18, Y+5	; 0x05
    403c:	3e 81       	ldd	r19, Y+6	; 0x06
    403e:	4f 81       	ldd	r20, Y+7	; 0x07
    4040:	58 85       	ldd	r21, Y+8	; 0x08
    4042:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    4046:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    404a:	69 83       	std	Y+1, r22	; 0x01
    404c:	7a 83       	std	Y+2, r23	; 0x02
    404e:	8b 83       	std	Y+3, r24	; 0x03
    4050:	9c 83       	std	Y+4, r25	; 0x04
    4052:	e9 81       	ldd	r30, Y+1	; 0x01
    4054:	fa 81       	ldd	r31, Y+2	; 0x02
    4056:	ab a5       	ldd	r26, Y+43	; 0x2b
    4058:	bc a5       	ldd	r27, Y+44	; 0x2c
    405a:	ed 93       	st	X+, r30
    405c:	fc 93       	st	X, r31
    
    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    405e:	30 97       	sbiw	r30, 0x00	; 0
    4060:	a9 f5       	brne	.+106    	; 0x40cc <st_prep_buffer+0xafa>
      if (sys.state == STATE_HOLD) {
    4062:	a4 e8       	ldi	r26, 0x84	; 132
    4064:	b5 e0       	ldi	r27, 0x05	; 5
    4066:	8c 91       	ld	r24, X
    4068:	80 32       	cpi	r24, 0x20	; 32
    406a:	81 f5       	brne	.+96     	; 0x40cc <st_prep_buffer+0xafa>
    406c:	4d 80       	ldd	r4, Y+5	; 0x05
    406e:	5e 80       	ldd	r5, Y+6	; 0x06
    4070:	6f 80       	ldd	r6, Y+7	; 0x07
    4072:	78 84       	ldd	r7, Y+8	; 0x08

        // Less than one step to decelerate to zero speed, but already very close. AMASS 
        // requires full steps to execute. So, just bail.
        prep.current_speed = 0.0;
    4074:	10 92 71 01 	sts	0x0171, r1
    4078:	10 92 72 01 	sts	0x0172, r1
    407c:	10 92 73 01 	sts	0x0173, r1
    4080:	10 92 74 01 	sts	0x0174, r1
        prep.dt_remainder = 0.0;
    4084:	10 92 68 01 	sts	0x0168, r1
    4088:	10 92 69 01 	sts	0x0169, r1
    408c:	10 92 6a 01 	sts	0x016A, r1
    4090:	10 92 6b 01 	sts	0x016B, r1
        prep.steps_remaining = n_steps_remaining;
    4094:	40 92 5c 01 	sts	0x015C, r4
    4098:	50 92 5d 01 	sts	0x015D, r5
    409c:	60 92 5e 01 	sts	0x015E, r6
    40a0:	70 92 5f 01 	sts	0x015F, r7
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    40a4:	29 85       	ldd	r18, Y+9	; 0x09
    40a6:	3a 85       	ldd	r19, Y+10	; 0x0a
    40a8:	4b 85       	ldd	r20, Y+11	; 0x0b
    40aa:	5c 85       	ldd	r21, Y+12	; 0x0c
    40ac:	c3 01       	movw	r24, r6
    40ae:	b2 01       	movw	r22, r4
    40b0:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    40b4:	ed 89       	ldd	r30, Y+21	; 0x15
    40b6:	fe 89       	ldd	r31, Y+22	; 0x16
    40b8:	65 a3       	std	Z+37, r22	; 0x25
    40ba:	76 a3       	std	Z+38, r23	; 0x26
    40bc:	87 a3       	std	Z+39, r24	; 0x27
    40be:	90 a7       	std	Z+40, r25	; 0x28
        plan_cycle_reinitialize();         
    40c0:	0e 94 11 2a 	call	0x5422	; 0x5422 <plan_cycle_reinitialize>
        sys.state = STATE_QUEUED; 
    40c4:	88 e0       	ldi	r24, 0x08	; 8
    40c6:	80 93 84 05 	sts	0x0584, r24
        return; // Segment not generated, but current step data still retained.
    40ca:	08 c1       	rjmp	.+528    	; 0x42dc <st_prep_buffer+0xd0a>
    // compensate, we track the time to execute the previous segment's partial step and simply
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are 
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    40cc:	0f 2e       	mov	r0, r31
    40ce:	f8 e6       	ldi	r31, 0x68	; 104
    40d0:	2f 2e       	mov	r2, r31
    40d2:	f1 e0       	ldi	r31, 0x01	; 1
    40d4:	3f 2e       	mov	r3, r31
    40d6:	f0 2d       	mov	r31, r0
    40d8:	d1 01       	movw	r26, r2
    40da:	2d 91       	ld	r18, X+
    40dc:	3d 91       	ld	r19, X+
    40de:	4d 91       	ld	r20, X+
    40e0:	5c 91       	ld	r21, X
    40e2:	c7 01       	movw	r24, r14
    40e4:	b6 01       	movw	r22, r12
    40e6:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    40ea:	6b 01       	movw	r12, r22
    40ec:	7c 01       	movw	r14, r24
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
    40ee:	a3 01       	movw	r20, r6
    40f0:	92 01       	movw	r18, r4
    40f2:	c5 01       	movw	r24, r10
    40f4:	b4 01       	movw	r22, r8
    40f6:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    40fa:	9b 01       	movw	r18, r22
    40fc:	ac 01       	movw	r20, r24
    40fe:	c7 01       	movw	r24, r14
    4100:	b6 01       	movw	r22, r12
    4102:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    4106:	6b 01       	movw	r12, r22
    4108:	7c 01       	movw	r14, r24
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time
    410a:	a3 01       	movw	r20, r6
    410c:	92 01       	movw	r18, r4
    410e:	6d 81       	ldd	r22, Y+5	; 0x05
    4110:	7e 81       	ldd	r23, Y+6	; 0x06
    4112:	8f 81       	ldd	r24, Y+7	; 0x07
    4114:	98 85       	ldd	r25, Y+8	; 0x08
    4116:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    411a:	a7 01       	movw	r20, r14
    411c:	96 01       	movw	r18, r12
    411e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    4122:	f1 01       	movw	r30, r2
    4124:	60 83       	st	Z, r22
    4126:	71 83       	std	Z+1, r23	; 0x01
    4128:	82 83       	std	Z+2, r24	; 0x02
    412a:	93 83       	std	Z+3, r25	; 0x03

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)    
    412c:	20 ec       	ldi	r18, 0xC0	; 192
    412e:	31 ee       	ldi	r19, 0xE1	; 225
    4130:	44 e6       	ldi	r20, 0x64	; 100
    4132:	5e e4       	ldi	r21, 0x4E	; 78
    4134:	c7 01       	movw	r24, r14
    4136:	b6 01       	movw	r22, r12
    4138:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    413c:	0e 94 49 39 	call	0x7292	; 0x7292 <ceil>
    4140:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    4144:	60 3d       	cpi	r22, 0xD0	; 208
    4146:	f7 e0       	ldi	r31, 0x07	; 7
    4148:	7f 07       	cpc	r23, r31
    414a:	81 05       	cpc	r24, r1
    414c:	91 05       	cpc	r25, r1
    414e:	28 f4       	brcc	.+10     	; 0x415a <st_prep_buffer+0xb88>
    4150:	ab a5       	ldd	r26, Y+43	; 0x2b
    4152:	bc a5       	ldd	r27, Y+44	; 0x2c
    4154:	15 96       	adiw	r26, 0x05	; 5
    4156:	1c 92       	st	X, r1
    4158:	31 c0       	rjmp	.+98     	; 0x41bc <st_prep_buffer+0xbea>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    415a:	60 3a       	cpi	r22, 0xA0	; 160
    415c:	bf e0       	ldi	r27, 0x0F	; 15
    415e:	7b 07       	cpc	r23, r27
    4160:	81 05       	cpc	r24, r1
    4162:	91 05       	cpc	r25, r1
    4164:	28 f4       	brcc	.+10     	; 0x4170 <st_prep_buffer+0xb9e>
    4166:	21 e0       	ldi	r18, 0x01	; 1
    4168:	eb a5       	ldd	r30, Y+43	; 0x2b
    416a:	fc a5       	ldd	r31, Y+44	; 0x2c
    416c:	25 83       	std	Z+5, r18	; 0x05
    416e:	10 c0       	rjmp	.+32     	; 0x4190 <st_prep_buffer+0xbbe>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    4170:	60 34       	cpi	r22, 0x40	; 64
    4172:	ff e1       	ldi	r31, 0x1F	; 31
    4174:	7f 07       	cpc	r23, r31
    4176:	81 05       	cpc	r24, r1
    4178:	91 05       	cpc	r25, r1
    417a:	30 f4       	brcc	.+12     	; 0x4188 <st_prep_buffer+0xbb6>
    417c:	22 e0       	ldi	r18, 0x02	; 2
    417e:	ab a5       	ldd	r26, Y+43	; 0x2b
    4180:	bc a5       	ldd	r27, Y+44	; 0x2c
    4182:	15 96       	adiw	r26, 0x05	; 5
    4184:	2c 93       	st	X, r18
    4186:	04 c0       	rjmp	.+8      	; 0x4190 <st_prep_buffer+0xbbe>
        else { prep_segment->amass_level = 3; }    
    4188:	23 e0       	ldi	r18, 0x03	; 3
    418a:	eb a5       	ldd	r30, Y+43	; 0x2b
    418c:	fc a5       	ldd	r31, Y+44	; 0x2c
    418e:	25 83       	std	Z+5, r18	; 0x05
        cycles >>= prep_segment->amass_level; 
    4190:	ab a5       	ldd	r26, Y+43	; 0x2b
    4192:	bc a5       	ldd	r27, Y+44	; 0x2c
    4194:	15 96       	adiw	r26, 0x05	; 5
    4196:	2c 91       	ld	r18, X
    4198:	15 97       	sbiw	r26, 0x05	; 5
    419a:	02 2e       	mov	r0, r18
    419c:	04 c0       	rjmp	.+8      	; 0x41a6 <st_prep_buffer+0xbd4>
    419e:	96 95       	lsr	r25
    41a0:	87 95       	ror	r24
    41a2:	77 95       	ror	r23
    41a4:	67 95       	ror	r22
    41a6:	0a 94       	dec	r0
    41a8:	d2 f7       	brpl	.-12     	; 0x419e <st_prep_buffer+0xbcc>
        prep_segment->n_step <<= prep_segment->amass_level;
    41aa:	e9 81       	ldd	r30, Y+1	; 0x01
    41ac:	fa 81       	ldd	r31, Y+2	; 0x02
    41ae:	02 c0       	rjmp	.+4      	; 0x41b4 <st_prep_buffer+0xbe2>
    41b0:	ee 0f       	add	r30, r30
    41b2:	ff 1f       	adc	r31, r31
    41b4:	2a 95       	dec	r18
    41b6:	e2 f7       	brpl	.-8      	; 0x41b0 <st_prep_buffer+0xbde>
    41b8:	ed 93       	st	X+, r30
    41ba:	fc 93       	st	X, r31
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    41bc:	61 15       	cp	r22, r1
    41be:	71 05       	cpc	r23, r1
    41c0:	f1 e0       	ldi	r31, 0x01	; 1
    41c2:	8f 07       	cpc	r24, r31
    41c4:	91 05       	cpc	r25, r1
    41c6:	38 f4       	brcc	.+14     	; 0x41d6 <st_prep_buffer+0xc04>
    41c8:	ab a5       	ldd	r26, Y+43	; 0x2b
    41ca:	bc a5       	ldd	r27, Y+44	; 0x2c
    41cc:	14 96       	adiw	r26, 0x04	; 4
    41ce:	7c 93       	st	X, r23
    41d0:	6e 93       	st	-X, r22
    41d2:	13 97       	sbiw	r26, 0x03	; 3
    41d4:	06 c0       	rjmp	.+12     	; 0x41e2 <st_prep_buffer+0xc10>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    41d6:	8f ef       	ldi	r24, 0xFF	; 255
    41d8:	9f ef       	ldi	r25, 0xFF	; 255
    41da:	eb a5       	ldd	r30, Y+43	; 0x2b
    41dc:	fc a5       	ldd	r31, Y+44	; 0x2c
    41de:	94 83       	std	Z+4, r25	; 0x04
    41e0:	83 83       	std	Z+3, r24	; 0x03
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices.
    segment_buffer_head = segment_next_head;
    41e2:	80 91 8c 01 	lds	r24, 0x018C
    41e6:	80 93 8d 01 	sts	0x018D, r24
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    41ea:	8f 5f       	subi	r24, 0xFF	; 255
    41ec:	86 30       	cpi	r24, 0x06	; 6
    41ee:	19 f0       	breq	.+6      	; 0x41f6 <st_prep_buffer+0xc24>
    41f0:	80 93 8c 01 	sts	0x018C, r24
    41f4:	02 c0       	rjmp	.+4      	; 0x41fa <st_prep_buffer+0xc28>
    41f6:	10 92 8c 01 	sts	0x018C, r1

    // Setup initial conditions for next segment.
    if (mm_remaining > prep.mm_complete) { 
    41fa:	2d a9       	ldd	r18, Y+53	; 0x35
    41fc:	3f a1       	ldd	r19, Y+39	; 0x27
    41fe:	40 2f       	mov	r20, r16
    4200:	51 2f       	mov	r21, r17
    4202:	ad e6       	ldi	r26, 0x6D	; 109
    4204:	b1 e0       	ldi	r27, 0x01	; 1
    4206:	6d 91       	ld	r22, X+
    4208:	7d 91       	ld	r23, X+
    420a:	8d 91       	ld	r24, X+
    420c:	9c 91       	ld	r25, X
    420e:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    4212:	88 23       	and	r24, r24
    4214:	9c f4       	brge	.+38     	; 0x423c <st_prep_buffer+0xc6a>
      // Normal operation. Block incomplete. Distance remaining in block to be executed.
      pl_block->millimeters = mm_remaining;      
    4216:	e0 91 87 01 	lds	r30, 0x0187
    421a:	f0 91 88 01 	lds	r31, 0x0188
    421e:	8d a9       	ldd	r24, Y+53	; 0x35
    4220:	9f a1       	ldd	r25, Y+39	; 0x27
    4222:	a0 2f       	mov	r26, r16
    4224:	b1 2f       	mov	r27, r17
    4226:	85 a3       	std	Z+37, r24	; 0x25
    4228:	96 a3       	std	Z+38, r25	; 0x26
    422a:	a7 a3       	std	Z+39, r26	; 0x27
    422c:	b0 a7       	std	Z+40, r27	; 0x28
      prep.steps_remaining = steps_remaining;  
    422e:	ec e5       	ldi	r30, 0x5C	; 92
    4230:	f1 e0       	ldi	r31, 0x01	; 1
    4232:	40 82       	st	Z, r4
    4234:	51 82       	std	Z+1, r5	; 0x01
    4236:	62 82       	std	Z+2, r6	; 0x02
    4238:	73 82       	std	Z+3, r7	; 0x03
    423a:	4a c0       	rjmp	.+148    	; 0x42d0 <st_prep_buffer+0xcfe>
    } else { 
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    423c:	20 e0       	ldi	r18, 0x00	; 0
    423e:	30 e0       	ldi	r19, 0x00	; 0
    4240:	a9 01       	movw	r20, r18
    4242:	6d a9       	ldd	r22, Y+53	; 0x35
    4244:	7f a1       	ldd	r23, Y+39	; 0x27
    4246:	80 2f       	mov	r24, r16
    4248:	91 2f       	mov	r25, r17
    424a:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    424e:	18 16       	cp	r1, r24
    4250:	cc f5       	brge	.+114    	; 0x42c4 <st_prep_buffer+0xcf2>
    4252:	4d 80       	ldd	r4, Y+5	; 0x05
    4254:	5e 80       	ldd	r5, Y+6	; 0x06
    4256:	6f 80       	ldd	r6, Y+7	; 0x07
    4258:	78 84       	ldd	r7, Y+8	; 0x08
        // Reset prep parameters for resuming and then bail.
        // NOTE: Currently only feed holds qualify for this scenario. May change with overrides.       
        prep.current_speed = 0.0;
    425a:	10 92 71 01 	sts	0x0171, r1
    425e:	10 92 72 01 	sts	0x0172, r1
    4262:	10 92 73 01 	sts	0x0173, r1
    4266:	10 92 74 01 	sts	0x0174, r1
        prep.dt_remainder = 0.0;
    426a:	10 92 68 01 	sts	0x0168, r1
    426e:	10 92 69 01 	sts	0x0169, r1
    4272:	10 92 6a 01 	sts	0x016A, r1
    4276:	10 92 6b 01 	sts	0x016B, r1
        prep.steps_remaining = ceil(steps_remaining);
    427a:	40 92 5c 01 	sts	0x015C, r4
    427e:	50 92 5d 01 	sts	0x015D, r5
    4282:	60 92 5e 01 	sts	0x015E, r6
    4286:	70 92 5f 01 	sts	0x015F, r7
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    428a:	00 91 87 01 	lds	r16, 0x0187
    428e:	10 91 88 01 	lds	r17, 0x0188
    4292:	20 91 60 01 	lds	r18, 0x0160
    4296:	30 91 61 01 	lds	r19, 0x0161
    429a:	40 91 62 01 	lds	r20, 0x0162
    429e:	50 91 63 01 	lds	r21, 0x0163
    42a2:	c3 01       	movw	r24, r6
    42a4:	b2 01       	movw	r22, r4
    42a6:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    42aa:	d8 01       	movw	r26, r16
    42ac:	95 96       	adiw	r26, 0x25	; 37
    42ae:	6d 93       	st	X+, r22
    42b0:	7d 93       	st	X+, r23
    42b2:	8d 93       	st	X+, r24
    42b4:	9c 93       	st	X, r25
    42b6:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize(); 
    42b8:	0e 94 11 2a 	call	0x5422	; 0x5422 <plan_cycle_reinitialize>
        sys.state = STATE_QUEUED; // End cycle.        
    42bc:	88 e0       	ldi	r24, 0x08	; 8
    42be:	80 93 84 05 	sts	0x0584, r24

        return; // Bail!
    42c2:	0c c0       	rjmp	.+24     	; 0x42dc <st_prep_buffer+0xd0a>
// TODO: Try to move QUEUED setting into cycle re-initialize.

      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        pl_block = NULL;
    42c4:	10 92 88 01 	sts	0x0188, r1
    42c8:	10 92 87 01 	sts	0x0187, r1
        plan_discard_current_block();
    42cc:	0e 94 ad 26 	call	0x4d5a	; 0x4d5a <plan_discard_current_block>
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    42d0:	90 91 8e 01 	lds	r25, 0x018E
    42d4:	80 91 8c 01 	lds	r24, 0x018C
    42d8:	98 13       	cpse	r25, r24
    42da:	96 c9       	rjmp	.-3284   	; 0x3608 <st_prep_buffer+0x36>
        plan_discard_current_block();
      }
    }

  } 
}      
    42dc:	e6 96       	adiw	r28, 0x36	; 54
    42de:	0f b6       	in	r0, 0x3f	; 63
    42e0:	f8 94       	cli
    42e2:	de bf       	out	0x3e, r29	; 62
    42e4:	0f be       	out	0x3f, r0	; 63
    42e6:	cd bf       	out	0x3d, r28	; 61
    42e8:	df 91       	pop	r29
    42ea:	cf 91       	pop	r28
    42ec:	1f 91       	pop	r17
    42ee:	0f 91       	pop	r16
    42f0:	ff 90       	pop	r15
    42f2:	ef 90       	pop	r14
    42f4:	df 90       	pop	r13
    42f6:	cf 90       	pop	r12
    42f8:	bf 90       	pop	r11
    42fa:	af 90       	pop	r10
    42fc:	9f 90       	pop	r9
    42fe:	8f 90       	pop	r8
    4300:	7f 90       	pop	r7
    4302:	6f 90       	pop	r6
    4304:	5f 90       	pop	r5
    4306:	4f 90       	pop	r4
    4308:	3f 90       	pop	r3
    430a:	2f 90       	pop	r2
    430c:	08 95       	ret

0000430e <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    430e:	f9 99       	sbic	0x1f, 1	; 31
    4310:	fe cf       	rjmp	.-4      	; 0x430e <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    4312:	92 bd       	out	0x22, r25	; 34
    4314:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4316:	81 e0       	ldi	r24, 0x01	; 1
    4318:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    431a:	80 b5       	in	r24, 0x20	; 32
}
    431c:	08 95       	ret

0000431e <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    431e:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    4320:	f9 99       	sbic	0x1f, 1	; 31
    4322:	fe cf       	rjmp	.-4      	; 0x4320 <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    4324:	92 bd       	out	0x22, r25	; 34
    4326:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    4328:	81 e0       	ldi	r24, 0x01	; 1
    432a:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    432c:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    432e:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    4330:	98 2f       	mov	r25, r24
    4332:	96 23       	and	r25, r22
    4334:	59 f0       	breq	.+22     	; 0x434c <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    4336:	6f 3f       	cpi	r22, 0xFF	; 255
    4338:	29 f0       	breq	.+10     	; 0x4344 <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    433a:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    433c:	84 e0       	ldi	r24, 0x04	; 4
    433e:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    4340:	f9 9a       	sbi	0x1f, 1	; 31
    4342:	0a c0       	rjmp	.+20     	; 0x4358 <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4344:	84 e1       	ldi	r24, 0x14	; 20
    4346:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    4348:	f9 9a       	sbi	0x1f, 1	; 31
    434a:	06 c0       	rjmp	.+12     	; 0x4358 <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    434c:	88 23       	and	r24, r24
    434e:	21 f0       	breq	.+8      	; 0x4358 <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    4350:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4352:	84 e2       	ldi	r24, 0x24	; 36
    4354:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4356:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    4358:	78 94       	sei
    435a:	08 95       	ret

0000435c <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    435c:	8f 92       	push	r8
    435e:	9f 92       	push	r9
    4360:	af 92       	push	r10
    4362:	bf 92       	push	r11
    4364:	cf 92       	push	r12
    4366:	df 92       	push	r13
    4368:	ef 92       	push	r14
    436a:	ff 92       	push	r15
    436c:	0f 93       	push	r16
    436e:	1f 93       	push	r17
    4370:	cf 93       	push	r28
    4372:	df 93       	push	r29
    4374:	6c 01       	movw	r12, r24
    4376:	8b 01       	movw	r16, r22
    4378:	5a 01       	movw	r10, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    437a:	41 15       	cp	r20, r1
    437c:	51 05       	cpc	r21, r1
    437e:	11 f1       	breq	.+68     	; 0x43c4 <memcpy_to_eeprom_with_checksum+0x68>
    4380:	ea 01       	movw	r28, r20

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4382:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    4384:	88 24       	eor	r8, r8
    4386:	83 94       	inc	r8
    4388:	91 10       	cpse	r9, r1
    438a:	09 c0       	rjmp	.+18     	; 0x439e <memcpy_to_eeprom_with_checksum+0x42>
    438c:	69 2d       	mov	r22, r9
    438e:	77 27       	eor	r23, r23
    4390:	67 fd       	sbrc	r22, 7
    4392:	70 95       	com	r23
    4394:	97 2e       	mov	r9, r23
    4396:	99 1c       	adc	r9, r9
    4398:	99 24       	eor	r9, r9
    439a:	99 1c       	adc	r9, r9
    439c:	01 c0       	rjmp	.+2      	; 0x43a0 <memcpy_to_eeprom_with_checksum+0x44>
    439e:	98 2c       	mov	r9, r8
    checksum += *source;
    43a0:	f8 01       	movw	r30, r16
    43a2:	61 91       	ld	r22, Z+
    43a4:	8f 01       	movw	r16, r30
    43a6:	96 0e       	add	r9, r22
    eeprom_put_char(destination++, *(source++)); 
    43a8:	7c 01       	movw	r14, r24
    43aa:	ff ef       	ldi	r31, 0xFF	; 255
    43ac:	ef 1a       	sub	r14, r31
    43ae:	ff 0a       	sbc	r15, r31
    43b0:	0e 94 8f 21 	call	0x431e	; 0x431e <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    43b4:	21 97       	sbiw	r28, 0x01	; 1
    43b6:	20 97       	sbiw	r28, 0x00	; 0
    43b8:	11 f0       	breq	.+4      	; 0x43be <memcpy_to_eeprom_with_checksum+0x62>
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    43ba:	c7 01       	movw	r24, r14
    43bc:	e5 cf       	rjmp	.-54     	; 0x4388 <memcpy_to_eeprom_with_checksum+0x2c>
    43be:	ca 0c       	add	r12, r10
    43c0:	db 1c       	adc	r13, r11
    43c2:	01 c0       	rjmp	.+2      	; 0x43c6 <memcpy_to_eeprom_with_checksum+0x6a>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    43c4:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    43c6:	69 2d       	mov	r22, r9
    43c8:	c6 01       	movw	r24, r12
    43ca:	0e 94 8f 21 	call	0x431e	; 0x431e <eeprom_put_char>
}
    43ce:	df 91       	pop	r29
    43d0:	cf 91       	pop	r28
    43d2:	1f 91       	pop	r17
    43d4:	0f 91       	pop	r16
    43d6:	ff 90       	pop	r15
    43d8:	ef 90       	pop	r14
    43da:	df 90       	pop	r13
    43dc:	cf 90       	pop	r12
    43de:	bf 90       	pop	r11
    43e0:	af 90       	pop	r10
    43e2:	9f 90       	pop	r9
    43e4:	8f 90       	pop	r8
    43e6:	08 95       	ret

000043e8 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    43e8:	8f 92       	push	r8
    43ea:	9f 92       	push	r9
    43ec:	af 92       	push	r10
    43ee:	bf 92       	push	r11
    43f0:	cf 92       	push	r12
    43f2:	df 92       	push	r13
    43f4:	ef 92       	push	r14
    43f6:	ff 92       	push	r15
    43f8:	0f 93       	push	r16
    43fa:	1f 93       	push	r17
    43fc:	cf 93       	push	r28
    43fe:	df 93       	push	r29
    4400:	6b 01       	movw	r12, r22
    4402:	5a 01       	movw	r10, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4404:	41 15       	cp	r20, r1
    4406:	51 05       	cpc	r21, r1
    4408:	29 f1       	breq	.+74     	; 0x4454 <memcpy_from_eeprom_with_checksum+0x6c>
    440a:	08 2f       	mov	r16, r24
    440c:	19 2f       	mov	r17, r25
    440e:	ea 01       	movw	r28, r20
    4410:	cb 01       	movw	r24, r22
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4412:	91 2c       	mov	r9, r1
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    4414:	88 24       	eor	r8, r8
    4416:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    4418:	7c 01       	movw	r14, r24
    441a:	2f ef       	ldi	r18, 0xFF	; 255
    441c:	e2 1a       	sub	r14, r18
    441e:	f2 0a       	sbc	r15, r18
    4420:	0e 94 87 21 	call	0x430e	; 0x430e <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    4424:	91 10       	cpse	r9, r1
    4426:	09 c0       	rjmp	.+18     	; 0x443a <memcpy_from_eeprom_with_checksum+0x52>
    4428:	29 2d       	mov	r18, r9
    442a:	33 27       	eor	r19, r19
    442c:	27 fd       	sbrc	r18, 7
    442e:	30 95       	com	r19
    4430:	93 2e       	mov	r9, r19
    4432:	99 1c       	adc	r9, r9
    4434:	99 24       	eor	r9, r9
    4436:	99 1c       	adc	r9, r9
    4438:	01 c0       	rjmp	.+2      	; 0x443c <memcpy_from_eeprom_with_checksum+0x54>
    443a:	98 2c       	mov	r9, r8
    checksum += data;    
    443c:	98 0e       	add	r9, r24
    *(destination++) = data; 
    443e:	f8 01       	movw	r30, r16
    4440:	81 93       	st	Z+, r24
    4442:	8f 01       	movw	r16, r30
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4444:	21 97       	sbiw	r28, 0x01	; 1
    4446:	20 97       	sbiw	r28, 0x00	; 0
    4448:	11 f0       	breq	.+4      	; 0x444e <memcpy_from_eeprom_with_checksum+0x66>
    data = eeprom_get_char(source++);
    444a:	c7 01       	movw	r24, r14
    444c:	e5 cf       	rjmp	.-54     	; 0x4418 <memcpy_from_eeprom_with_checksum+0x30>
    444e:	ca 0c       	add	r12, r10
    4450:	db 1c       	adc	r13, r11
    4452:	01 c0       	rjmp	.+2      	; 0x4456 <memcpy_from_eeprom_with_checksum+0x6e>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    4454:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4456:	c6 01       	movw	r24, r12
    4458:	0e 94 87 21 	call	0x430e	; 0x430e <eeprom_get_char>
    445c:	41 e0       	ldi	r20, 0x01	; 1
    445e:	50 e0       	ldi	r21, 0x00	; 0
    4460:	89 15       	cp	r24, r9
    4462:	11 f0       	breq	.+4      	; 0x4468 <memcpy_from_eeprom_with_checksum+0x80>
    4464:	40 e0       	ldi	r20, 0x00	; 0
    4466:	50 e0       	ldi	r21, 0x00	; 0
}
    4468:	ca 01       	movw	r24, r20
    446a:	df 91       	pop	r29
    446c:	cf 91       	pop	r28
    446e:	1f 91       	pop	r17
    4470:	0f 91       	pop	r16
    4472:	ff 90       	pop	r15
    4474:	ef 90       	pop	r14
    4476:	df 90       	pop	r13
    4478:	cf 90       	pop	r12
    447a:	bf 90       	pop	r11
    447c:	af 90       	pop	r10
    447e:	9f 90       	pop	r9
    4480:	8f 90       	pop	r8
    4482:	08 95       	ret

00004484 <settings_store_startup_line>:


// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
  uint16_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    4484:	21 e5       	ldi	r18, 0x51	; 81
    4486:	82 9f       	mul	r24, r18
    4488:	c0 01       	movw	r24, r0
    448a:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    448c:	40 e5       	ldi	r20, 0x50	; 80
    448e:	50 e0       	ldi	r21, 0x00	; 0
    4490:	9d 5f       	subi	r25, 0xFD	; 253
    4492:	0e 94 ae 21 	call	0x435c	; 0x435c <memcpy_to_eeprom_with_checksum>
    4496:	08 95       	ret

00004498 <settings_store_build_info>:


// Method to store build info into EEPROM
void settings_store_build_info(char *line)
{
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    4498:	40 e5       	ldi	r20, 0x50	; 80
    449a:	50 e0       	ldi	r21, 0x00	; 0
    449c:	bc 01       	movw	r22, r24
    449e:	80 ee       	ldi	r24, 0xE0	; 224
    44a0:	93 e0       	ldi	r25, 0x03	; 3
    44a2:	0e 94 ae 21 	call	0x435c	; 0x435c <memcpy_to_eeprom_with_checksum>
    44a6:	08 95       	ret

000044a8 <settings_write_coord_data>:


// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{  
  uint16_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    44a8:	2d e0       	ldi	r18, 0x0D	; 13
    44aa:	82 9f       	mul	r24, r18
    44ac:	c0 01       	movw	r24, r0
    44ae:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    44b0:	4c e0       	ldi	r20, 0x0C	; 12
    44b2:	50 e0       	ldi	r21, 0x00	; 0
    44b4:	9e 5f       	subi	r25, 0xFE	; 254
    44b6:	0e 94 ae 21 	call	0x435c	; 0x435c <memcpy_to_eeprom_with_checksum>
    44ba:	08 95       	ret

000044bc <settings_write_tool_data>:
}  

// Method to store tool parameters into EEPROM
void settings_write_tool_data(uint8_t tool_select, gc_tools_t *tool_data)
{
  uint16_t addr = tool_select*(sizeof(gc_tools_t)+1) + EEPROM_ADDR_TOOLS;
    44bc:	21 e1       	ldi	r18, 0x11	; 17
    44be:	82 9f       	mul	r24, r18
    44c0:	c0 01       	movw	r24, r0
    44c2:	11 24       	eor	r1, r1
  memcpy_to_eeprom_with_checksum(addr,(char*)tool_data, sizeof(gc_tools_t));
    44c4:	40 e1       	ldi	r20, 0x10	; 16
    44c6:	50 e0       	ldi	r21, 0x00	; 0
    44c8:	80 58       	subi	r24, 0x80	; 128
    44ca:	9e 4f       	sbci	r25, 0xFE	; 254
    44cc:	0e 94 ae 21 	call	0x435c	; 0x435c <memcpy_to_eeprom_with_checksum>
    44d0:	08 95       	ret

000044d2 <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
void write_global_settings() 
{
  eeprom_put_char(0, SETTINGS_VERSION);
    44d2:	69 e0       	ldi	r22, 0x09	; 9
    44d4:	80 e0       	ldi	r24, 0x00	; 0
    44d6:	90 e0       	ldi	r25, 0x00	; 0
    44d8:	0e 94 8f 21 	call	0x431e	; 0x431e <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    44dc:	4d e4       	ldi	r20, 0x4D	; 77
    44de:	50 e0       	ldi	r21, 0x00	; 0
    44e0:	60 e4       	ldi	r22, 0x40	; 64
    44e2:	77 e0       	ldi	r23, 0x07	; 7
    44e4:	81 e0       	ldi	r24, 0x01	; 1
    44e6:	90 e0       	ldi	r25, 0x00	; 0
    44e8:	0e 94 ae 21 	call	0x435c	; 0x435c <memcpy_to_eeprom_with_checksum>
    44ec:	08 95       	ret

000044ee <settings_reset>:
}


// Method to reset Grbl global settings back to defaults. 
void settings_reset() {
  settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
    44ee:	8a e0       	ldi	r24, 0x0A	; 10
    44f0:	80 93 70 07 	sts	0x0770, r24
  settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
    44f4:	89 e1       	ldi	r24, 0x19	; 25
    44f6:	80 93 73 07 	sts	0x0773, r24
  settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
    44fa:	10 92 71 07 	sts	0x0771, r1
  settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
    44fe:	86 e0       	ldi	r24, 0x06	; 6
    4500:	80 93 72 07 	sts	0x0772, r24
  settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
    4504:	83 e0       	ldi	r24, 0x03	; 3
    4506:	80 93 74 07 	sts	0x0774, r24
  settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
    450a:	8a e0       	ldi	r24, 0x0A	; 10
    450c:	97 ed       	ldi	r25, 0xD7	; 215
    450e:	a3 ea       	ldi	r26, 0xA3	; 163
    4510:	bc e3       	ldi	r27, 0x3C	; 60
    4512:	80 93 75 07 	sts	0x0775, r24
    4516:	90 93 76 07 	sts	0x0776, r25
    451a:	a0 93 77 07 	sts	0x0777, r26
    451e:	b0 93 78 07 	sts	0x0778, r27
  settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
    4522:	8f e6       	ldi	r24, 0x6F	; 111
    4524:	92 e1       	ldi	r25, 0x12	; 18
    4526:	a3 e0       	ldi	r26, 0x03	; 3
    4528:	bb e3       	ldi	r27, 0x3B	; 59
    452a:	80 93 79 07 	sts	0x0779, r24
    452e:	90 93 7a 07 	sts	0x077A, r25
    4532:	a0 93 7b 07 	sts	0x077B, r26
    4536:	b0 93 7c 07 	sts	0x077C, r27
  settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
    453a:	10 92 7e 07 	sts	0x077E, r1
  settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
    453e:	80 e0       	ldi	r24, 0x00	; 0
    4540:	90 e0       	ldi	r25, 0x00	; 0
    4542:	a8 ec       	ldi	r26, 0xC8	; 200
    4544:	b1 e4       	ldi	r27, 0x41	; 65
    4546:	80 93 7f 07 	sts	0x077F, r24
    454a:	90 93 80 07 	sts	0x0780, r25
    454e:	a0 93 81 07 	sts	0x0781, r26
    4552:	b0 93 82 07 	sts	0x0782, r27
  settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
    4556:	80 e0       	ldi	r24, 0x00	; 0
    4558:	90 e0       	ldi	r25, 0x00	; 0
    455a:	aa ef       	ldi	r26, 0xFA	; 250
    455c:	b3 e4       	ldi	r27, 0x43	; 67
    455e:	80 93 83 07 	sts	0x0783, r24
    4562:	90 93 84 07 	sts	0x0784, r25
    4566:	a0 93 85 07 	sts	0x0785, r26
    456a:	b0 93 86 07 	sts	0x0786, r27
  settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
    456e:	2a ef       	ldi	r18, 0xFA	; 250
    4570:	30 e0       	ldi	r19, 0x00	; 0
    4572:	30 93 88 07 	sts	0x0788, r19
    4576:	20 93 87 07 	sts	0x0787, r18
  settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
    457a:	40 e0       	ldi	r20, 0x00	; 0
    457c:	50 e0       	ldi	r21, 0x00	; 0
    457e:	60 e8       	ldi	r22, 0x80	; 128
    4580:	7f e3       	ldi	r23, 0x3F	; 63
    4582:	40 93 89 07 	sts	0x0789, r20
    4586:	50 93 8a 07 	sts	0x078A, r21
    458a:	60 93 8b 07 	sts	0x078B, r22
    458e:	70 93 8c 07 	sts	0x078C, r23

  settings.flags = 0;
  if (DEFAULT_REPORT_INCHES) { settings.flags |= BITFLAG_REPORT_INCHES; }
  if (DEFAULT_AUTO_START) { settings.flags |= BITFLAG_AUTO_START; }
    4592:	22 e0       	ldi	r18, 0x02	; 2
    4594:	20 93 7d 07 	sts	0x077D, r18
  if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
  if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
  if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
  if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
  
  settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
    4598:	40 e0       	ldi	r20, 0x00	; 0
    459a:	50 e0       	ldi	r21, 0x00	; 0
    459c:	6a e7       	ldi	r22, 0x7A	; 122
    459e:	73 e4       	ldi	r23, 0x43	; 67
    45a0:	40 93 40 07 	sts	0x0740, r20
    45a4:	50 93 41 07 	sts	0x0741, r21
    45a8:	60 93 42 07 	sts	0x0742, r22
    45ac:	70 93 43 07 	sts	0x0743, r23
  settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
    45b0:	40 93 44 07 	sts	0x0744, r20
    45b4:	50 93 45 07 	sts	0x0745, r21
    45b8:	60 93 46 07 	sts	0x0746, r22
    45bc:	70 93 47 07 	sts	0x0747, r23
  settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
    45c0:	40 93 48 07 	sts	0x0748, r20
    45c4:	50 93 49 07 	sts	0x0749, r21
    45c8:	60 93 4a 07 	sts	0x074A, r22
    45cc:	70 93 4b 07 	sts	0x074B, r23
  settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
    45d0:	80 93 4c 07 	sts	0x074C, r24
    45d4:	90 93 4d 07 	sts	0x074D, r25
    45d8:	a0 93 4e 07 	sts	0x074E, r26
    45dc:	b0 93 4f 07 	sts	0x074F, r27
  settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
    45e0:	80 93 50 07 	sts	0x0750, r24
    45e4:	90 93 51 07 	sts	0x0751, r25
    45e8:	a0 93 52 07 	sts	0x0752, r26
    45ec:	b0 93 53 07 	sts	0x0753, r27
  settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
    45f0:	80 93 54 07 	sts	0x0754, r24
    45f4:	90 93 55 07 	sts	0x0755, r25
    45f8:	a0 93 56 07 	sts	0x0756, r26
    45fc:	b0 93 57 07 	sts	0x0757, r27
  settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
    4600:	80 e0       	ldi	r24, 0x00	; 0
    4602:	90 ea       	ldi	r25, 0xA0	; 160
    4604:	ac e0       	ldi	r26, 0x0C	; 12
    4606:	b7 e4       	ldi	r27, 0x47	; 71
    4608:	80 93 58 07 	sts	0x0758, r24
    460c:	90 93 59 07 	sts	0x0759, r25
    4610:	a0 93 5a 07 	sts	0x075A, r26
    4614:	b0 93 5b 07 	sts	0x075B, r27
  settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
    4618:	80 93 5c 07 	sts	0x075C, r24
    461c:	90 93 5d 07 	sts	0x075D, r25
    4620:	a0 93 5e 07 	sts	0x075E, r26
    4624:	b0 93 5f 07 	sts	0x075F, r27
  settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
    4628:	80 93 60 07 	sts	0x0760, r24
    462c:	90 93 61 07 	sts	0x0761, r25
    4630:	a0 93 62 07 	sts	0x0762, r26
    4634:	b0 93 63 07 	sts	0x0763, r27
  settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
    4638:	80 e0       	ldi	r24, 0x00	; 0
    463a:	90 e0       	ldi	r25, 0x00	; 0
    463c:	a8 e4       	ldi	r26, 0x48	; 72
    463e:	b3 ec       	ldi	r27, 0xC3	; 195
    4640:	80 93 64 07 	sts	0x0764, r24
    4644:	90 93 65 07 	sts	0x0765, r25
    4648:	a0 93 66 07 	sts	0x0766, r26
    464c:	b0 93 67 07 	sts	0x0767, r27
  settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
    4650:	80 93 68 07 	sts	0x0768, r24
    4654:	90 93 69 07 	sts	0x0769, r25
    4658:	a0 93 6a 07 	sts	0x076A, r26
    465c:	b0 93 6b 07 	sts	0x076B, r27
  settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    
    4660:	80 93 6c 07 	sts	0x076C, r24
    4664:	90 93 6d 07 	sts	0x076D, r25
    4668:	a0 93 6e 07 	sts	0x076E, r26
    466c:	b0 93 6f 07 	sts	0x076F, r27

  write_global_settings();
    4670:	0e 94 69 22 	call	0x44d2	; 0x44d2 <write_global_settings>
    4674:	08 95       	ret

00004676 <settings_read_startup_line>:
}


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    4676:	1f 93       	push	r17
    4678:	cf 93       	push	r28
    467a:	df 93       	push	r29
    467c:	18 2f       	mov	r17, r24
    467e:	eb 01       	movw	r28, r22
  uint16_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
    4680:	81 e5       	ldi	r24, 0x51	; 81
    4682:	18 9f       	mul	r17, r24
    4684:	b0 01       	movw	r22, r0
    4686:	11 24       	eor	r1, r1
    4688:	7d 5f       	subi	r23, 0xFD	; 253
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    468a:	40 e5       	ldi	r20, 0x50	; 80
    468c:	50 e0       	ldi	r21, 0x00	; 0
    468e:	ce 01       	movw	r24, r28
    4690:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <memcpy_from_eeprom_with_checksum>
    4694:	89 2b       	or	r24, r25
    4696:	39 f4       	brne	.+14     	; 0x46a6 <settings_read_startup_line+0x30>
    // Reset line with default value
    line[0] = 0; // Empty line
    4698:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    469a:	be 01       	movw	r22, r28
    469c:	81 2f       	mov	r24, r17
    469e:	0e 94 42 22 	call	0x4484	; 0x4484 <settings_store_startup_line>
    return(false);
    46a2:	80 e0       	ldi	r24, 0x00	; 0
    46a4:	01 c0       	rjmp	.+2      	; 0x46a8 <settings_read_startup_line+0x32>
  } else {
    return(true);
    46a6:	81 e0       	ldi	r24, 0x01	; 1
  }
}
    46a8:	df 91       	pop	r29
    46aa:	cf 91       	pop	r28
    46ac:	1f 91       	pop	r17
    46ae:	08 95       	ret

000046b0 <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    46b0:	cf 93       	push	r28
    46b2:	df 93       	push	r29
    46b4:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    46b6:	40 e5       	ldi	r20, 0x50	; 80
    46b8:	50 e0       	ldi	r21, 0x00	; 0
    46ba:	60 ee       	ldi	r22, 0xE0	; 224
    46bc:	73 e0       	ldi	r23, 0x03	; 3
    46be:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <memcpy_from_eeprom_with_checksum>
    46c2:	89 2b       	or	r24, r25
    46c4:	31 f4       	brne	.+12     	; 0x46d2 <settings_read_build_info+0x22>
    // Reset line with default value
    line[0] = 0; // Empty line
    46c6:	18 82       	st	Y, r1
    settings_store_build_info(line);
    46c8:	ce 01       	movw	r24, r28
    46ca:	0e 94 4c 22 	call	0x4498	; 0x4498 <settings_store_build_info>
    return(false);
    46ce:	80 e0       	ldi	r24, 0x00	; 0
    46d0:	01 c0       	rjmp	.+2      	; 0x46d4 <settings_read_build_info+0x24>
  } else {
    return(true);
    46d2:	81 e0       	ldi	r24, 0x01	; 1
  }
}
    46d4:	df 91       	pop	r29
    46d6:	cf 91       	pop	r28
    46d8:	08 95       	ret

000046da <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    46da:	1f 93       	push	r17
    46dc:	cf 93       	push	r28
    46de:	df 93       	push	r29
    46e0:	18 2f       	mov	r17, r24
    46e2:	eb 01       	movw	r28, r22
  uint16_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
    46e4:	8d e0       	ldi	r24, 0x0D	; 13
    46e6:	18 9f       	mul	r17, r24
    46e8:	b0 01       	movw	r22, r0
    46ea:	11 24       	eor	r1, r1
    46ec:	7e 5f       	subi	r23, 0xFE	; 254
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    46ee:	4c e0       	ldi	r20, 0x0C	; 12
    46f0:	50 e0       	ldi	r21, 0x00	; 0
    46f2:	ce 01       	movw	r24, r28
    46f4:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <memcpy_from_eeprom_with_checksum>
    46f8:	89 2b       	or	r24, r25
    46fa:	59 f4       	brne	.+22     	; 0x4712 <settings_read_coord_data+0x38>
    // Reset with default zero vector
    clear_vector_float(coord_data); 
    46fc:	8c e0       	ldi	r24, 0x0C	; 12
    46fe:	fe 01       	movw	r30, r28
    4700:	11 92       	st	Z+, r1
    4702:	8a 95       	dec	r24
    4704:	e9 f7       	brne	.-6      	; 0x4700 <settings_read_coord_data+0x26>
    settings_write_coord_data(coord_select,coord_data);
    4706:	be 01       	movw	r22, r28
    4708:	81 2f       	mov	r24, r17
    470a:	0e 94 54 22 	call	0x44a8	; 0x44a8 <settings_write_coord_data>
    return(false);
    470e:	80 e0       	ldi	r24, 0x00	; 0
    4710:	01 c0       	rjmp	.+2      	; 0x4714 <settings_read_coord_data+0x3a>
  } else {
    return(true);
    4712:	81 e0       	ldi	r24, 0x01	; 1
  }
}  
    4714:	df 91       	pop	r29
    4716:	cf 91       	pop	r28
    4718:	1f 91       	pop	r17
    471a:	08 95       	ret

0000471c <settings_read_tool_data>:


// Read selected tool data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_tool_data(uint8_t tool_select, gc_tools_t *tool_data)
{
    471c:	1f 93       	push	r17
    471e:	cf 93       	push	r28
    4720:	df 93       	push	r29
    4722:	18 2f       	mov	r17, r24
    4724:	eb 01       	movw	r28, r22
  uint16_t addr = tool_select*(sizeof(gc_tools_t)+1) + EEPROM_ADDR_TOOLS;
    4726:	81 e1       	ldi	r24, 0x11	; 17
    4728:	18 9f       	mul	r17, r24
    472a:	b0 01       	movw	r22, r0
    472c:	11 24       	eor	r1, r1
    472e:	60 58       	subi	r22, 0x80	; 128
    4730:	7e 4f       	sbci	r23, 0xFE	; 254
  if (!(memcpy_from_eeprom_with_checksum((char*)tool_data, addr, sizeof(gc_tools_t)))) {
    4732:	40 e1       	ldi	r20, 0x10	; 16
    4734:	50 e0       	ldi	r21, 0x00	; 0
    4736:	ce 01       	movw	r24, r28
    4738:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <memcpy_from_eeprom_with_checksum>
    473c:	89 2b       	or	r24, r25
    473e:	41 f4       	brne	.+16     	; 0x4750 <settings_read_tool_data+0x34>
    // Reset with default zero vector
    clear_vector(tool_data);
    4740:	19 82       	std	Y+1, r1	; 0x01
    4742:	18 82       	st	Y, r1
    settings_write_tool_data(tool_select,tool_data);
    4744:	be 01       	movw	r22, r28
    4746:	81 2f       	mov	r24, r17
    4748:	0e 94 5e 22 	call	0x44bc	; 0x44bc <settings_write_tool_data>
    return(false);
    474c:	80 e0       	ldi	r24, 0x00	; 0
    474e:	01 c0       	rjmp	.+2      	; 0x4752 <settings_read_tool_data+0x36>
  } else {
    return(true);
    4750:	81 e0       	ldi	r24, 0x01	; 1
  }
}
    4752:	df 91       	pop	r29
    4754:	cf 91       	pop	r28
    4756:	1f 91       	pop	r17
    4758:	08 95       	ret

0000475a <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    475a:	80 e0       	ldi	r24, 0x00	; 0
    475c:	90 e0       	ldi	r25, 0x00	; 0
    475e:	0e 94 87 21 	call	0x430e	; 0x430e <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    4762:	89 30       	cpi	r24, 0x09	; 9
    4764:	69 f4       	brne	.+26     	; 0x4780 <read_global_settings+0x26>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    4766:	4d e4       	ldi	r20, 0x4D	; 77
    4768:	50 e0       	ldi	r21, 0x00	; 0
    476a:	61 e0       	ldi	r22, 0x01	; 1
    476c:	70 e0       	ldi	r23, 0x00	; 0
    476e:	80 e4       	ldi	r24, 0x40	; 64
    4770:	97 e0       	ldi	r25, 0x07	; 7
    4772:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <memcpy_from_eeprom_with_checksum>
    4776:	21 e0       	ldi	r18, 0x01	; 1
    4778:	89 2b       	or	r24, r25
    477a:	19 f4       	brne	.+6      	; 0x4782 <read_global_settings+0x28>
    477c:	20 e0       	ldi	r18, 0x00	; 0
    477e:	01 c0       	rjmp	.+2      	; 0x4782 <read_global_settings+0x28>
      return(false);
    }
  } else {
    return(false); 
    4780:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    4782:	82 2f       	mov	r24, r18
    4784:	08 95       	ret

00004786 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    4786:	cf 92       	push	r12
    4788:	df 92       	push	r13
    478a:	ef 92       	push	r14
    478c:	ff 92       	push	r15
    478e:	cf 93       	push	r28
    4790:	df 93       	push	r29
    4792:	d8 2f       	mov	r29, r24
    4794:	6a 01       	movw	r12, r20
    4796:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    4798:	20 e0       	ldi	r18, 0x00	; 0
    479a:	30 e0       	ldi	r19, 0x00	; 0
    479c:	a9 01       	movw	r20, r18
    479e:	c7 01       	movw	r24, r14
    47a0:	b6 01       	movw	r22, r12
    47a2:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    47a6:	88 23       	and	r24, r24
    47a8:	0c f4       	brge	.+2      	; 0x47ac <settings_store_global_setting+0x26>
    47aa:	e6 c0       	rjmp	.+460    	; 0x4978 <settings_store_global_setting+0x1f2>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    47ac:	d4 36       	cpi	r29, 0x64	; 100
    47ae:	a0 f0       	brcs	.+40     	; 0x47d8 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    47b0:	ec e9       	ldi	r30, 0x9C	; 156
    47b2:	ed 0f       	add	r30, r29
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    47b4:	e3 30       	cpi	r30, 0x03	; 3
    47b6:	20 f0       	brcs	.+8      	; 0x47c0 <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    47b8:	ea 30       	cpi	r30, 0x0A	; 10
    47ba:	08 f0       	brcs	.+2      	; 0x47be <settings_store_global_setting+0x38>
    47bc:	eb c0       	rjmp	.+470    	; 0x4994 <settings_store_global_setting+0x20e>
    47be:	de c0       	rjmp	.+444    	; 0x497c <settings_store_global_setting+0x1f6>
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
        // Valid axis setting found.
        switch (set_idx) {
          case 0: settings.steps_per_mm[parameter] = value; break;
    47c0:	f0 e0       	ldi	r31, 0x00	; 0
    47c2:	ee 0f       	add	r30, r30
    47c4:	ff 1f       	adc	r31, r31
    47c6:	ee 0f       	add	r30, r30
    47c8:	ff 1f       	adc	r31, r31
    47ca:	e0 5c       	subi	r30, 0xC0	; 192
    47cc:	f8 4f       	sbci	r31, 0xF8	; 248
    47ce:	c0 82       	st	Z, r12
    47d0:	d1 82       	std	Z+1, r13	; 0x01
    47d2:	e2 82       	std	Z+2, r14	; 0x02
    47d4:	f3 82       	std	Z+3, r15	; 0x03
    47d6:	cc c0       	rjmp	.+408    	; 0x4970 <settings_store_global_setting+0x1ea>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    47d8:	c7 01       	movw	r24, r14
    47da:	b6 01       	movw	r22, r12
    47dc:	0e 94 68 3c 	call	0x78d0	; 0x78d0 <trunc>
    47e0:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    switch(parameter) {
    47e4:	8d 2f       	mov	r24, r29
    47e6:	90 e0       	ldi	r25, 0x00	; 0
    47e8:	8c 31       	cpi	r24, 0x1C	; 28
    47ea:	91 05       	cpc	r25, r1
    47ec:	08 f0       	brcs	.+2      	; 0x47f0 <settings_store_global_setting+0x6a>
    47ee:	c8 c0       	rjmp	.+400    	; 0x4980 <settings_store_global_setting+0x1fa>
    47f0:	fc 01       	movw	r30, r24
    47f2:	e1 53       	subi	r30, 0x31	; 49
    47f4:	ff 4f       	sbci	r31, 0xFF	; 255
    47f6:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    47fa:	63 30       	cpi	r22, 0x03	; 3
    47fc:	08 f4       	brcc	.+2      	; 0x4800 <settings_store_global_setting+0x7a>
    47fe:	c2 c0       	rjmp	.+388    	; 0x4984 <settings_store_global_setting+0x1fe>
        settings.pulse_microseconds = int_value; break;
    4800:	60 93 70 07 	sts	0x0770, r22
    4804:	b5 c0       	rjmp	.+362    	; 0x4970 <settings_store_global_setting+0x1ea>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    4806:	60 93 73 07 	sts	0x0773, r22
    480a:	b2 c0       	rjmp	.+356    	; 0x4970 <settings_store_global_setting+0x1ea>
      case 2: settings.step_invert_mask = int_value; break;
    480c:	60 93 71 07 	sts	0x0771, r22
    4810:	af c0       	rjmp	.+350    	; 0x4970 <settings_store_global_setting+0x1ea>
      case 3: settings.dir_invert_mask = int_value; break;
    4812:	60 93 72 07 	sts	0x0772, r22
    4816:	ac c0       	rjmp	.+344    	; 0x4970 <settings_store_global_setting+0x1ea>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    4818:	66 23       	and	r22, r22
    481a:	31 f0       	breq	.+12     	; 0x4828 <settings_store_global_setting+0xa2>
    481c:	ed e7       	ldi	r30, 0x7D	; 125
    481e:	f7 e0       	ldi	r31, 0x07	; 7
    4820:	80 81       	ld	r24, Z
    4822:	84 60       	ori	r24, 0x04	; 4
    4824:	80 83       	st	Z, r24
    4826:	a4 c0       	rjmp	.+328    	; 0x4970 <settings_store_global_setting+0x1ea>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    4828:	ed e7       	ldi	r30, 0x7D	; 125
    482a:	f7 e0       	ldi	r31, 0x07	; 7
    482c:	80 81       	ld	r24, Z
    482e:	8b 7f       	andi	r24, 0xFB	; 251
    4830:	80 83       	st	Z, r24
    4832:	9e c0       	rjmp	.+316    	; 0x4970 <settings_store_global_setting+0x1ea>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    4834:	66 23       	and	r22, r22
    4836:	31 f0       	breq	.+12     	; 0x4844 <settings_store_global_setting+0xbe>
    4838:	ed e7       	ldi	r30, 0x7D	; 125
    483a:	f7 e0       	ldi	r31, 0x07	; 7
    483c:	80 81       	ld	r24, Z
    483e:	80 64       	ori	r24, 0x40	; 64
    4840:	80 83       	st	Z, r24
    4842:	96 c0       	rjmp	.+300    	; 0x4970 <settings_store_global_setting+0x1ea>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    4844:	ed e7       	ldi	r30, 0x7D	; 125
    4846:	f7 e0       	ldi	r31, 0x07	; 7
    4848:	80 81       	ld	r24, Z
    484a:	8f 7b       	andi	r24, 0xBF	; 191
    484c:	80 83       	st	Z, r24
    484e:	90 c0       	rjmp	.+288    	; 0x4970 <settings_store_global_setting+0x1ea>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    4850:	66 23       	and	r22, r22
    4852:	31 f0       	breq	.+12     	; 0x4860 <settings_store_global_setting+0xda>
    4854:	ed e7       	ldi	r30, 0x7D	; 125
    4856:	f7 e0       	ldi	r31, 0x07	; 7
    4858:	80 81       	ld	r24, Z
    485a:	80 68       	ori	r24, 0x80	; 128
    485c:	80 83       	st	Z, r24
    485e:	88 c0       	rjmp	.+272    	; 0x4970 <settings_store_global_setting+0x1ea>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    4860:	ed e7       	ldi	r30, 0x7D	; 125
    4862:	f7 e0       	ldi	r31, 0x07	; 7
    4864:	80 81       	ld	r24, Z
    4866:	8f 77       	andi	r24, 0x7F	; 127
    4868:	80 83       	st	Z, r24
    486a:	82 c0       	rjmp	.+260    	; 0x4970 <settings_store_global_setting+0x1ea>
        break;
      case 10: settings.status_report_mask = int_value;
    486c:	60 93 74 07 	sts	0x0774, r22
      case 11: settings.junction_deviation = value; break;
    4870:	c0 92 75 07 	sts	0x0775, r12
    4874:	d0 92 76 07 	sts	0x0776, r13
    4878:	e0 92 77 07 	sts	0x0777, r14
    487c:	f0 92 78 07 	sts	0x0778, r15
    4880:	77 c0       	rjmp	.+238    	; 0x4970 <settings_store_global_setting+0x1ea>
      case 12: settings.arc_tolerance = value; break;
    4882:	c0 92 79 07 	sts	0x0779, r12
    4886:	d0 92 7a 07 	sts	0x077A, r13
    488a:	e0 92 7b 07 	sts	0x077B, r14
    488e:	f0 92 7c 07 	sts	0x077C, r15
    4892:	6e c0       	rjmp	.+220    	; 0x4970 <settings_store_global_setting+0x1ea>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    4894:	66 23       	and	r22, r22
    4896:	31 f0       	breq	.+12     	; 0x48a4 <settings_store_global_setting+0x11e>
    4898:	ed e7       	ldi	r30, 0x7D	; 125
    489a:	f7 e0       	ldi	r31, 0x07	; 7
    489c:	80 81       	ld	r24, Z
    489e:	81 60       	ori	r24, 0x01	; 1
    48a0:	80 83       	st	Z, r24
    48a2:	66 c0       	rjmp	.+204    	; 0x4970 <settings_store_global_setting+0x1ea>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    48a4:	ed e7       	ldi	r30, 0x7D	; 125
    48a6:	f7 e0       	ldi	r31, 0x07	; 7
    48a8:	80 81       	ld	r24, Z
    48aa:	8e 7f       	andi	r24, 0xFE	; 254
    48ac:	80 83       	st	Z, r24
    48ae:	60 c0       	rjmp	.+192    	; 0x4970 <settings_store_global_setting+0x1ea>
        break;
      case 14: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_AUTO_START; }
    48b0:	66 23       	and	r22, r22
    48b2:	31 f0       	breq	.+12     	; 0x48c0 <settings_store_global_setting+0x13a>
    48b4:	ed e7       	ldi	r30, 0x7D	; 125
    48b6:	f7 e0       	ldi	r31, 0x07	; 7
    48b8:	80 81       	ld	r24, Z
    48ba:	82 60       	ori	r24, 0x02	; 2
    48bc:	80 83       	st	Z, r24
    48be:	58 c0       	rjmp	.+176    	; 0x4970 <settings_store_global_setting+0x1ea>
        else { settings.flags &= ~BITFLAG_AUTO_START; }
    48c0:	ed e7       	ldi	r30, 0x7D	; 125
    48c2:	f7 e0       	ldi	r31, 0x07	; 7
    48c4:	80 81       	ld	r24, Z
    48c6:	8d 7f       	andi	r24, 0xFD	; 253
    48c8:	80 83       	st	Z, r24
    48ca:	52 c0       	rjmp	.+164    	; 0x4970 <settings_store_global_setting+0x1ea>
        break;
      case 20:
        if (int_value) { 
    48cc:	66 23       	and	r22, r22
    48ce:	41 f0       	breq	.+16     	; 0x48e0 <settings_store_global_setting+0x15a>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    48d0:	80 91 7d 07 	lds	r24, 0x077D
    48d4:	84 ff       	sbrs	r24, 4
    48d6:	58 c0       	rjmp	.+176    	; 0x4988 <settings_store_global_setting+0x202>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; 
    48d8:	80 62       	ori	r24, 0x20	; 32
    48da:	80 93 7d 07 	sts	0x077D, r24
    48de:	48 c0       	rjmp	.+144    	; 0x4970 <settings_store_global_setting+0x1ea>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    48e0:	ed e7       	ldi	r30, 0x7D	; 125
    48e2:	f7 e0       	ldi	r31, 0x07	; 7
    48e4:	80 81       	ld	r24, Z
    48e6:	8f 7d       	andi	r24, 0xDF	; 223
    48e8:	80 83       	st	Z, r24
    48ea:	42 c0       	rjmp	.+132    	; 0x4970 <settings_store_global_setting+0x1ea>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    48ec:	66 23       	and	r22, r22
    48ee:	31 f0       	breq	.+12     	; 0x48fc <settings_store_global_setting+0x176>
    48f0:	ed e7       	ldi	r30, 0x7D	; 125
    48f2:	f7 e0       	ldi	r31, 0x07	; 7
    48f4:	80 81       	ld	r24, Z
    48f6:	88 60       	ori	r24, 0x08	; 8
    48f8:	80 83       	st	Z, r24
    48fa:	05 c0       	rjmp	.+10     	; 0x4906 <settings_store_global_setting+0x180>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    48fc:	ed e7       	ldi	r30, 0x7D	; 125
    48fe:	f7 e0       	ldi	r31, 0x07	; 7
    4900:	80 81       	ld	r24, Z
    4902:	87 7f       	andi	r24, 0xF7	; 247
    4904:	80 83       	st	Z, r24
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    4906:	0e 94 24 2b 	call	0x5648	; 0x5648 <limits_init>
        break;
    490a:	32 c0       	rjmp	.+100    	; 0x4970 <settings_store_global_setting+0x1ea>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    490c:	66 23       	and	r22, r22
    490e:	31 f0       	breq	.+12     	; 0x491c <settings_store_global_setting+0x196>
    4910:	ed e7       	ldi	r30, 0x7D	; 125
    4912:	f7 e0       	ldi	r31, 0x07	; 7
    4914:	80 81       	ld	r24, Z
    4916:	80 61       	ori	r24, 0x10	; 16
    4918:	80 83       	st	Z, r24
    491a:	2a c0       	rjmp	.+84     	; 0x4970 <settings_store_global_setting+0x1ea>
        else { 
          settings.flags &= ~BITFLAG_HOMING_ENABLE; 
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    491c:	ed e7       	ldi	r30, 0x7D	; 125
    491e:	f7 e0       	ldi	r31, 0x07	; 7
    4920:	80 81       	ld	r24, Z
    4922:	8f 7c       	andi	r24, 0xCF	; 207
    4924:	80 83       	st	Z, r24
    4926:	24 c0       	rjmp	.+72     	; 0x4970 <settings_store_global_setting+0x1ea>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    4928:	60 93 7e 07 	sts	0x077E, r22
    492c:	21 c0       	rjmp	.+66     	; 0x4970 <settings_store_global_setting+0x1ea>
      case 24: settings.homing_feed_rate = value; break;
    492e:	c0 92 7f 07 	sts	0x077F, r12
    4932:	d0 92 80 07 	sts	0x0780, r13
    4936:	e0 92 81 07 	sts	0x0781, r14
    493a:	f0 92 82 07 	sts	0x0782, r15
    493e:	18 c0       	rjmp	.+48     	; 0x4970 <settings_store_global_setting+0x1ea>
      case 25: settings.homing_seek_rate = value; break;
    4940:	c0 92 83 07 	sts	0x0783, r12
    4944:	d0 92 84 07 	sts	0x0784, r13
    4948:	e0 92 85 07 	sts	0x0785, r14
    494c:	f0 92 86 07 	sts	0x0786, r15
    4950:	0f c0       	rjmp	.+30     	; 0x4970 <settings_store_global_setting+0x1ea>
      case 26: settings.homing_debounce_delay = int_value; break;
    4952:	86 2f       	mov	r24, r22
    4954:	90 e0       	ldi	r25, 0x00	; 0
    4956:	90 93 88 07 	sts	0x0788, r25
    495a:	80 93 87 07 	sts	0x0787, r24
    495e:	08 c0       	rjmp	.+16     	; 0x4970 <settings_store_global_setting+0x1ea>
      case 27: settings.homing_pulloff = value; break;
    4960:	c0 92 89 07 	sts	0x0789, r12
    4964:	d0 92 8a 07 	sts	0x078A, r13
    4968:	e0 92 8b 07 	sts	0x078B, r14
    496c:	f0 92 8c 07 	sts	0x078C, r15
      default: 
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    4970:	0e 94 69 22 	call	0x44d2	; 0x44d2 <write_global_settings>
  return(STATUS_OK);
    4974:	80 e0       	ldi	r24, 0x00	; 0
    4976:	56 c0       	rjmp	.+172    	; 0x4a24 <settings_store_global_setting+0x29e>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    4978:	84 e0       	ldi	r24, 0x04	; 4
    497a:	54 c0       	rjmp	.+168    	; 0x4a24 <settings_store_global_setting+0x29e>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    497c:	83 e0       	ldi	r24, 0x03	; 3
    497e:	52 c0       	rjmp	.+164    	; 0x4a24 <settings_store_global_setting+0x29e>
      case 24: settings.homing_feed_rate = value; break;
      case 25: settings.homing_seek_rate = value; break;
      case 26: settings.homing_debounce_delay = int_value; break;
      case 27: settings.homing_pulloff = value; break;
      default: 
        return(STATUS_INVALID_STATEMENT);
    4980:	83 e0       	ldi	r24, 0x03	; 3
    4982:	50 c0       	rjmp	.+160    	; 0x4a24 <settings_store_global_setting+0x29e>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    4984:	86 e0       	ldi	r24, 0x06	; 6
    4986:	4e c0       	rjmp	.+156    	; 0x4a24 <settings_store_global_setting+0x29e>
        if (int_value) { settings.flags |= BITFLAG_AUTO_START; }
        else { settings.flags &= ~BITFLAG_AUTO_START; }
        break;
      case 20:
        if (int_value) { 
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    4988:	8a e0       	ldi	r24, 0x0A	; 10
    498a:	4c c0       	rjmp	.+152    	; 0x4a24 <settings_store_global_setting+0x29e>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    498c:	83 e0       	ldi	r24, 0x03	; 3
    498e:	4a c0       	rjmp	.+148    	; 0x4a24 <settings_store_global_setting+0x29e>
    4990:	83 e0       	ldi	r24, 0x03	; 3
    4992:	48 c0       	rjmp	.+144    	; 0x4a24 <settings_store_global_setting+0x29e>
        parameter -= AXIS_SETTINGS_INCREMENT;
    4994:	e2 e9       	ldi	r30, 0x92	; 146
    4996:	ed 0f       	add	r30, r29
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    4998:	e3 30       	cpi	r30, 0x03	; 3
    499a:	68 f0       	brcs	.+26     	; 0x49b6 <settings_store_global_setting+0x230>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    499c:	ea 30       	cpi	r30, 0x0A	; 10
    499e:	b0 f3       	brcs	.-20     	; 0x498c <settings_store_global_setting+0x206>
        parameter -= AXIS_SETTINGS_INCREMENT;
    49a0:	c8 e8       	ldi	r28, 0x88	; 136
    49a2:	cd 0f       	add	r28, r29
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    49a4:	c3 30       	cpi	r28, 0x03	; 3
    49a6:	98 f0       	brcs	.+38     	; 0x49ce <settings_store_global_setting+0x248>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    49a8:	ca 30       	cpi	r28, 0x0A	; 10
    49aa:	90 f3       	brcs	.-28     	; 0x4990 <settings_store_global_setting+0x20a>
        parameter -= AXIS_SETTINGS_INCREMENT;
    49ac:	d2 58       	subi	r29, 0x82	; 130
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    49ae:	d3 30       	cpi	r29, 0x03	; 3
    49b0:	40 f1       	brcs	.+80     	; 0x4a02 <settings_store_global_setting+0x27c>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    49b2:	83 e0       	ldi	r24, 0x03	; 3
    49b4:	37 c0       	rjmp	.+110    	; 0x4a24 <settings_store_global_setting+0x29e>
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
        // Valid axis setting found.
        switch (set_idx) {
          case 0: settings.steps_per_mm[parameter] = value; break;
          case 1: settings.max_rate[parameter] = value; break;
    49b6:	f0 e0       	ldi	r31, 0x00	; 0
    49b8:	ee 0f       	add	r30, r30
    49ba:	ff 1f       	adc	r31, r31
    49bc:	ee 0f       	add	r30, r30
    49be:	ff 1f       	adc	r31, r31
    49c0:	e4 5b       	subi	r30, 0xB4	; 180
    49c2:	f8 4f       	sbci	r31, 0xF8	; 248
    49c4:	c0 82       	st	Z, r12
    49c6:	d1 82       	std	Z+1, r13	; 0x01
    49c8:	e2 82       	std	Z+2, r14	; 0x02
    49ca:	f3 82       	std	Z+3, r15	; 0x03
    49cc:	d1 cf       	rjmp	.-94     	; 0x4970 <settings_store_global_setting+0x1ea>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    49ce:	d0 e0       	ldi	r29, 0x00	; 0
    49d0:	cc 0f       	add	r28, r28
    49d2:	dd 1f       	adc	r29, r29
    49d4:	cc 0f       	add	r28, r28
    49d6:	dd 1f       	adc	r29, r29
    49d8:	c8 5a       	subi	r28, 0xA8	; 168
    49da:	d8 4f       	sbci	r29, 0xF8	; 248
    49dc:	20 e0       	ldi	r18, 0x00	; 0
    49de:	30 e0       	ldi	r19, 0x00	; 0
    49e0:	40 e7       	ldi	r20, 0x70	; 112
    49e2:	52 e4       	ldi	r21, 0x42	; 66
    49e4:	c7 01       	movw	r24, r14
    49e6:	b6 01       	movw	r22, r12
    49e8:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    49ec:	20 e0       	ldi	r18, 0x00	; 0
    49ee:	30 e0       	ldi	r19, 0x00	; 0
    49f0:	40 e7       	ldi	r20, 0x70	; 112
    49f2:	52 e4       	ldi	r21, 0x42	; 66
    49f4:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    49f8:	68 83       	st	Y, r22
    49fa:	79 83       	std	Y+1, r23	; 0x01
    49fc:	8a 83       	std	Y+2, r24	; 0x02
    49fe:	9b 83       	std	Y+3, r25	; 0x03
    4a00:	b7 cf       	rjmp	.-146    	; 0x4970 <settings_store_global_setting+0x1ea>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    4a02:	ed 2f       	mov	r30, r29
    4a04:	f0 e0       	ldi	r31, 0x00	; 0
    4a06:	ee 0f       	add	r30, r30
    4a08:	ff 1f       	adc	r31, r31
    4a0a:	ee 0f       	add	r30, r30
    4a0c:	ff 1f       	adc	r31, r31
    4a0e:	ec 59       	subi	r30, 0x9C	; 156
    4a10:	f8 4f       	sbci	r31, 0xF8	; 248
    4a12:	f7 fa       	bst	r15, 7
    4a14:	f0 94       	com	r15
    4a16:	f7 f8       	bld	r15, 7
    4a18:	f0 94       	com	r15
    4a1a:	c0 82       	st	Z, r12
    4a1c:	d1 82       	std	Z+1, r13	; 0x01
    4a1e:	e2 82       	std	Z+2, r14	; 0x02
    4a20:	f3 82       	std	Z+3, r15	; 0x03
    4a22:	a6 cf       	rjmp	.-180    	; 0x4970 <settings_store_global_setting+0x1ea>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    4a24:	df 91       	pop	r29
    4a26:	cf 91       	pop	r28
    4a28:	ff 90       	pop	r15
    4a2a:	ef 90       	pop	r14
    4a2c:	df 90       	pop	r13
    4a2e:	cf 90       	pop	r12
    4a30:	08 95       	ret

00004a32 <settings_init>:


// Initialize the config subsystem
void settings_init() {
    4a32:	1f 93       	push	r17
    4a34:	cf 93       	push	r28
    4a36:	df 93       	push	r29
    4a38:	cd b7       	in	r28, 0x3d	; 61
    4a3a:	de b7       	in	r29, 0x3e	; 62
    4a3c:	2c 97       	sbiw	r28, 0x0c	; 12
    4a3e:	0f b6       	in	r0, 0x3f	; 63
    4a40:	f8 94       	cli
    4a42:	de bf       	out	0x3e, r29	; 62
    4a44:	0f be       	out	0x3f, r0	; 63
    4a46:	cd bf       	out	0x3d, r28	; 61
  if(!read_global_settings()) {
    4a48:	0e 94 ad 23 	call	0x475a	; 0x475a <read_global_settings>
    4a4c:	81 11       	cpse	r24, r1
    4a4e:	17 c0       	rjmp	.+46     	; 0x4a7e <settings_init+0x4c>
    report_status_message(STATUS_SETTING_READ_FAIL);
    4a50:	87 e0       	ldi	r24, 0x07	; 7
    4a52:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    settings_reset();
    4a56:	0e 94 77 22 	call	0x44ee	; 0x44ee <settings_reset>
    report_grbl_settings();
    4a5a:	0e 94 79 30 	call	0x60f2	; 0x60f2 <report_grbl_settings>
    4a5e:	0f c0       	rjmp	.+30     	; 0x4a7e <settings_init+0x4c>
  }
  // Read all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.
  float coord_data[N_AXIS];
  uint8_t i;
  for (i=0; i<=SETTING_INDEX_NCOORD; i++) {
    if (!settings_read_coord_data(i, coord_data)) {
    4a60:	be 01       	movw	r22, r28
    4a62:	6f 5f       	subi	r22, 0xFF	; 255
    4a64:	7f 4f       	sbci	r23, 0xFF	; 255
    4a66:	81 2f       	mov	r24, r17
    4a68:	0e 94 6d 23 	call	0x46da	; 0x46da <settings_read_coord_data>
    4a6c:	81 11       	cpse	r24, r1
    4a6e:	03 c0       	rjmp	.+6      	; 0x4a76 <settings_init+0x44>
      report_status_message(STATUS_SETTING_READ_FAIL);
    4a70:	87 e0       	ldi	r24, 0x07	; 7
    4a72:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    report_grbl_settings();
  }
  // Read all parameter data into a dummy variable. If error, reset to zero, otherwise do nothing.
  float coord_data[N_AXIS];
  uint8_t i;
  for (i=0; i<=SETTING_INDEX_NCOORD; i++) {
    4a76:	1f 5f       	subi	r17, 0xFF	; 255
    4a78:	18 30       	cpi	r17, 0x08	; 8
    4a7a:	91 f7       	brne	.-28     	; 0x4a60 <settings_init+0x2e>
    4a7c:	02 c0       	rjmp	.+4      	; 0x4a82 <settings_init+0x50>
  return(STATUS_OK);
}


// Initialize the config subsystem
void settings_init() {
    4a7e:	10 e0       	ldi	r17, 0x00	; 0
    4a80:	ef cf       	rjmp	.-34     	; 0x4a60 <settings_init+0x2e>
    if (!settings_read_coord_data(i, coord_data)) {
      report_status_message(STATUS_SETTING_READ_FAIL);
    }
  }
  // NOTE: Startup lines are handled and called by main.c at the end of initialization.
}
    4a82:	2c 96       	adiw	r28, 0x0c	; 12
    4a84:	0f b6       	in	r0, 0x3f	; 63
    4a86:	f8 94       	cli
    4a88:	de bf       	out	0x3e, r29	; 62
    4a8a:	0f be       	out	0x3f, r0	; 63
    4a8c:	cd bf       	out	0x3d, r28	; 61
    4a8e:	df 91       	pop	r29
    4a90:	cf 91       	pop	r28
    4a92:	1f 91       	pop	r17
    4a94:	08 95       	ret

00004a96 <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4a96:	88 23       	and	r24, r24
    4a98:	21 f0       	breq	.+8      	; 0x4aa2 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4a9a:	81 30       	cpi	r24, 0x01	; 1
    4a9c:	21 f4       	brne	.+8      	; 0x4aa6 <get_step_pin_mask+0x10>
    4a9e:	88 e0       	ldi	r24, 0x08	; 8
    4aa0:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4aa2:	84 e0       	ldi	r24, 0x04	; 4
    4aa4:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
  return((1<<Z_STEP_BIT));
    4aa6:	80 e1       	ldi	r24, 0x10	; 16
}
    4aa8:	08 95       	ret

00004aaa <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4aaa:	88 23       	and	r24, r24
    4aac:	21 f0       	breq	.+8      	; 0x4ab6 <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4aae:	81 30       	cpi	r24, 0x01	; 1
    4ab0:	21 f4       	brne	.+8      	; 0x4aba <get_direction_pin_mask+0x10>
    4ab2:	80 e4       	ldi	r24, 0x40	; 64
    4ab4:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4ab6:	80 e2       	ldi	r24, 0x20	; 32
    4ab8:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
  return((1<<Z_DIRECTION_BIT));
    4aba:	80 e8       	ldi	r24, 0x80	; 128
}
    4abc:	08 95       	ret

00004abe <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4abe:	88 23       	and	r24, r24
    4ac0:	21 f0       	breq	.+8      	; 0x4aca <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4ac2:	81 30       	cpi	r24, 0x01	; 1
    4ac4:	21 f4       	brne	.+8      	; 0x4ace <get_limit_pin_mask+0x10>
    4ac6:	84 e0       	ldi	r24, 0x04	; 4
    4ac8:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4aca:	82 e0       	ldi	r24, 0x02	; 2
    4acc:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
  return((1<<Z_LIMIT_BIT));
    4ace:	88 e0       	ldi	r24, 0x08	; 8
}
    4ad0:	08 95       	ret

00004ad2 <planner_recalculate>:
  to compute an optimal plan, so select carefully. The Arduino 328p memory is already maxed out, but future
  ARM versions should have enough memory and speed for look-ahead blocks numbering up to a hundred or more.

*/
static void planner_recalculate() 
{   
    4ad2:	3f 92       	push	r3
    4ad4:	4f 92       	push	r4
    4ad6:	5f 92       	push	r5
    4ad8:	6f 92       	push	r6
    4ada:	7f 92       	push	r7
    4adc:	8f 92       	push	r8
    4ade:	9f 92       	push	r9
    4ae0:	af 92       	push	r10
    4ae2:	bf 92       	push	r11
    4ae4:	cf 92       	push	r12
    4ae6:	df 92       	push	r13
    4ae8:	ef 92       	push	r14
    4aea:	ff 92       	push	r15
    4aec:	0f 93       	push	r16
    4aee:	1f 93       	push	r17
    4af0:	cf 93       	push	r28
    4af2:	df 93       	push	r29
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
    4af4:	80 91 49 02 	lds	r24, 0x0249


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    4af8:	81 11       	cpse	r24, r1
    4afa:	01 c0       	rjmp	.+2      	; 0x4afe <planner_recalculate+0x2c>
    4afc:	84 e1       	ldi	r24, 0x14	; 20
  block_index--;
    4afe:	bb 24       	eor	r11, r11
    4b00:	ba 94       	dec	r11
    4b02:	b8 0e       	add	r11, r24
{   
  // Initialize block index to the last block in the planner buffer.
  uint8_t block_index = plan_prev_block_index(block_buffer_head);
        
  // Bail. Can't do anything with one only one plan-able block.
  if (block_index == block_buffer_planned) { return; }
    4b04:	c0 91 47 02 	lds	r28, 0x0247
    4b08:	cb 15       	cp	r28, r11
    4b0a:	09 f4       	brne	.+2      	; 0x4b0e <planner_recalculate+0x3c>
    4b0c:	03 c1       	rjmp	.+518    	; 0x4d14 <planner_recalculate+0x242>
  // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
  // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
  // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
  float entry_speed_sqr;
  plan_block_t *next;
  plan_block_t *current = &block_buffer[block_index];
    4b0e:	89 e2       	ldi	r24, 0x29	; 41
    4b10:	b8 9e       	mul	r11, r24
    4b12:	80 01       	movw	r16, r0
    4b14:	11 24       	eor	r1, r1
    4b16:	05 5b       	subi	r16, 0xB5	; 181
    4b18:	1d 4f       	sbci	r17, 0xFD	; 253

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
    4b1a:	f8 01       	movw	r30, r16
    4b1c:	85 88       	ldd	r8, Z+21	; 0x15
    4b1e:	96 88       	ldd	r9, Z+22	; 0x16
    4b20:	a7 88       	ldd	r10, Z+23	; 0x17
    4b22:	c0 8c       	ldd	r12, Z+24	; 0x18
    4b24:	61 a1       	ldd	r22, Z+33	; 0x21
    4b26:	72 a1       	ldd	r23, Z+34	; 0x22
    4b28:	83 a1       	ldd	r24, Z+35	; 0x23
    4b2a:	94 a1       	ldd	r25, Z+36	; 0x24
    4b2c:	9b 01       	movw	r18, r22
    4b2e:	ac 01       	movw	r20, r24
    4b30:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    4b34:	f8 01       	movw	r30, r16
    4b36:	25 a1       	ldd	r18, Z+37	; 0x25
    4b38:	36 a1       	ldd	r19, Z+38	; 0x26
    4b3a:	47 a1       	ldd	r20, Z+39	; 0x27
    4b3c:	50 a5       	ldd	r21, Z+40	; 0x28
    4b3e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    4b42:	d6 2e       	mov	r13, r22
    4b44:	e7 2e       	mov	r14, r23
    4b46:	f8 2e       	mov	r15, r24
    4b48:	d9 2f       	mov	r29, r25
    4b4a:	26 2f       	mov	r18, r22
    4b4c:	37 2f       	mov	r19, r23
    4b4e:	48 2f       	mov	r20, r24
    4b50:	59 2f       	mov	r21, r25
    4b52:	68 2d       	mov	r22, r8
    4b54:	79 2d       	mov	r23, r9
    4b56:	8a 2d       	mov	r24, r10
    4b58:	9c 2d       	mov	r25, r12
    4b5a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    4b5e:	88 23       	and	r24, r24
    4b60:	24 f4       	brge	.+8      	; 0x4b6a <planner_recalculate+0x98>
    4b62:	d8 2c       	mov	r13, r8
    4b64:	e9 2c       	mov	r14, r9
    4b66:	fa 2c       	mov	r15, r10
    4b68:	dc 2d       	mov	r29, r12
    4b6a:	4d 2d       	mov	r20, r13
    4b6c:	5e 2d       	mov	r21, r14
    4b6e:	6f 2d       	mov	r22, r15
    4b70:	7d 2f       	mov	r23, r29
    4b72:	f8 01       	movw	r30, r16
    4b74:	41 8b       	std	Z+17, r20	; 0x11
    4b76:	52 8b       	std	Z+18, r21	; 0x12
    4b78:	63 8b       	std	Z+19, r22	; 0x13
    4b7a:	74 8b       	std	Z+20, r23	; 0x14


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    4b7c:	b1 10       	cpse	r11, r1
    4b7e:	04 c0       	rjmp	.+8      	; 0x4b88 <planner_recalculate+0xb6>
    4b80:	0f 2e       	mov	r0, r31
    4b82:	f4 e1       	ldi	r31, 0x14	; 20
    4b84:	bf 2e       	mov	r11, r31
    4b86:	f0 2d       	mov	r31, r0
  block_index--;
    4b88:	ba 94       	dec	r11

  // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    4b8a:	cb 15       	cp	r28, r11
    4b8c:	49 f0       	breq	.+18     	; 0x4ba0 <planner_recalculate+0xce>
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
    4b8e:	0f 2e       	mov	r0, r31
    4b90:	f9 e2       	ldi	r31, 0x29	; 41
    4b92:	af 2e       	mov	r10, r31
    4b94:	f0 2d       	mov	r31, r0


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    4b96:	0f 2e       	mov	r0, r31
    4b98:	f4 e1       	ldi	r31, 0x14	; 20
    4b9a:	9f 2e       	mov	r9, r31
    4b9c:	f0 2d       	mov	r31, r0
    4b9e:	4d c0       	rjmp	.+154    	; 0x4c3a <planner_recalculate+0x168>
  current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->acceleration*current->millimeters);
  
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
    4ba0:	80 91 4a 02 	lds	r24, 0x024A
    4ba4:	c8 13       	cpse	r28, r24
    4ba6:	4d c0       	rjmp	.+154    	; 0x4c42 <planner_recalculate+0x170>
    4ba8:	0e 94 c7 1a 	call	0x358e	; 0x358e <st_update_plan_block_parameters>
    4bac:	4a c0       	rjmp	.+148    	; 0x4c42 <planner_recalculate+0x170>
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
      next = current;
      current = &block_buffer[block_index];
    4bae:	ab 9c       	mul	r10, r11
    4bb0:	e0 01       	movw	r28, r0
    4bb2:	11 24       	eor	r1, r1
    4bb4:	c5 5b       	subi	r28, 0xB5	; 181
    4bb6:	dd 4f       	sbci	r29, 0xFD	; 253


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    4bb8:	b1 10       	cpse	r11, r1
    4bba:	01 c0       	rjmp	.+2      	; 0x4bbe <planner_recalculate+0xec>
    4bbc:	b9 2c       	mov	r11, r9
  block_index--;
    4bbe:	ba 94       	dec	r11
      next = current;
      current = &block_buffer[block_index];
      block_index = plan_prev_block_index(block_index);

      // Check if next block is the tail block(=planned block). If so, update current stepper parameters.
      if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); } 
    4bc0:	80 91 4a 02 	lds	r24, 0x024A
    4bc4:	8b 11       	cpse	r24, r11
    4bc6:	02 c0       	rjmp	.+4      	; 0x4bcc <planner_recalculate+0xfa>
    4bc8:	0e 94 c7 1a 	call	0x358e	; 0x358e <st_update_plan_block_parameters>

      // Compute maximum entry speed decelerating over the current block from its exit speed.
      if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
    4bcc:	cd 88       	ldd	r12, Y+21	; 0x15
    4bce:	de 88       	ldd	r13, Y+22	; 0x16
    4bd0:	ef 88       	ldd	r14, Y+23	; 0x17
    4bd2:	f8 8c       	ldd	r15, Y+24	; 0x18
    4bd4:	a7 01       	movw	r20, r14
    4bd6:	96 01       	movw	r18, r12
    4bd8:	69 89       	ldd	r22, Y+17	; 0x11
    4bda:	7a 89       	ldd	r23, Y+18	; 0x12
    4bdc:	8b 89       	ldd	r24, Y+19	; 0x13
    4bde:	9c 89       	ldd	r25, Y+20	; 0x14
    4be0:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    4be4:	88 23       	and	r24, r24
    4be6:	41 f1       	breq	.+80     	; 0x4c38 <planner_recalculate+0x166>
        entry_speed_sqr = next->entry_speed_sqr + 2*current->acceleration*current->millimeters;
    4be8:	69 a1       	ldd	r22, Y+33	; 0x21
    4bea:	7a a1       	ldd	r23, Y+34	; 0x22
    4bec:	8b a1       	ldd	r24, Y+35	; 0x23
    4bee:	9c a1       	ldd	r25, Y+36	; 0x24
    4bf0:	9b 01       	movw	r18, r22
    4bf2:	ac 01       	movw	r20, r24
    4bf4:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    4bf8:	2d a1       	ldd	r18, Y+37	; 0x25
    4bfa:	3e a1       	ldd	r19, Y+38	; 0x26
    4bfc:	4f a1       	ldd	r20, Y+39	; 0x27
    4bfe:	58 a5       	ldd	r21, Y+40	; 0x28
    4c00:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    4c04:	f8 01       	movw	r30, r16
    4c06:	21 89       	ldd	r18, Z+17	; 0x11
    4c08:	32 89       	ldd	r19, Z+18	; 0x12
    4c0a:	43 89       	ldd	r20, Z+19	; 0x13
    4c0c:	54 89       	ldd	r21, Z+20	; 0x14
    4c0e:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    4c12:	2b 01       	movw	r4, r22
    4c14:	3c 01       	movw	r6, r24
        if (entry_speed_sqr < current->max_entry_speed_sqr) {
    4c16:	9b 01       	movw	r18, r22
    4c18:	ac 01       	movw	r20, r24
    4c1a:	c7 01       	movw	r24, r14
    4c1c:	b6 01       	movw	r22, r12
    4c1e:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    4c22:	18 16       	cp	r1, r24
    4c24:	2c f4       	brge	.+10     	; 0x4c30 <planner_recalculate+0x15e>
          current->entry_speed_sqr = entry_speed_sqr;
    4c26:	49 8a       	std	Y+17, r4	; 0x11
    4c28:	5a 8a       	std	Y+18, r5	; 0x12
    4c2a:	6b 8a       	std	Y+19, r6	; 0x13
    4c2c:	7c 8a       	std	Y+20, r7	; 0x14
    4c2e:	04 c0       	rjmp	.+8      	; 0x4c38 <planner_recalculate+0x166>
        } else {
          current->entry_speed_sqr = current->max_entry_speed_sqr;
    4c30:	c9 8a       	std	Y+17, r12	; 0x11
    4c32:	da 8a       	std	Y+18, r13	; 0x12
    4c34:	eb 8a       	std	Y+19, r14	; 0x13
    4c36:	fc 8a       	std	Y+20, r15	; 0x14


// Returns the index of the previous block in the ring buffer
static uint8_t plan_prev_block_index(uint8_t block_index) 
{
  if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
    4c38:	8e 01       	movw	r16, r28
  block_index = plan_prev_block_index(block_index);
  if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass complete.
    // Check if the first block is the tail. If so, notify stepper to update its current parameters.
    if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
  } else { // Three or more plan-able blocks
    while (block_index != block_buffer_planned) { 
    4c3a:	80 91 47 02 	lds	r24, 0x0247
    4c3e:	b8 12       	cpse	r11, r24
    4c40:	b6 cf       	rjmp	.-148    	; 0x4bae <planner_recalculate+0xdc>
    }
  }    

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
    4c42:	40 90 47 02 	lds	r4, 0x0247
    4c46:	f9 e2       	ldi	r31, 0x29	; 41
    4c48:	4f 9e       	mul	r4, r31
    4c4a:	80 01       	movw	r16, r0
    4c4c:	11 24       	eor	r1, r1
    4c4e:	05 5b       	subi	r16, 0xB5	; 181
    4c50:	1d 4f       	sbci	r17, 0xFD	; 253


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    4c52:	77 24       	eor	r7, r7
    4c54:	73 94       	inc	r7
    4c56:	74 0c       	add	r7, r4
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    4c58:	84 e1       	ldi	r24, 0x14	; 20
    4c5a:	78 12       	cpse	r7, r24
    4c5c:	01 c0       	rjmp	.+2      	; 0x4c60 <planner_recalculate+0x18e>
    4c5e:	71 2c       	mov	r7, r1

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    4c60:	60 90 49 02 	lds	r6, 0x0249
    current = next;
    next = &block_buffer[block_index];
    4c64:	0f 2e       	mov	r0, r31
    4c66:	f9 e2       	ldi	r31, 0x29	; 41
    4c68:	5f 2e       	mov	r5, r31
    4c6a:	f0 2d       	mov	r31, r0

// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    4c6c:	31 2c       	mov	r3, r1

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    4c6e:	4e c0       	rjmp	.+156    	; 0x4d0c <planner_recalculate+0x23a>
    current = next;
    next = &block_buffer[block_index];
    4c70:	57 9c       	mul	r5, r7
    4c72:	e0 01       	movw	r28, r0
    4c74:	11 24       	eor	r1, r1
    4c76:	c5 5b       	subi	r28, 0xB5	; 181
    4c78:	dd 4f       	sbci	r29, 0xFD	; 253
    
    // Any acceleration detected in the forward pass automatically moves the optimal planned
    // pointer forward, since everything before this is all optimal. In other words, nothing
    // can improve the plan from the buffer tail to the planned pointer by logic.
    if (current->entry_speed_sqr < next->entry_speed_sqr) {
    4c7a:	f8 01       	movw	r30, r16
    4c7c:	81 88       	ldd	r8, Z+17	; 0x11
    4c7e:	92 88       	ldd	r9, Z+18	; 0x12
    4c80:	a3 88       	ldd	r10, Z+19	; 0x13
    4c82:	b4 88       	ldd	r11, Z+20	; 0x14
    4c84:	c9 88       	ldd	r12, Y+17	; 0x11
    4c86:	da 88       	ldd	r13, Y+18	; 0x12
    4c88:	eb 88       	ldd	r14, Y+19	; 0x13
    4c8a:	fc 88       	ldd	r15, Y+20	; 0x14
    4c8c:	a7 01       	movw	r20, r14
    4c8e:	96 01       	movw	r18, r12
    4c90:	c5 01       	movw	r24, r10
    4c92:	b4 01       	movw	r22, r8
    4c94:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    4c98:	88 23       	and	r24, r24
    4c9a:	2c f5       	brge	.+74     	; 0x4ce6 <planner_recalculate+0x214>
      entry_speed_sqr = current->entry_speed_sqr + 2*current->acceleration*current->millimeters;
    4c9c:	f8 01       	movw	r30, r16
    4c9e:	61 a1       	ldd	r22, Z+33	; 0x21
    4ca0:	72 a1       	ldd	r23, Z+34	; 0x22
    4ca2:	83 a1       	ldd	r24, Z+35	; 0x23
    4ca4:	94 a1       	ldd	r25, Z+36	; 0x24
    4ca6:	9b 01       	movw	r18, r22
    4ca8:	ac 01       	movw	r20, r24
    4caa:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    4cae:	f8 01       	movw	r30, r16
    4cb0:	25 a1       	ldd	r18, Z+37	; 0x25
    4cb2:	36 a1       	ldd	r19, Z+38	; 0x26
    4cb4:	47 a1       	ldd	r20, Z+39	; 0x27
    4cb6:	50 a5       	ldd	r21, Z+40	; 0x28
    4cb8:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    4cbc:	9b 01       	movw	r18, r22
    4cbe:	ac 01       	movw	r20, r24
    4cc0:	c5 01       	movw	r24, r10
    4cc2:	b4 01       	movw	r22, r8
    4cc4:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    4cc8:	4b 01       	movw	r8, r22
    4cca:	5c 01       	movw	r10, r24
      // If true, current block is full-acceleration and we can move the planned pointer forward.
      if (entry_speed_sqr < next->entry_speed_sqr) {
    4ccc:	9b 01       	movw	r18, r22
    4cce:	ac 01       	movw	r20, r24
    4cd0:	c7 01       	movw	r24, r14
    4cd2:	b6 01       	movw	r22, r12
    4cd4:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    4cd8:	18 16       	cp	r1, r24
    4cda:	2c f4       	brge	.+10     	; 0x4ce6 <planner_recalculate+0x214>
        next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass sets this.
    4cdc:	89 8a       	std	Y+17, r8	; 0x11
    4cde:	9a 8a       	std	Y+18, r9	; 0x12
    4ce0:	ab 8a       	std	Y+19, r10	; 0x13
    4ce2:	bc 8a       	std	Y+20, r11	; 0x14
        block_buffer_planned = block_index; // Set optimal plan pointer.
    4ce4:	47 2c       	mov	r4, r7
    
    // Any block set at its maximum entry speed also creates an optimal plan up to this
    // point in the buffer. When the plan is bracketed by either the beginning of the
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    4ce6:	2d 89       	ldd	r18, Y+21	; 0x15
    4ce8:	3e 89       	ldd	r19, Y+22	; 0x16
    4cea:	4f 89       	ldd	r20, Y+23	; 0x17
    4cec:	58 8d       	ldd	r21, Y+24	; 0x18
    4cee:	69 89       	ldd	r22, Y+17	; 0x11
    4cf0:	7a 89       	ldd	r23, Y+18	; 0x12
    4cf2:	8b 89       	ldd	r24, Y+19	; 0x13
    4cf4:	9c 89       	ldd	r25, Y+20	; 0x14
    4cf6:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    4cfa:	81 11       	cpse	r24, r1
    4cfc:	01 c0       	rjmp	.+2      	; 0x4d00 <planner_recalculate+0x22e>
    4cfe:	47 2c       	mov	r4, r7


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    4d00:	73 94       	inc	r7
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    4d02:	f4 e1       	ldi	r31, 0x14	; 20
    4d04:	7f 12       	cpse	r7, r31
    4d06:	01 c0       	rjmp	.+2      	; 0x4d0a <planner_recalculate+0x238>
    4d08:	73 2c       	mov	r7, r3
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    current = next;
    next = &block_buffer[block_index];
    4d0a:	8e 01       	movw	r16, r28

  // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
  // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
  next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
  block_index = plan_next_block_index(block_buffer_planned); 
  while (block_index != block_buffer_head) {
    4d0c:	76 10       	cpse	r7, r6
    4d0e:	b0 cf       	rjmp	.-160    	; 0x4c70 <planner_recalculate+0x19e>
    4d10:	40 92 47 02 	sts	0x0247, r4
    // buffer and a maximum entry speed or two maximum entry speeds, every block in between
    // cannot logically be further improved. Hence, we don't have to recompute them anymore.
    if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
    block_index = plan_next_block_index( block_index );
  } 
}
    4d14:	df 91       	pop	r29
    4d16:	cf 91       	pop	r28
    4d18:	1f 91       	pop	r17
    4d1a:	0f 91       	pop	r16
    4d1c:	ff 90       	pop	r15
    4d1e:	ef 90       	pop	r14
    4d20:	df 90       	pop	r13
    4d22:	cf 90       	pop	r12
    4d24:	bf 90       	pop	r11
    4d26:	af 90       	pop	r10
    4d28:	9f 90       	pop	r9
    4d2a:	8f 90       	pop	r8
    4d2c:	7f 90       	pop	r7
    4d2e:	6f 90       	pop	r6
    4d30:	5f 90       	pop	r5
    4d32:	4f 90       	pop	r4
    4d34:	3f 90       	pop	r3
    4d36:	08 95       	ret

00004d38 <plan_reset>:


void plan_reset() 
{
  memset(&pl, 0, sizeof(pl)); // Clear planner struct
    4d38:	8c e1       	ldi	r24, 0x1C	; 28
    4d3a:	eb e2       	ldi	r30, 0x2B	; 43
    4d3c:	f2 e0       	ldi	r31, 0x02	; 2
    4d3e:	df 01       	movw	r26, r30
    4d40:	1d 92       	st	X+, r1
    4d42:	8a 95       	dec	r24
    4d44:	e9 f7       	brne	.-6      	; 0x4d40 <plan_reset+0x8>
  block_buffer_tail = 0;
    4d46:	10 92 4a 02 	sts	0x024A, r1
  block_buffer_head = 0; // Empty = tail
    4d4a:	10 92 49 02 	sts	0x0249, r1
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
    4d4e:	81 e0       	ldi	r24, 0x01	; 1
    4d50:	80 93 48 02 	sts	0x0248, r24
  block_buffer_planned = 0; // = block_buffer_tail;
    4d54:	10 92 47 02 	sts	0x0247, r1
    4d58:	08 95       	ret

00004d5a <plan_discard_current_block>:
}


void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    4d5a:	80 91 4a 02 	lds	r24, 0x024A
    4d5e:	90 91 49 02 	lds	r25, 0x0249
    4d62:	98 17       	cp	r25, r24
    4d64:	69 f0       	breq	.+26     	; 0x4d80 <plan_discard_current_block+0x26>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    4d66:	91 e0       	ldi	r25, 0x01	; 1
    4d68:	98 0f       	add	r25, r24
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    4d6a:	94 31       	cpi	r25, 0x14	; 20
    4d6c:	09 f4       	brne	.+2      	; 0x4d70 <plan_discard_current_block+0x16>
    4d6e:	90 e0       	ldi	r25, 0x00	; 0
void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
    4d70:	20 91 47 02 	lds	r18, 0x0247
    4d74:	82 13       	cpse	r24, r18
    4d76:	02 c0       	rjmp	.+4      	; 0x4d7c <plan_discard_current_block+0x22>
    4d78:	90 93 47 02 	sts	0x0247, r25
    block_buffer_tail = block_index;
    4d7c:	90 93 4a 02 	sts	0x024A, r25
    4d80:	08 95       	ret

00004d82 <plan_get_current_block>:
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    4d82:	80 91 4a 02 	lds	r24, 0x024A
    4d86:	90 91 49 02 	lds	r25, 0x0249
    4d8a:	98 17       	cp	r25, r24
    4d8c:	39 f0       	breq	.+14     	; 0x4d9c <plan_get_current_block+0x1a>
  return(&block_buffer[block_buffer_tail]);
    4d8e:	29 e2       	ldi	r18, 0x29	; 41
    4d90:	82 9f       	mul	r24, r18
    4d92:	c0 01       	movw	r24, r0
    4d94:	11 24       	eor	r1, r1
    4d96:	85 5b       	subi	r24, 0xB5	; 181
    4d98:	9d 4f       	sbci	r25, 0xFD	; 253
    4d9a:	08 95       	ret
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    4d9c:	80 e0       	ldi	r24, 0x00	; 0
    4d9e:	90 e0       	ldi	r25, 0x00	; 0
  return(&block_buffer[block_buffer_tail]);
}
    4da0:	08 95       	ret

00004da2 <plan_get_exec_block_exit_speed>:


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    4da2:	e0 91 4a 02 	lds	r30, 0x024A
    4da6:	ef 5f       	subi	r30, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    4da8:	e4 31       	cpi	r30, 0x14	; 20
    4daa:	09 f4       	brne	.+2      	; 0x4dae <plan_get_exec_block_exit_speed+0xc>
    4dac:	e0 e0       	ldi	r30, 0x00	; 0


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    4dae:	80 91 49 02 	lds	r24, 0x0249
    4db2:	8e 17       	cp	r24, r30
    4db4:	69 f0       	breq	.+26     	; 0x4dd0 <plan_get_exec_block_exit_speed+0x2e>
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
    4db6:	89 e2       	ldi	r24, 0x29	; 41
    4db8:	e8 9f       	mul	r30, r24
    4dba:	f0 01       	movw	r30, r0
    4dbc:	11 24       	eor	r1, r1
    4dbe:	e5 5b       	subi	r30, 0xB5	; 181
    4dc0:	fd 4f       	sbci	r31, 0xFD	; 253
    4dc2:	61 89       	ldd	r22, Z+17	; 0x11
    4dc4:	72 89       	ldd	r23, Z+18	; 0x12
    4dc6:	83 89       	ldd	r24, Z+19	; 0x13
    4dc8:	94 89       	ldd	r25, Z+20	; 0x14
    4dca:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    4dce:	08 95       	ret


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    4dd0:	60 e0       	ldi	r22, 0x00	; 0
    4dd2:	70 e0       	ldi	r23, 0x00	; 0
    4dd4:	cb 01       	movw	r24, r22
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
}
    4dd6:	08 95       	ret

00004dd8 <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
  if (block_buffer_tail == next_buffer_head) { return(true); }
    4dd8:	81 e0       	ldi	r24, 0x01	; 1
    4dda:	20 91 4a 02 	lds	r18, 0x024A
    4dde:	90 91 48 02 	lds	r25, 0x0248
    4de2:	29 13       	cpse	r18, r25
    4de4:	80 e0       	ldi	r24, 0x00	; 0
  return(false);
}
    4de6:	08 95       	ret

00004de8 <plan_buffer_line>:
#ifdef USE_LINE_NUMBERS   
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number) 
#else
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate) 
#endif
{
    4de8:	2f 92       	push	r2
    4dea:	3f 92       	push	r3
    4dec:	4f 92       	push	r4
    4dee:	5f 92       	push	r5
    4df0:	6f 92       	push	r6
    4df2:	7f 92       	push	r7
    4df4:	8f 92       	push	r8
    4df6:	9f 92       	push	r9
    4df8:	af 92       	push	r10
    4dfa:	bf 92       	push	r11
    4dfc:	cf 92       	push	r12
    4dfe:	df 92       	push	r13
    4e00:	ef 92       	push	r14
    4e02:	ff 92       	push	r15
    4e04:	0f 93       	push	r16
    4e06:	1f 93       	push	r17
    4e08:	cf 93       	push	r28
    4e0a:	df 93       	push	r29
    4e0c:	cd b7       	in	r28, 0x3d	; 61
    4e0e:	de b7       	in	r29, 0x3e	; 62
    4e10:	ad 97       	sbiw	r28, 0x2d	; 45
    4e12:	0f b6       	in	r0, 0x3f	; 63
    4e14:	f8 94       	cli
    4e16:	de bf       	out	0x3e, r29	; 62
    4e18:	0f be       	out	0x3f, r0	; 63
    4e1a:	cd bf       	out	0x3d, r28	; 61
    4e1c:	49 a3       	std	Y+33, r20	; 0x21
    4e1e:	5a a3       	std	Y+34, r21	; 0x22
    4e20:	6b a3       	std	Y+35, r22	; 0x23
    4e22:	7c a3       	std	Y+36, r23	; 0x24
    4e24:	2d a3       	std	Y+37, r18	; 0x25
  // Prepare and initialize new block
  plan_block_t *block = &block_buffer[block_buffer_head];
    4e26:	20 91 49 02 	lds	r18, 0x0249
    4e2a:	49 e2       	ldi	r20, 0x29	; 41
    4e2c:	24 9f       	mul	r18, r20
    4e2e:	90 01       	movw	r18, r0
    4e30:	11 24       	eor	r1, r1
    4e32:	f9 01       	movw	r30, r18
    4e34:	e5 5b       	subi	r30, 0xB5	; 181
    4e36:	fd 4f       	sbci	r31, 0xFD	; 253
    4e38:	1f 01       	movw	r2, r30
  block->step_event_count = 0;
    4e3a:	15 86       	std	Z+13, r1	; 0x0d
    4e3c:	16 86       	std	Z+14, r1	; 0x0e
    4e3e:	17 86       	std	Z+15, r1	; 0x0f
    4e40:	10 8a       	std	Z+16, r1	; 0x10
  block->millimeters = 0;
    4e42:	15 a2       	std	Z+37, r1	; 0x25
    4e44:	16 a2       	std	Z+38, r1	; 0x26
    4e46:	17 a2       	std	Z+39, r1	; 0x27
    4e48:	10 a6       	std	Z+40, r1	; 0x28
  block->direction_bits = 0;
    4e4a:	10 82       	st	Z, r1
  block->acceleration = SOME_LARGE_VALUE; // Scaled down to maximum acceleration later
    4e4c:	49 e9       	ldi	r20, 0x99	; 153
    4e4e:	56 e7       	ldi	r21, 0x76	; 118
    4e50:	66 e9       	ldi	r22, 0x96	; 150
    4e52:	7e e7       	ldi	r23, 0x7E	; 126
    4e54:	41 a3       	std	Z+33, r20	; 0x21
    4e56:	52 a3       	std	Z+34, r21	; 0x22
    4e58:	63 a3       	std	Z+35, r22	; 0x23
    4e5a:	74 a3       	std	Z+36, r23	; 0x24
    4e5c:	5c 01       	movw	r10, r24
    4e5e:	00 e4       	ldi	r16, 0x40	; 64
    4e60:	17 e0       	ldi	r17, 0x07	; 7
    4e62:	ae 01       	movw	r20, r28
    4e64:	4f 5f       	subi	r20, 0xFF	; 255
    4e66:	5f 4f       	sbci	r21, 0xFF	; 255
    4e68:	5c 8f       	std	Y+28, r21	; 0x1c
    4e6a:	4b 8f       	std	Y+27, r20	; 0x1b
    4e6c:	0f 2e       	mov	r0, r31
    4e6e:	fb e2       	ldi	r31, 0x2B	; 43
    4e70:	4f 2e       	mov	r4, r31
    4e72:	f2 e0       	ldi	r31, 0x02	; 2
    4e74:	5f 2e       	mov	r5, r31
    4e76:	f0 2d       	mov	r31, r0
    4e78:	7f 01       	movw	r14, r30
    4e7a:	ce 01       	movw	r24, r28
    4e7c:	0d 96       	adiw	r24, 0x0d	; 13
    4e7e:	6c 01       	movw	r12, r24
  // TODO: After this for-loop, we don't touch the stepper algorithm data. Might be a good idea
  // to try to keep these types of things completely separate from the planner for portability.
  int32_t target_steps[N_AXIS];
  float unit_vec[N_AXIS], delta_mm;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    4e80:	71 2c       	mov	r7, r1
    4e82:	be 8e       	std	Y+30, r11	; 0x1e
    4e84:	ad 8e       	std	Y+29, r10	; 0x1d
    // Calculate target position in absolute steps. This conversion should be consistent throughout.
    target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
    4e86:	ed 8d       	ldd	r30, Y+29	; 0x1d
    4e88:	fe 8d       	ldd	r31, Y+30	; 0x1e
    4e8a:	61 91       	ld	r22, Z+
    4e8c:	71 91       	ld	r23, Z+
    4e8e:	81 91       	ld	r24, Z+
    4e90:	91 91       	ld	r25, Z+
    4e92:	fe 8f       	std	Y+30, r31	; 0x1e
    4e94:	ed 8f       	std	Y+29, r30	; 0x1d
    4e96:	18 a3       	std	Y+32, r17	; 0x20
    4e98:	0f 8f       	std	Y+31, r16	; 0x1f
    4e9a:	f8 01       	movw	r30, r16
    4e9c:	20 81       	ld	r18, Z
    4e9e:	31 81       	ldd	r19, Z+1	; 0x01
    4ea0:	42 81       	ldd	r20, Z+2	; 0x02
    4ea2:	53 81       	ldd	r21, Z+3	; 0x03
    4ea4:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    4ea8:	0e 94 6a 3b 	call	0x76d4	; 0x76d4 <lround>
    4eac:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4eae:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4eb0:	61 93       	st	Z+, r22
    4eb2:	71 93       	st	Z+, r23
    4eb4:	81 93       	st	Z+, r24
    4eb6:	91 93       	st	Z+, r25
    4eb8:	fc 8f       	std	Y+28, r31	; 0x1c
    4eba:	eb 8f       	std	Y+27, r30	; 0x1b
  
    // Number of steps for each axis and determine max step events
    block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
    4ebc:	f2 01       	movw	r30, r4
    4ebe:	81 90       	ld	r8, Z+
    4ec0:	91 90       	ld	r9, Z+
    4ec2:	a1 90       	ld	r10, Z+
    4ec4:	b1 90       	ld	r11, Z+
    4ec6:	2f 01       	movw	r4, r30
    4ec8:	68 19       	sub	r22, r8
    4eca:	79 09       	sbc	r23, r9
    4ecc:	8a 09       	sbc	r24, r10
    4ece:	9b 09       	sbc	r25, r11
    4ed0:	9b 01       	movw	r18, r22
    4ed2:	ac 01       	movw	r20, r24
    4ed4:	3a f4       	brpl	.+14     	; 0x4ee4 <plan_buffer_line+0xfc>
    4ed6:	22 27       	eor	r18, r18
    4ed8:	33 27       	eor	r19, r19
    4eda:	a9 01       	movw	r20, r18
    4edc:	26 1b       	sub	r18, r22
    4ede:	37 0b       	sbc	r19, r23
    4ee0:	48 0b       	sbc	r20, r24
    4ee2:	59 0b       	sbc	r21, r25
    4ee4:	f7 01       	movw	r30, r14
    4ee6:	21 83       	std	Z+1, r18	; 0x01
    4ee8:	32 83       	std	Z+2, r19	; 0x02
    4eea:	43 83       	std	Z+3, r20	; 0x03
    4eec:	54 83       	std	Z+4, r21	; 0x04
    block->step_event_count = max(block->step_event_count, block->steps[idx]);
    4eee:	f1 01       	movw	r30, r2
    4ef0:	85 84       	ldd	r8, Z+13	; 0x0d
    4ef2:	96 84       	ldd	r9, Z+14	; 0x0e
    4ef4:	a7 84       	ldd	r10, Z+15	; 0x0f
    4ef6:	b0 88       	ldd	r11, Z+16	; 0x10
    4ef8:	28 15       	cp	r18, r8
    4efa:	39 05       	cpc	r19, r9
    4efc:	4a 05       	cpc	r20, r10
    4efe:	5b 05       	cpc	r21, r11
    4f00:	10 f4       	brcc	.+4      	; 0x4f06 <plan_buffer_line+0x11e>
    4f02:	a5 01       	movw	r20, r10
    4f04:	94 01       	movw	r18, r8
    4f06:	f1 01       	movw	r30, r2
    4f08:	25 87       	std	Z+13, r18	; 0x0d
    4f0a:	36 87       	std	Z+14, r19	; 0x0e
    4f0c:	47 87       	std	Z+15, r20	; 0x0f
    4f0e:	50 8b       	std	Z+16, r21	; 0x10
    
    // Compute individual axes distance for move and prep unit vector calculations.
    // NOTE: Computes true distance from converted step values.
    delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
    4f10:	0e 94 fe 39 	call	0x73fc	; 0x73fc <__floatsisf>
    4f14:	ef 8d       	ldd	r30, Y+31	; 0x1f
    4f16:	f8 a1       	ldd	r31, Y+32	; 0x20
    4f18:	20 81       	ld	r18, Z
    4f1a:	31 81       	ldd	r19, Z+1	; 0x01
    4f1c:	42 81       	ldd	r20, Z+2	; 0x02
    4f1e:	53 81       	ldd	r21, Z+3	; 0x03
    4f20:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    4f24:	4b 01       	movw	r8, r22
    4f26:	5c 01       	movw	r10, r24
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
    4f28:	f6 01       	movw	r30, r12
    4f2a:	61 93       	st	Z+, r22
    4f2c:	71 93       	st	Z+, r23
    4f2e:	81 93       	st	Z+, r24
    4f30:	91 93       	st	Z+, r25
    4f32:	6f 01       	movw	r12, r30
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    4f34:	20 e0       	ldi	r18, 0x00	; 0
    4f36:	30 e0       	ldi	r19, 0x00	; 0
    4f38:	a9 01       	movw	r20, r18
    4f3a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    4f3e:	88 23       	and	r24, r24
    4f40:	44 f4       	brge	.+16     	; 0x4f52 <plan_buffer_line+0x16a>
    4f42:	f1 01       	movw	r30, r2
    4f44:	60 80       	ld	r6, Z
    4f46:	87 2d       	mov	r24, r7
    4f48:	0e 94 55 25 	call	0x4aaa	; 0x4aaa <get_direction_pin_mask>
    4f4c:	86 29       	or	r24, r6
    4f4e:	f1 01       	movw	r30, r2
    4f50:	80 83       	st	Z, r24
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    4f52:	a5 01       	movw	r20, r10
    4f54:	94 01       	movw	r18, r8
    4f56:	c5 01       	movw	r24, r10
    4f58:	b4 01       	movw	r22, r8
    4f5a:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    4f5e:	f1 01       	movw	r30, r2
    4f60:	25 a1       	ldd	r18, Z+37	; 0x25
    4f62:	36 a1       	ldd	r19, Z+38	; 0x26
    4f64:	47 a1       	ldd	r20, Z+39	; 0x27
    4f66:	50 a5       	ldd	r21, Z+40	; 0x28
    4f68:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    4f6c:	f1 01       	movw	r30, r2
    4f6e:	65 a3       	std	Z+37, r22	; 0x25
    4f70:	76 a3       	std	Z+38, r23	; 0x26
    4f72:	87 a3       	std	Z+39, r24	; 0x27
    4f74:	90 a7       	std	Z+40, r25	; 0x28
  // TODO: After this for-loop, we don't touch the stepper algorithm data. Might be a good idea
  // to try to keep these types of things completely separate from the planner for portability.
  int32_t target_steps[N_AXIS];
  float unit_vec[N_AXIS], delta_mm;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    4f76:	73 94       	inc	r7
    4f78:	0c 5f       	subi	r16, 0xFC	; 252
    4f7a:	1f 4f       	sbci	r17, 0xFF	; 255
    4f7c:	f4 e0       	ldi	r31, 0x04	; 4
    4f7e:	ef 0e       	add	r14, r31
    4f80:	f1 1c       	adc	r15, r1
    4f82:	23 e0       	ldi	r18, 0x03	; 3
    4f84:	72 12       	cpse	r7, r18
    4f86:	7f cf       	rjmp	.-258    	; 0x4e86 <plan_buffer_line+0x9e>
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
  }
  block->millimeters = sqrt(block->millimeters); // Complete millimeters calculation with sqrt()
    4f88:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    4f8c:	6b 01       	movw	r12, r22
    4f8e:	7c 01       	movw	r14, r24
    4f90:	f1 01       	movw	r30, r2
    4f92:	65 a3       	std	Z+37, r22	; 0x25
    4f94:	76 a3       	std	Z+38, r23	; 0x26
    4f96:	87 a3       	std	Z+39, r24	; 0x27
    4f98:	90 a7       	std	Z+40, r25	; 0x28
  
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
    4f9a:	85 85       	ldd	r24, Z+13	; 0x0d
    4f9c:	96 85       	ldd	r25, Z+14	; 0x0e
    4f9e:	a7 85       	ldd	r26, Z+15	; 0x0f
    4fa0:	b0 89       	ldd	r27, Z+16	; 0x10
    4fa2:	89 2b       	or	r24, r25
    4fa4:	8a 2b       	or	r24, r26
    4fa6:	8b 2b       	or	r24, r27
    4fa8:	09 f4       	brne	.+2      	; 0x4fac <plan_buffer_line+0x1c4>
    4faa:	e6 c1       	rjmp	.+972    	; 0x5378 <plan_buffer_line+0x590>
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    4fac:	20 e0       	ldi	r18, 0x00	; 0
    4fae:	30 e0       	ldi	r19, 0x00	; 0
    4fb0:	a9 01       	movw	r20, r18
    4fb2:	69 a1       	ldd	r22, Y+33	; 0x21
    4fb4:	7a a1       	ldd	r23, Y+34	; 0x22
    4fb6:	8b a1       	ldd	r24, Y+35	; 0x23
    4fb8:	9c a1       	ldd	r25, Y+36	; 0x24
    4fba:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    4fbe:	88 23       	and	r24, r24
    4fc0:	84 f0       	brlt	.+32     	; 0x4fe2 <plan_buffer_line+0x1fa>
  else if (invert_feed_rate) { feed_rate = block->millimeters/feed_rate; }
    4fc2:	fd a1       	ldd	r31, Y+37	; 0x25
    4fc4:	ff 23       	and	r31, r31
    4fc6:	a9 f0       	breq	.+42     	; 0x4ff2 <plan_buffer_line+0x20a>
    4fc8:	29 a1       	ldd	r18, Y+33	; 0x21
    4fca:	3a a1       	ldd	r19, Y+34	; 0x22
    4fcc:	4b a1       	ldd	r20, Y+35	; 0x23
    4fce:	5c a1       	ldd	r21, Y+36	; 0x24
    4fd0:	c7 01       	movw	r24, r14
    4fd2:	b6 01       	movw	r22, r12
    4fd4:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    4fd8:	69 a3       	std	Y+33, r22	; 0x21
    4fda:	7a a3       	std	Y+34, r23	; 0x22
    4fdc:	8b a3       	std	Y+35, r24	; 0x23
    4fde:	9c a3       	std	Y+36, r25	; 0x24
    4fe0:	08 c0       	rjmp	.+16     	; 0x4ff2 <plan_buffer_line+0x20a>
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    4fe2:	29 e9       	ldi	r18, 0x99	; 153
    4fe4:	29 a3       	std	Y+33, r18	; 0x21
    4fe6:	46 e7       	ldi	r20, 0x76	; 118
    4fe8:	4a a3       	std	Y+34, r20	; 0x22
    4fea:	56 e9       	ldi	r21, 0x96	; 150
    4fec:	5b a3       	std	Y+35, r21	; 0x23
    4fee:	8e e7       	ldi	r24, 0x7E	; 126
    4ff0:	8c a3       	std	Y+36, r24	; 0x24
  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled 
  // down such that no individual axes maximum values are exceeded with respect to the line direction. 
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
    4ff2:	a7 01       	movw	r20, r14
    4ff4:	96 01       	movw	r18, r12
    4ff6:	60 e0       	ldi	r22, 0x00	; 0
    4ff8:	70 e0       	ldi	r23, 0x00	; 0
    4ffa:	80 e8       	ldi	r24, 0x80	; 128
    4ffc:	9f e3       	ldi	r25, 0x3F	; 63
    4ffe:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    5002:	6a a7       	std	Y+42, r22	; 0x2a
    5004:	7b a7       	std	Y+43, r23	; 0x2b
    5006:	8c a7       	std	Y+44, r24	; 0x2c
    5008:	9d a7       	std	Y+45, r25	; 0x2d
    500a:	e7 e3       	ldi	r30, 0x37	; 55
    500c:	f2 e0       	ldi	r31, 0x02	; 2
    500e:	fe 8f       	std	Y+30, r31	; 0x1e
    5010:	ed 8f       	std	Y+29, r30	; 0x1d
    5012:	0f 2e       	mov	r0, r31
    5014:	fc e4       	ldi	r31, 0x4C	; 76
    5016:	ef 2e       	mov	r14, r31
    5018:	f7 e0       	ldi	r31, 0x07	; 7
    501a:	ff 2e       	mov	r15, r31
    501c:	f0 2d       	mov	r31, r0
    501e:	ae 01       	movw	r20, r28
    5020:	47 5e       	subi	r20, 0xE7	; 231
    5022:	5f 4f       	sbci	r21, 0xFF	; 255
    5024:	5a 8f       	std	Y+26, r21	; 0x1a
    5026:	49 8f       	std	Y+25, r20	; 0x19
    5028:	8e 01       	movw	r16, r28
    502a:	03 5f       	subi	r16, 0xF3	; 243
    502c:	1f 4f       	sbci	r17, 0xFF	; 255
  float junction_cos_theta = 0;
    502e:	81 2c       	mov	r8, r1
    5030:	91 2c       	mov	r9, r1
    5032:	54 01       	movw	r10, r8
    5034:	3c 8e       	std	Y+28, r3	; 0x1c
    5036:	2b 8e       	std	Y+27, r2	; 0x1b
    5038:	17 01       	movw	r2, r14
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    503a:	f8 01       	movw	r30, r16
    503c:	c0 80       	ld	r12, Z
    503e:	d1 80       	ldd	r13, Z+1	; 0x01
    5040:	e2 80       	ldd	r14, Z+2	; 0x02
    5042:	f3 80       	ldd	r15, Z+3	; 0x03
    5044:	20 e0       	ldi	r18, 0x00	; 0
    5046:	30 e0       	ldi	r19, 0x00	; 0
    5048:	a9 01       	movw	r20, r18
    504a:	c7 01       	movw	r24, r14
    504c:	b6 01       	movw	r22, r12
    504e:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    5052:	88 23       	and	r24, r24
    5054:	09 f4       	brne	.+2      	; 0x5058 <plan_buffer_line+0x270>
    5056:	8e c0       	rjmp	.+284    	; 0x5174 <plan_buffer_line+0x38c>
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
    5058:	a7 01       	movw	r20, r14
    505a:	96 01       	movw	r18, r12
    505c:	6a a5       	ldd	r22, Y+42	; 0x2a
    505e:	7b a5       	ldd	r23, Y+43	; 0x2b
    5060:	8c a5       	ldd	r24, Y+44	; 0x2c
    5062:	9d a5       	ldd	r25, Y+45	; 0x2d
    5064:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5068:	6b 01       	movw	r12, r22
    506a:	7c 01       	movw	r14, r24
    506c:	f8 01       	movw	r30, r16
    506e:	60 83       	st	Z, r22
    5070:	71 83       	std	Z+1, r23	; 0x01
    5072:	82 83       	std	Z+2, r24	; 0x02
    5074:	93 83       	std	Z+3, r25	; 0x03
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.
    5076:	9b 01       	movw	r18, r22
    5078:	ac 01       	movw	r20, r24
    507a:	60 e0       	ldi	r22, 0x00	; 0
    507c:	70 e0       	ldi	r23, 0x00	; 0
    507e:	80 e8       	ldi	r24, 0x80	; 128
    5080:	9f e3       	ldi	r25, 0x3F	; 63
    5082:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    5086:	2b 01       	movw	r4, r22
    5088:	3c 01       	movw	r6, r24
    508a:	e8 94       	clt
    508c:	77 f8       	bld	r7, 7
    508e:	39 a6       	std	Y+41, r3	; 0x29
    5090:	28 a6       	std	Y+40, r2	; 0x28

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    5092:	f1 01       	movw	r30, r2
    5094:	20 81       	ld	r18, Z
    5096:	31 81       	ldd	r19, Z+1	; 0x01
    5098:	42 81       	ldd	r20, Z+2	; 0x02
    509a:	53 81       	ldd	r21, Z+3	; 0x03
    509c:	c3 01       	movw	r24, r6
    509e:	b2 01       	movw	r22, r4
    50a0:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    50a4:	6f 8f       	std	Y+31, r22	; 0x1f
    50a6:	7d a3       	std	Y+37, r23	; 0x25
    50a8:	8e a3       	std	Y+38, r24	; 0x26
    50aa:	9f a3       	std	Y+39, r25	; 0x27
    50ac:	29 a1       	ldd	r18, Y+33	; 0x21
    50ae:	3a a1       	ldd	r19, Y+34	; 0x22
    50b0:	4b a1       	ldd	r20, Y+35	; 0x23
    50b2:	5c a1       	ldd	r21, Y+36	; 0x24
    50b4:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    50b8:	18 16       	cp	r1, r24
    50ba:	44 f4       	brge	.+16     	; 0x50cc <plan_buffer_line+0x2e4>
    50bc:	f9 a1       	ldd	r31, Y+33	; 0x21
    50be:	ff 8f       	std	Y+31, r31	; 0x1f
    50c0:	2a a1       	ldd	r18, Y+34	; 0x22
    50c2:	2d a3       	std	Y+37, r18	; 0x25
    50c4:	4b a1       	ldd	r20, Y+35	; 0x23
    50c6:	4e a3       	std	Y+38, r20	; 0x26
    50c8:	5c a1       	ldd	r21, Y+36	; 0x24
    50ca:	5f a3       	std	Y+39, r21	; 0x27
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    50cc:	eb 8d       	ldd	r30, Y+27	; 0x1b
    50ce:	fc 8d       	ldd	r31, Y+28	; 0x1c
    50d0:	f1 a1       	ldd	r31, Z+33	; 0x21
    50d2:	f9 a3       	std	Y+33, r31	; 0x21
    50d4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    50d6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    50d8:	f2 a1       	ldd	r31, Z+34	; 0x22
    50da:	fa a3       	std	Y+34, r31	; 0x22
    50dc:	eb 8d       	ldd	r30, Y+27	; 0x1b
    50de:	fc 8d       	ldd	r31, Y+28	; 0x1c
    50e0:	f3 a1       	ldd	r31, Z+35	; 0x23
    50e2:	fb a3       	std	Y+35, r31	; 0x23
    50e4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    50e6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    50e8:	f4 a1       	ldd	r31, Z+36	; 0x24
    50ea:	fc a3       	std	Y+36, r31	; 0x24
    50ec:	e8 a5       	ldd	r30, Y+40	; 0x28
    50ee:	f9 a5       	ldd	r31, Y+41	; 0x29
    50f0:	24 85       	ldd	r18, Z+12	; 0x0c
    50f2:	35 85       	ldd	r19, Z+13	; 0x0d
    50f4:	46 85       	ldd	r20, Z+14	; 0x0e
    50f6:	57 85       	ldd	r21, Z+15	; 0x0f
    50f8:	c3 01       	movw	r24, r6
    50fa:	b2 01       	movw	r22, r4
    50fc:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5100:	46 2e       	mov	r4, r22
    5102:	57 2e       	mov	r5, r23
    5104:	68 2e       	mov	r6, r24
    5106:	79 2e       	mov	r7, r25
    5108:	26 2f       	mov	r18, r22
    510a:	37 2f       	mov	r19, r23
    510c:	48 2f       	mov	r20, r24
    510e:	59 2f       	mov	r21, r25
    5110:	69 a1       	ldd	r22, Y+33	; 0x21
    5112:	7a a1       	ldd	r23, Y+34	; 0x22
    5114:	8b a1       	ldd	r24, Y+35	; 0x23
    5116:	9c a1       	ldd	r25, Y+36	; 0x24
    5118:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    511c:	88 23       	and	r24, r24
    511e:	2c f4       	brge	.+10     	; 0x512a <plan_buffer_line+0x342>
    5120:	49 a0       	ldd	r4, Y+33	; 0x21
    5122:	5a a0       	ldd	r5, Y+34	; 0x22
    5124:	6b a0       	ldd	r6, Y+35	; 0x23
    5126:	2c a1       	ldd	r18, Y+36	; 0x24
    5128:	01 c0       	rjmp	.+2      	; 0x512c <plan_buffer_line+0x344>
    512a:	27 2d       	mov	r18, r7
    512c:	84 2d       	mov	r24, r4
    512e:	95 2d       	mov	r25, r5
    5130:	a6 2d       	mov	r26, r6
    5132:	b2 2f       	mov	r27, r18
    5134:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5136:	fc 8d       	ldd	r31, Y+28	; 0x1c
    5138:	81 a3       	std	Z+33, r24	; 0x21
    513a:	92 a3       	std	Z+34, r25	; 0x22
    513c:	a3 a3       	std	Z+35, r26	; 0x23
    513e:	b4 a3       	std	Z+36, r27	; 0x24

      // Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction
      // between the current move and the previous move is simply the dot product of the two unit vectors, 
      // where prev_unit_vec is negative. Used later to compute maximum junction speed.
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    5140:	ed 8d       	ldd	r30, Y+29	; 0x1d
    5142:	fe 8d       	ldd	r31, Y+30	; 0x1e
    5144:	20 81       	ld	r18, Z
    5146:	31 81       	ldd	r19, Z+1	; 0x01
    5148:	42 81       	ldd	r20, Z+2	; 0x02
    514a:	53 81       	ldd	r21, Z+3	; 0x03
    514c:	c7 01       	movw	r24, r14
    514e:	b6 01       	movw	r22, r12
    5150:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5154:	9b 01       	movw	r18, r22
    5156:	ac 01       	movw	r20, r24
    5158:	c5 01       	movw	r24, r10
    515a:	b4 01       	movw	r22, r8
    515c:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    5160:	4b 01       	movw	r8, r22
    5162:	5c 01       	movw	r10, r24
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    5164:	ff 8d       	ldd	r31, Y+31	; 0x1f
    5166:	f9 a3       	std	Y+33, r31	; 0x21
    5168:	2d a1       	ldd	r18, Y+37	; 0x25
    516a:	2a a3       	std	Y+34, r18	; 0x22
    516c:	4e a1       	ldd	r20, Y+38	; 0x26
    516e:	4b a3       	std	Y+35, r20	; 0x23
    5170:	5f a1       	ldd	r21, Y+39	; 0x27
    5172:	5c a3       	std	Y+36, r21	; 0x24
    5174:	0c 5f       	subi	r16, 0xFC	; 252
    5176:	1f 4f       	sbci	r17, 0xFF	; 255
    5178:	8d 8d       	ldd	r24, Y+29	; 0x1d
    517a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    517c:	04 96       	adiw	r24, 0x04	; 4
    517e:	9e 8f       	std	Y+30, r25	; 0x1e
    5180:	8d 8f       	std	Y+29, r24	; 0x1d
    5182:	94 e0       	ldi	r25, 0x04	; 4
    5184:	29 0e       	add	r2, r25
    5186:	31 1c       	adc	r3, r1
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    5188:	e9 8d       	ldd	r30, Y+25	; 0x19
    518a:	fa 8d       	ldd	r31, Y+26	; 0x1a
    518c:	0e 17       	cp	r16, r30
    518e:	1f 07       	cpc	r17, r31
    5190:	09 f0       	breq	.+2      	; 0x5194 <plan_buffer_line+0x3ac>
    5192:	53 cf       	rjmp	.-346    	; 0x503a <plan_buffer_line+0x252>
    5194:	2b 8c       	ldd	r2, Y+27	; 0x1b
    5196:	3c 8c       	ldd	r3, Y+28	; 0x1c
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    }
  }
  
  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if (block_buffer_head == block_buffer_tail) {
    5198:	90 91 49 02 	lds	r25, 0x0249
    519c:	80 91 4a 02 	lds	r24, 0x024A
    51a0:	98 13       	cpse	r25, r24
    51a2:	0a c0       	rjmp	.+20     	; 0x51b8 <plan_buffer_line+0x3d0>
  
    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    block->entry_speed_sqr = 0.0;
    51a4:	f1 01       	movw	r30, r2
    51a6:	11 8a       	std	Z+17, r1	; 0x11
    51a8:	12 8a       	std	Z+18, r1	; 0x12
    51aa:	13 8a       	std	Z+19, r1	; 0x13
    51ac:	14 8a       	std	Z+20, r1	; 0x14
    block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
    51ae:	11 8e       	std	Z+25, r1	; 0x19
    51b0:	12 8e       	std	Z+26, r1	; 0x1a
    51b2:	13 8e       	std	Z+27, r1	; 0x1b
    51b4:	14 8e       	std	Z+28, r1	; 0x1c
    51b6:	4d c0       	rjmp	.+154    	; 0x5252 <plan_buffer_line+0x46a>
       changed dynamically during operation nor can the line move geometry. This must be kept in
       memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
       change the overall maximum entry speed conditions of all blocks.
    */
    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    float sin_theta_d2 = sqrt(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Always positive.
    51b8:	a5 01       	movw	r20, r10
    51ba:	94 01       	movw	r18, r8
    51bc:	60 e0       	ldi	r22, 0x00	; 0
    51be:	70 e0       	ldi	r23, 0x00	; 0
    51c0:	80 e8       	ldi	r24, 0x80	; 128
    51c2:	9f e3       	ldi	r25, 0x3F	; 63
    51c4:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    51c8:	20 e0       	ldi	r18, 0x00	; 0
    51ca:	30 e0       	ldi	r19, 0x00	; 0
    51cc:	40 e0       	ldi	r20, 0x00	; 0
    51ce:	5f e3       	ldi	r21, 0x3F	; 63
    51d0:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    51d4:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    51d8:	6b 01       	movw	r12, r22
    51da:	7c 01       	movw	r14, r24

    // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
    // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
    block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
    51dc:	20 91 75 07 	lds	r18, 0x0775
    51e0:	30 91 76 07 	lds	r19, 0x0776
    51e4:	40 91 77 07 	lds	r20, 0x0777
    51e8:	50 91 78 07 	lds	r21, 0x0778
    51ec:	f1 01       	movw	r30, r2
    51ee:	61 a1       	ldd	r22, Z+33	; 0x21
    51f0:	72 a1       	ldd	r23, Z+34	; 0x22
    51f2:	83 a1       	ldd	r24, Z+35	; 0x23
    51f4:	94 a1       	ldd	r25, Z+36	; 0x24
    51f6:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    51fa:	a7 01       	movw	r20, r14
    51fc:	96 01       	movw	r18, r12
    51fe:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5202:	4b 01       	movw	r8, r22
    5204:	5c 01       	movw	r10, r24
    5206:	a7 01       	movw	r20, r14
    5208:	96 01       	movw	r18, r12
    520a:	60 e0       	ldi	r22, 0x00	; 0
    520c:	70 e0       	ldi	r23, 0x00	; 0
    520e:	80 e8       	ldi	r24, 0x80	; 128
    5210:	9f e3       	ldi	r25, 0x3F	; 63
    5212:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    5216:	9b 01       	movw	r18, r22
    5218:	ac 01       	movw	r20, r24
    521a:	c5 01       	movw	r24, r10
    521c:	b4 01       	movw	r22, r8
    521e:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    5222:	e6 2e       	mov	r14, r22
    5224:	f7 2e       	mov	r15, r23
    5226:	08 2f       	mov	r16, r24
    5228:	19 2f       	mov	r17, r25
    522a:	20 e0       	ldi	r18, 0x00	; 0
    522c:	30 e0       	ldi	r19, 0x00	; 0
    522e:	a9 01       	movw	r20, r18
    5230:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    5234:	88 23       	and	r24, r24
    5236:	24 f4       	brge	.+8      	; 0x5240 <plan_buffer_line+0x458>
    5238:	e1 2c       	mov	r14, r1
    523a:	f1 2c       	mov	r15, r1
    523c:	00 e0       	ldi	r16, 0x00	; 0
    523e:	10 e0       	ldi	r17, 0x00	; 0
    5240:	4e 2d       	mov	r20, r14
    5242:	5f 2d       	mov	r21, r15
    5244:	60 2f       	mov	r22, r16
    5246:	71 2f       	mov	r23, r17
    5248:	f1 01       	movw	r30, r2
    524a:	41 8f       	std	Z+25, r20	; 0x19
    524c:	52 8f       	std	Z+26, r21	; 0x1a
    524e:	63 8f       	std	Z+27, r22	; 0x1b
    5250:	74 8f       	std	Z+28, r23	; 0x1c
                                 (block->acceleration * settings.junction_deviation * sin_theta_d2)/(1.0-sin_theta_d2) );
  }

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
    5252:	29 a1       	ldd	r18, Y+33	; 0x21
    5254:	3a a1       	ldd	r19, Y+34	; 0x22
    5256:	4b a1       	ldd	r20, Y+35	; 0x23
    5258:	5c a1       	ldd	r21, Y+36	; 0x24
    525a:	69 a1       	ldd	r22, Y+33	; 0x21
    525c:	7a a1       	ldd	r23, Y+34	; 0x22
    525e:	8b a1       	ldd	r24, Y+35	; 0x23
    5260:	9c a1       	ldd	r25, Y+36	; 0x24
    5262:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5266:	16 2f       	mov	r17, r22
    5268:	07 2f       	mov	r16, r23
    526a:	f8 2e       	mov	r15, r24
    526c:	e9 2e       	mov	r14, r25
    526e:	86 2f       	mov	r24, r22
    5270:	90 2f       	mov	r25, r16
    5272:	af 2d       	mov	r26, r15
    5274:	be 2d       	mov	r27, r14
    5276:	f1 01       	movw	r30, r2
    5278:	85 8f       	std	Z+29, r24	; 0x1d
    527a:	96 8f       	std	Z+30, r25	; 0x1e
    527c:	a7 8f       	std	Z+31, r26	; 0x1f
    527e:	b0 a3       	std	Z+32, r27	; 0x20
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    5280:	91 8c       	ldd	r9, Z+25	; 0x19
    5282:	82 8c       	ldd	r8, Z+26	; 0x1a
    5284:	73 8c       	ldd	r7, Z+27	; 0x1b
    5286:	64 8c       	ldd	r6, Z+28	; 0x1c
    5288:	a0 90 43 02 	lds	r10, 0x0243
    528c:	b0 90 44 02 	lds	r11, 0x0244
    5290:	c0 90 45 02 	lds	r12, 0x0245
    5294:	d0 90 46 02 	lds	r13, 0x0246
    5298:	2a 2d       	mov	r18, r10
    529a:	3b 2d       	mov	r19, r11
    529c:	4c 2d       	mov	r20, r12
    529e:	5d 2d       	mov	r21, r13
    52a0:	61 2f       	mov	r22, r17
    52a2:	70 2f       	mov	r23, r16
    52a4:	8f 2d       	mov	r24, r15
    52a6:	9e 2d       	mov	r25, r14
    52a8:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    52ac:	88 23       	and	r24, r24
    52ae:	0c f4       	brge	.+2      	; 0x52b2 <plan_buffer_line+0x4ca>
    52b0:	55 c0       	rjmp	.+170    	; 0x535c <plan_buffer_line+0x574>
    52b2:	2a 2d       	mov	r18, r10
    52b4:	3b 2d       	mov	r19, r11
    52b6:	4c 2d       	mov	r20, r12
    52b8:	5d 2d       	mov	r21, r13
    52ba:	69 2d       	mov	r22, r9
    52bc:	78 2d       	mov	r23, r8
    52be:	87 2d       	mov	r24, r7
    52c0:	96 2d       	mov	r25, r6
    52c2:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    52c6:	88 23       	and	r24, r24
    52c8:	ac f0       	brlt	.+42     	; 0x52f4 <plan_buffer_line+0x50c>
    52ca:	2a 2d       	mov	r18, r10
    52cc:	3b 2d       	mov	r19, r11
    52ce:	4c 2d       	mov	r20, r12
    52d0:	5d 2d       	mov	r21, r13
    52d2:	61 2f       	mov	r22, r17
    52d4:	70 2f       	mov	r23, r16
    52d6:	8f 2d       	mov	r24, r15
    52d8:	9e 2d       	mov	r25, r14
    52da:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    52de:	88 23       	and	r24, r24
    52e0:	2c f4       	brge	.+10     	; 0x52ec <plan_buffer_line+0x504>
    52e2:	91 2e       	mov	r9, r17
    52e4:	80 2e       	mov	r8, r16
    52e6:	7f 2c       	mov	r7, r15
    52e8:	6e 2c       	mov	r6, r14
    52ea:	04 c0       	rjmp	.+8      	; 0x52f4 <plan_buffer_line+0x50c>
    52ec:	9a 2c       	mov	r9, r10
    52ee:	8b 2c       	mov	r8, r11
    52f0:	7c 2c       	mov	r7, r12
    52f2:	6d 2c       	mov	r6, r13
    52f4:	89 2d       	mov	r24, r9
    52f6:	98 2d       	mov	r25, r8
    52f8:	a7 2d       	mov	r26, r7
    52fa:	b6 2d       	mov	r27, r6
    52fc:	f1 01       	movw	r30, r2
    52fe:	85 8b       	std	Z+21, r24	; 0x15
    5300:	96 8b       	std	Z+22, r25	; 0x16
    5302:	a7 8b       	std	Z+23, r26	; 0x17
    5304:	b0 8f       	std	Z+24, r27	; 0x18
                                   min(block->nominal_speed_sqr,pl.previous_nominal_speed_sqr));
  
  // Update previous path unit_vector and nominal speed (squared)
  memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
    5306:	8c e0       	ldi	r24, 0x0C	; 12
    5308:	fe 01       	movw	r30, r28
    530a:	3d 96       	adiw	r30, 0x0d	; 13
    530c:	a7 e3       	ldi	r26, 0x37	; 55
    530e:	b2 e0       	ldi	r27, 0x02	; 2
    5310:	01 90       	ld	r0, Z+
    5312:	0d 92       	st	X+, r0
    5314:	8a 95       	dec	r24
    5316:	e1 f7       	brne	.-8      	; 0x5310 <plan_buffer_line+0x528>
  pl.previous_nominal_speed_sqr = block->nominal_speed_sqr;
    5318:	81 2f       	mov	r24, r17
    531a:	90 2f       	mov	r25, r16
    531c:	af 2d       	mov	r26, r15
    531e:	be 2d       	mov	r27, r14
    5320:	80 93 43 02 	sts	0x0243, r24
    5324:	90 93 44 02 	sts	0x0244, r25
    5328:	a0 93 45 02 	sts	0x0245, r26
    532c:	b0 93 46 02 	sts	0x0246, r27
    
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
    5330:	8c e0       	ldi	r24, 0x0C	; 12
    5332:	fe 01       	movw	r30, r28
    5334:	31 96       	adiw	r30, 0x01	; 1
    5336:	ab e2       	ldi	r26, 0x2B	; 43
    5338:	b2 e0       	ldi	r27, 0x02	; 2
    533a:	01 90       	ld	r0, Z+
    533c:	0d 92       	st	X+, r0
    533e:	8a 95       	dec	r24
    5340:	e1 f7       	brne	.-8      	; 0x533a <plan_buffer_line+0x552>

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
    5342:	80 91 48 02 	lds	r24, 0x0248
    5346:	80 93 49 02 	sts	0x0249, r24


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    534a:	8f 5f       	subi	r24, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    534c:	84 31       	cpi	r24, 0x14	; 20
    534e:	09 f4       	brne	.+2      	; 0x5352 <plan_buffer_line+0x56a>
    5350:	80 e0       	ldi	r24, 0x00	; 0
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
    5352:	80 93 48 02 	sts	0x0248, r24
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
    5356:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <planner_recalculate>
    535a:	0e c0       	rjmp	.+28     	; 0x5378 <plan_buffer_line+0x590>

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    535c:	29 2d       	mov	r18, r9
    535e:	38 2d       	mov	r19, r8
    5360:	47 2d       	mov	r20, r7
    5362:	56 2d       	mov	r21, r6
    5364:	61 2f       	mov	r22, r17
    5366:	70 2f       	mov	r23, r16
    5368:	8f 2d       	mov	r24, r15
    536a:	9e 2d       	mov	r25, r14
    536c:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    5370:	18 16       	cp	r1, r24
    5372:	0c f0       	brlt	.+2      	; 0x5376 <plan_buffer_line+0x58e>
    5374:	b6 cf       	rjmp	.-148    	; 0x52e2 <plan_buffer_line+0x4fa>
    5376:	be cf       	rjmp	.-132    	; 0x52f4 <plan_buffer_line+0x50c>
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
}
    5378:	ad 96       	adiw	r28, 0x2d	; 45
    537a:	0f b6       	in	r0, 0x3f	; 63
    537c:	f8 94       	cli
    537e:	de bf       	out	0x3e, r29	; 62
    5380:	0f be       	out	0x3f, r0	; 63
    5382:	cd bf       	out	0x3d, r28	; 61
    5384:	df 91       	pop	r29
    5386:	cf 91       	pop	r28
    5388:	1f 91       	pop	r17
    538a:	0f 91       	pop	r16
    538c:	ff 90       	pop	r15
    538e:	ef 90       	pop	r14
    5390:	df 90       	pop	r13
    5392:	cf 90       	pop	r12
    5394:	bf 90       	pop	r11
    5396:	af 90       	pop	r10
    5398:	9f 90       	pop	r9
    539a:	8f 90       	pop	r8
    539c:	7f 90       	pop	r7
    539e:	6f 90       	pop	r6
    53a0:	5f 90       	pop	r5
    53a2:	4f 90       	pop	r4
    53a4:	3f 90       	pop	r3
    53a6:	2f 90       	pop	r2
    53a8:	08 95       	ret

000053aa <plan_sync_position>:
// Reset the planner position vectors. Called by the system abort/initialization routine.
void plan_sync_position()
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    pl.position[idx] = sys.position[idx];
    53aa:	80 91 87 05 	lds	r24, 0x0587
    53ae:	90 91 88 05 	lds	r25, 0x0588
    53b2:	a0 91 89 05 	lds	r26, 0x0589
    53b6:	b0 91 8a 05 	lds	r27, 0x058A
    53ba:	80 93 2b 02 	sts	0x022B, r24
    53be:	90 93 2c 02 	sts	0x022C, r25
    53c2:	a0 93 2d 02 	sts	0x022D, r26
    53c6:	b0 93 2e 02 	sts	0x022E, r27
    53ca:	80 91 8b 05 	lds	r24, 0x058B
    53ce:	90 91 8c 05 	lds	r25, 0x058C
    53d2:	a0 91 8d 05 	lds	r26, 0x058D
    53d6:	b0 91 8e 05 	lds	r27, 0x058E
    53da:	80 93 2f 02 	sts	0x022F, r24
    53de:	90 93 30 02 	sts	0x0230, r25
    53e2:	a0 93 31 02 	sts	0x0231, r26
    53e6:	b0 93 32 02 	sts	0x0232, r27
    53ea:	80 91 8f 05 	lds	r24, 0x058F
    53ee:	90 91 90 05 	lds	r25, 0x0590
    53f2:	a0 91 91 05 	lds	r26, 0x0591
    53f6:	b0 91 92 05 	lds	r27, 0x0592
    53fa:	80 93 33 02 	sts	0x0233, r24
    53fe:	90 93 34 02 	sts	0x0234, r25
    5402:	a0 93 35 02 	sts	0x0235, r26
    5406:	b0 93 36 02 	sts	0x0236, r27
    540a:	08 95       	ret

0000540c <plan_get_block_buffer_count>:


// Returns the number of active blocks are in the planner buffer.
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
    540c:	80 91 49 02 	lds	r24, 0x0249
    5410:	90 91 4a 02 	lds	r25, 0x024A
    5414:	89 17       	cp	r24, r25
    5416:	10 f0       	brcs	.+4      	; 0x541c <plan_get_block_buffer_count+0x10>
    5418:	89 1b       	sub	r24, r25
    541a:	08 95       	ret
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
    541c:	8c 5e       	subi	r24, 0xEC	; 236
    541e:	89 1b       	sub	r24, r25
}
    5420:	08 95       	ret

00005422 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    5422:	0e 94 c7 1a 	call	0x358e	; 0x358e <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    5426:	80 91 4a 02 	lds	r24, 0x024A
    542a:	80 93 47 02 	sts	0x0247, r24
  planner_recalculate();  
    542e:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <planner_recalculate>
    5432:	08 95       	ret

00005434 <read_float>:
// CNC applications, the typical decimal value is expected to be in the range of E0 to E-4.
// Scientific notation is officially not supported by g-code, and the 'E' character may
// be a g-code word on some CNC systems. So, 'E' notation will not be recognized. 
// NOTE: Thanks to Radu-Eosif Mihailescu for identifying the issues with using strtod().
uint8_t read_float(char *line, uint8_t *char_counter, float *float_ptr)                  
{
    5434:	4f 92       	push	r4
    5436:	5f 92       	push	r5
    5438:	6f 92       	push	r6
    543a:	7f 92       	push	r7
    543c:	9f 92       	push	r9
    543e:	af 92       	push	r10
    5440:	bf 92       	push	r11
    5442:	cf 92       	push	r12
    5444:	df 92       	push	r13
    5446:	ef 92       	push	r14
    5448:	ff 92       	push	r15
    544a:	0f 93       	push	r16
    544c:	1f 93       	push	r17
    544e:	cf 93       	push	r28
    5450:	df 93       	push	r29
    5452:	7c 01       	movw	r14, r24
    5454:	8b 01       	movw	r16, r22
    5456:	6a 01       	movw	r12, r20
  char *ptr = line + *char_counter;
    5458:	fb 01       	movw	r30, r22
    545a:	80 81       	ld	r24, Z
    545c:	f7 01       	movw	r30, r14
    545e:	e8 0f       	add	r30, r24
    5460:	f1 1d       	adc	r31, r1
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
    5462:	40 81       	ld	r20, Z
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    5464:	4d 32       	cpi	r20, 0x2D	; 45
    5466:	39 f4       	brne	.+14     	; 0x5476 <read_float+0x42>
    isnegative = true;
    c = *ptr++;
    5468:	9f 01       	movw	r18, r30
    546a:	2e 5f       	subi	r18, 0xFE	; 254
    546c:	3f 4f       	sbci	r19, 0xFF	; 255
    546e:	41 81       	ldd	r20, Z+1	; 0x01
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
  if (c == '-') {
    isnegative = true;
    5470:	aa 24       	eor	r10, r10
    5472:	a3 94       	inc	r10
    5474:	0c c0       	rjmp	.+24     	; 0x548e <read_float+0x5a>
    c = *ptr++;
  } else if (c == '+') {
    5476:	4b 32       	cpi	r20, 0x2B	; 43
    5478:	29 f0       	breq	.+10     	; 0x5484 <read_float+0x50>
{
  char *ptr = line + *char_counter;
  unsigned char c;
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
    547a:	9f 01       	movw	r18, r30
    547c:	2f 5f       	subi	r18, 0xFF	; 255
    547e:	3f 4f       	sbci	r19, 0xFF	; 255
  
  // Capture initial positive/minus character
  bool isnegative = false;
    5480:	a1 2c       	mov	r10, r1
    5482:	05 c0       	rjmp	.+10     	; 0x548e <read_float+0x5a>
  if (c == '-') {
    isnegative = true;
    c = *ptr++;
  } else if (c == '+') {
    c = *ptr++;
    5484:	9f 01       	movw	r18, r30
    5486:	2e 5f       	subi	r18, 0xFE	; 254
    5488:	3f 4f       	sbci	r19, 0xFF	; 255
    548a:	41 81       	ldd	r20, Z+1	; 0x01
    
  // Grab first character and increment pointer. No spaces assumed in line.
  c = *ptr++;
  
  // Capture initial positive/minus character
  bool isnegative = false;
    548c:	a1 2c       	mov	r10, r1
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
    548e:	e0 e0       	ldi	r30, 0x00	; 0
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
    5490:	50 e0       	ldi	r21, 0x00	; 0
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
  int8_t exp = 0;
    5492:	b1 2c       	mov	r11, r1
  } else if (c == '+') {
    c = *ptr++;
  }
  
  // Extract number into fast integer. Track decimal in terms of exponent value.
  uint32_t intval = 0;
    5494:	60 e0       	ldi	r22, 0x00	; 0
    5496:	70 e0       	ldi	r23, 0x00	; 0
    5498:	cb 01       	movw	r24, r22
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
      isdecimal = true;
    549a:	f1 e0       	ldi	r31, 0x01	; 1
    549c:	e9 01       	movw	r28, r18
  uint32_t intval = 0;
  int8_t exp = 0;
  uint8_t ndigit = 0;
  bool isdecimal = false;
  while(1) {
    c -= '0';
    549e:	40 53       	subi	r20, 0x30	; 48
    if (c <= 9) {
    54a0:	4a 30       	cpi	r20, 0x0A	; 10
    54a2:	20 f5       	brcc	.+72     	; 0x54ec <read_float+0xb8>
      ndigit++;
    54a4:	5f 5f       	subi	r21, 0xFF	; 255
      if (ndigit <= MAX_INT_DIGITS) {
    54a6:	59 30       	cpi	r21, 0x09	; 9
    54a8:	e8 f4       	brcc	.+58     	; 0x54e4 <read_float+0xb0>
        if (isdecimal) { exp--; }
    54aa:	e1 11       	cpse	r30, r1
    54ac:	ba 94       	dec	r11
        intval = (((intval << 2) + intval) << 1) + c; // intval*10 + c
    54ae:	2b 01       	movw	r4, r22
    54b0:	3c 01       	movw	r6, r24
    54b2:	44 0c       	add	r4, r4
    54b4:	55 1c       	adc	r5, r5
    54b6:	66 1c       	adc	r6, r6
    54b8:	77 1c       	adc	r7, r7
    54ba:	44 0c       	add	r4, r4
    54bc:	55 1c       	adc	r5, r5
    54be:	66 1c       	adc	r6, r6
    54c0:	77 1c       	adc	r7, r7
    54c2:	dc 01       	movw	r26, r24
    54c4:	cb 01       	movw	r24, r22
    54c6:	84 0d       	add	r24, r4
    54c8:	95 1d       	adc	r25, r5
    54ca:	a6 1d       	adc	r26, r6
    54cc:	b7 1d       	adc	r27, r7
    54ce:	88 0f       	add	r24, r24
    54d0:	99 1f       	adc	r25, r25
    54d2:	aa 1f       	adc	r26, r26
    54d4:	bb 1f       	adc	r27, r27
    54d6:	bc 01       	movw	r22, r24
    54d8:	cd 01       	movw	r24, r26
    54da:	64 0f       	add	r22, r20
    54dc:	71 1d       	adc	r23, r1
    54de:	81 1d       	adc	r24, r1
    54e0:	91 1d       	adc	r25, r1
    54e2:	09 c0       	rjmp	.+18     	; 0x54f6 <read_float+0xc2>
      } else {
        if (!(isdecimal)) { exp++; }  // Drop overflow digits
    54e4:	e1 11       	cpse	r30, r1
    54e6:	07 c0       	rjmp	.+14     	; 0x54f6 <read_float+0xc2>
    54e8:	b3 94       	inc	r11
    54ea:	05 c0       	rjmp	.+10     	; 0x54f6 <read_float+0xc2>
      }
    } else if (c == (('.'-'0') & 0xff)  &&  !(isdecimal)) {
    54ec:	4e 3f       	cpi	r20, 0xFE	; 254
    54ee:	39 f4       	brne	.+14     	; 0x54fe <read_float+0xca>
    54f0:	e1 11       	cpse	r30, r1
    54f2:	07 c0       	rjmp	.+14     	; 0x5502 <read_float+0xce>
      isdecimal = true;
    54f4:	ef 2f       	mov	r30, r31
    } else {
      break;
    }
    c = *ptr++;
    54f6:	48 81       	ld	r20, Y
    54f8:	2f 5f       	subi	r18, 0xFF	; 255
    54fa:	3f 4f       	sbci	r19, 0xFF	; 255
  }
    54fc:	cf cf       	rjmp	.-98     	; 0x549c <read_float+0x68>
    54fe:	9b 2c       	mov	r9, r11
    5500:	01 c0       	rjmp	.+2      	; 0x5504 <read_float+0xd0>
    5502:	9b 2c       	mov	r9, r11
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
    5504:	55 23       	and	r21, r21
    5506:	09 f4       	brne	.+2      	; 0x550a <read_float+0xd6>
    5508:	50 c0       	rjmp	.+160    	; 0x55aa <read_float+0x176>
  
  // Convert integer into floating point.
  float fval;
  fval = (float)intval;
    550a:	0e 94 fc 39 	call	0x73f8	; 0x73f8 <__floatunsisf>
    550e:	2b 01       	movw	r4, r22
    5510:	3c 01       	movw	r6, r24
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    5512:	20 e0       	ldi	r18, 0x00	; 0
    5514:	30 e0       	ldi	r19, 0x00	; 0
    5516:	a9 01       	movw	r20, r18
    5518:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    551c:	88 23       	and	r24, r24
    551e:	69 f1       	breq	.+90     	; 0x557a <read_float+0x146>
    while (exp <= -2) {
    5520:	ff ef       	ldi	r31, 0xFF	; 255
    5522:	9f 16       	cp	r9, r31
    5524:	7c f4       	brge	.+30     	; 0x5544 <read_float+0x110>
      fval *= 0.01; 
    5526:	2a e0       	ldi	r18, 0x0A	; 10
    5528:	37 ed       	ldi	r19, 0xD7	; 215
    552a:	43 e2       	ldi	r20, 0x23	; 35
    552c:	5c e3       	ldi	r21, 0x3C	; 60
    552e:	c3 01       	movw	r24, r6
    5530:	b2 01       	movw	r22, r4
    5532:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5536:	2b 01       	movw	r4, r22
    5538:	3c 01       	movw	r6, r24
    553a:	b3 94       	inc	r11
    553c:	b3 94       	inc	r11
  fval = (float)intval;
  
  // Apply decimal. Should perform no more than two floating point multiplications for the
  // expected range of E0 to E-4.
  if (fval != 0) {
    while (exp <= -2) {
    553e:	8f ef       	ldi	r24, 0xFF	; 255
    5540:	b8 16       	cp	r11, r24
    5542:	8c f3       	brlt	.-30     	; 0x5526 <read_float+0xf2>
      fval *= 0.01; 
      exp += 2;
    }
    if (exp < 0) { 
    5544:	bb 20       	and	r11, r11
    5546:	5c f4       	brge	.+22     	; 0x555e <read_float+0x12a>
      fval *= 0.1; 
    5548:	2d ec       	ldi	r18, 0xCD	; 205
    554a:	3c ec       	ldi	r19, 0xCC	; 204
    554c:	4c ec       	ldi	r20, 0xCC	; 204
    554e:	5d e3       	ldi	r21, 0x3D	; 61
    5550:	c3 01       	movw	r24, r6
    5552:	b2 01       	movw	r22, r4
    5554:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5558:	2b 01       	movw	r4, r22
    555a:	3c 01       	movw	r6, r24
    555c:	0e c0       	rjmp	.+28     	; 0x557a <read_float+0x146>
    } else if (exp > 0) {
    555e:	1b 14       	cp	r1, r11
    5560:	64 f4       	brge	.+24     	; 0x557a <read_float+0x146>
      do {
        fval *= 10.0;
    5562:	20 e0       	ldi	r18, 0x00	; 0
    5564:	30 e0       	ldi	r19, 0x00	; 0
    5566:	40 e2       	ldi	r20, 0x20	; 32
    5568:	51 e4       	ldi	r21, 0x41	; 65
    556a:	c3 01       	movw	r24, r6
    556c:	b2 01       	movw	r22, r4
    556e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5572:	2b 01       	movw	r4, r22
    5574:	3c 01       	movw	r6, r24
      } while (--exp > 0);
    5576:	ba 94       	dec	r11
    5578:	a1 f7       	brne	.-24     	; 0x5562 <read_float+0x12e>
    } 
  }

  // Assign floating point value with correct sign.    
  if (isnegative) {
    557a:	aa 20       	and	r10, r10
    557c:	51 f0       	breq	.+20     	; 0x5592 <read_float+0x15e>
    *float_ptr = -fval;
    557e:	77 fa       	bst	r7, 7
    5580:	70 94       	com	r7
    5582:	77 f8       	bld	r7, 7
    5584:	70 94       	com	r7
    5586:	f6 01       	movw	r30, r12
    5588:	40 82       	st	Z, r4
    558a:	51 82       	std	Z+1, r5	; 0x01
    558c:	62 82       	std	Z+2, r6	; 0x02
    558e:	73 82       	std	Z+3, r7	; 0x03
    5590:	05 c0       	rjmp	.+10     	; 0x559c <read_float+0x168>
  } else {
    *float_ptr = fval;
    5592:	f6 01       	movw	r30, r12
    5594:	40 82       	st	Z, r4
    5596:	51 82       	std	Z+1, r5	; 0x01
    5598:	62 82       	std	Z+2, r6	; 0x02
    559a:	73 82       	std	Z+3, r7	; 0x03
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
    559c:	ce 19       	sub	r28, r14
    559e:	df 09       	sbc	r29, r15
    55a0:	c1 50       	subi	r28, 0x01	; 1
    55a2:	f8 01       	movw	r30, r16
    55a4:	c0 83       	st	Z, r28
  
  return(true);
    55a6:	81 e0       	ldi	r24, 0x01	; 1
    55a8:	01 c0       	rjmp	.+2      	; 0x55ac <read_float+0x178>
    }
    c = *ptr++;
  }
  
  // Return if no digits have been read.
  if (!ndigit) { return(false); };
    55aa:	80 e0       	ldi	r24, 0x00	; 0
  }

  *char_counter = ptr - line - 1; // Set char_counter to next statement
  
  return(true);
}
    55ac:	df 91       	pop	r29
    55ae:	cf 91       	pop	r28
    55b0:	1f 91       	pop	r17
    55b2:	0f 91       	pop	r16
    55b4:	ff 90       	pop	r15
    55b6:	ef 90       	pop	r14
    55b8:	df 90       	pop	r13
    55ba:	cf 90       	pop	r12
    55bc:	bf 90       	pop	r11
    55be:	af 90       	pop	r10
    55c0:	9f 90       	pop	r9
    55c2:	7f 90       	pop	r7
    55c4:	6f 90       	pop	r6
    55c6:	5f 90       	pop	r5
    55c8:	4f 90       	pop	r4
    55ca:	08 95       	ret

000055cc <delay_ms>:

// Delays variable defined milliseconds. Compiler compatibility fix for _delay_ms(),
// which only accepts constants in future compiler releases.
void delay_ms(uint16_t ms) 
{
  while ( ms-- ) { _delay_ms(1); }
    55cc:	00 97       	sbiw	r24, 0x00	; 0
    55ce:	49 f0       	breq	.+18     	; 0x55e2 <delay_ms+0x16>
    55d0:	ef e9       	ldi	r30, 0x9F	; 159
    55d2:	ff e0       	ldi	r31, 0x0F	; 15
    55d4:	31 97       	sbiw	r30, 0x01	; 1
    55d6:	f1 f7       	brne	.-4      	; 0x55d4 <delay_ms+0x8>
    55d8:	00 c0       	rjmp	.+0      	; 0x55da <delay_ms+0xe>
    55da:	00 00       	nop
    55dc:	01 97       	sbiw	r24, 0x01	; 1
    55de:	00 97       	sbiw	r24, 0x00	; 0
    55e0:	b9 f7       	brne	.-18     	; 0x55d0 <delay_ms+0x4>
    55e2:	08 95       	ret

000055e4 <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    55e4:	8f 92       	push	r8
    55e6:	9f 92       	push	r9
    55e8:	af 92       	push	r10
    55ea:	bf 92       	push	r11
    55ec:	cf 92       	push	r12
    55ee:	df 92       	push	r13
    55f0:	ef 92       	push	r14
    55f2:	ff 92       	push	r15
    55f4:	69 01       	movw	r12, r18
    55f6:	7a 01       	movw	r14, r20
    55f8:	9b 01       	movw	r18, r22
    55fa:	ac 01       	movw	r20, r24
    55fc:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5600:	4b 01       	movw	r8, r22
    5602:	5c 01       	movw	r10, r24
    5604:	a7 01       	movw	r20, r14
    5606:	96 01       	movw	r18, r12
    5608:	c7 01       	movw	r24, r14
    560a:	b6 01       	movw	r22, r12
    560c:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5610:	9b 01       	movw	r18, r22
    5612:	ac 01       	movw	r20, r24
    5614:	c5 01       	movw	r24, r10
    5616:	b4 01       	movw	r22, r8
    5618:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    561c:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    5620:	ff 90       	pop	r15
    5622:	ef 90       	pop	r14
    5624:	df 90       	pop	r13
    5626:	cf 90       	pop	r12
    5628:	bf 90       	pop	r11
    562a:	af 90       	pop	r10
    562c:	9f 90       	pop	r9
    562e:	8f 90       	pop	r8
    5630:	08 95       	ret

00005632 <limits_disable>:
}


void limits_disable()
{
  LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    5632:	eb e6       	ldi	r30, 0x6B	; 107
    5634:	f0 e0       	ldi	r31, 0x00	; 0
    5636:	80 81       	ld	r24, Z
    5638:	81 7f       	andi	r24, 0xF1	; 241
    563a:	80 83       	st	Z, r24
  PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    563c:	e8 e6       	ldi	r30, 0x68	; 104
    563e:	f0 e0       	ldi	r31, 0x00	; 0
    5640:	80 81       	ld	r24, Z
    5642:	8e 7f       	andi	r24, 0xFE	; 254
    5644:	80 83       	st	Z, r24
    5646:	08 95       	ret

00005648 <limits_init>:
#define HOMING_AXIS_SEARCH_SCALAR  1.5 // Must be > 1 to ensure limit switch will be engaged.


void limits_init() 
{
  LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    5648:	84 b1       	in	r24, 0x04	; 4
    564a:	81 7f       	andi	r24, 0xF1	; 241
    564c:	84 b9       	out	0x04, r24	; 4

  if (bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) {
    564e:	80 91 7d 07 	lds	r24, 0x077D
    5652:	86 ff       	sbrs	r24, 6
    5654:	04 c0       	rjmp	.+8      	; 0x565e <limits_init+0x16>
    LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
    5656:	85 b1       	in	r24, 0x05	; 5
    5658:	81 7f       	andi	r24, 0xF1	; 241
    565a:	85 b9       	out	0x05, r24	; 5
    565c:	03 c0       	rjmp	.+6      	; 0x5664 <limits_init+0x1c>
  } else {
    LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    565e:	85 b1       	in	r24, 0x05	; 5
    5660:	8e 60       	ori	r24, 0x0E	; 14
    5662:	85 b9       	out	0x05, r24	; 5
  }

  if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    5664:	80 91 7d 07 	lds	r24, 0x077D
    5668:	83 ff       	sbrs	r24, 3
    566a:	0b c0       	rjmp	.+22     	; 0x5682 <limits_init+0x3a>
    LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    566c:	eb e6       	ldi	r30, 0x6B	; 107
    566e:	f0 e0       	ldi	r31, 0x00	; 0
    5670:	80 81       	ld	r24, Z
    5672:	8e 60       	ori	r24, 0x0E	; 14
    5674:	80 83       	st	Z, r24
    PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    5676:	e8 e6       	ldi	r30, 0x68	; 104
    5678:	f0 e0       	ldi	r31, 0x00	; 0
    567a:	80 81       	ld	r24, Z
    567c:	81 60       	ori	r24, 0x01	; 1
    567e:	80 83       	st	Z, r24
    5680:	08 95       	ret
  } else {
    limits_disable(); 
    5682:	0e 94 19 2b 	call	0x5632	; 0x5632 <limits_disable>
    5686:	08 95       	ret

00005688 <__vector_3>:
// homing cycles and will not respond correctly. Upon user request or need, there may be a
// special pinout for an e-stop, but it is generally recommended to just directly connect
// your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
#ifndef ENABLE_SOFTWARE_DEBOUNCE
  ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process. 
  {
    5688:	1f 92       	push	r1
    568a:	0f 92       	push	r0
    568c:	0f b6       	in	r0, 0x3f	; 63
    568e:	0f 92       	push	r0
    5690:	11 24       	eor	r1, r1
    5692:	2f 93       	push	r18
    5694:	3f 93       	push	r19
    5696:	4f 93       	push	r20
    5698:	5f 93       	push	r21
    569a:	6f 93       	push	r22
    569c:	7f 93       	push	r23
    569e:	8f 93       	push	r24
    56a0:	9f 93       	push	r25
    56a2:	af 93       	push	r26
    56a4:	bf 93       	push	r27
    56a6:	ef 93       	push	r30
    56a8:	ff 93       	push	r31
    // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
    // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
    // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
    // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
    // limit setting if their limits are constantly triggering after a reset and move their axes.
    if (sys.state != STATE_ALARM) { 
    56aa:	80 91 84 05 	lds	r24, 0x0584
    56ae:	81 30       	cpi	r24, 0x01	; 1
    56b0:	71 f0       	breq	.+28     	; 0x56ce <__vector_3+0x46>
      if (bit_isfalse(sys.execute,EXEC_ALARM)) {
    56b2:	80 91 85 05 	lds	r24, 0x0585
    56b6:	85 fd       	sbrc	r24, 5
    56b8:	0a c0       	rjmp	.+20     	; 0x56ce <__vector_3+0x46>
        mc_reset(); // Initiate system kill.
    56ba:	0e 94 d6 09 	call	0x13ac	; 0x13ac <mc_reset>
        bit_true_atomic(sys.execute, (EXEC_ALARM | EXEC_CRIT_EVENT)); // Indicate hard limit critical event
    56be:	8f b7       	in	r24, 0x3f	; 63
    56c0:	f8 94       	cli
    56c2:	e5 e8       	ldi	r30, 0x85	; 133
    56c4:	f5 e0       	ldi	r31, 0x05	; 5
    56c6:	90 81       	ld	r25, Z
    56c8:	90 66       	ori	r25, 0x60	; 96
    56ca:	90 83       	st	Z, r25
    56cc:	8f bf       	out	0x3f, r24	; 63
      }
    }
  }  
    56ce:	ff 91       	pop	r31
    56d0:	ef 91       	pop	r30
    56d2:	bf 91       	pop	r27
    56d4:	af 91       	pop	r26
    56d6:	9f 91       	pop	r25
    56d8:	8f 91       	pop	r24
    56da:	7f 91       	pop	r23
    56dc:	6f 91       	pop	r22
    56de:	5f 91       	pop	r21
    56e0:	4f 91       	pop	r20
    56e2:	3f 91       	pop	r19
    56e4:	2f 91       	pop	r18
    56e6:	0f 90       	pop	r0
    56e8:	0f be       	out	0x3f, r0	; 63
    56ea:	0f 90       	pop	r0
    56ec:	1f 90       	pop	r1
    56ee:	18 95       	reti

000056f0 <limits_go_home>:
// the trigger point of the limit switches. The rapid stops are handled by a system level axis lock 
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically 
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort runtime command can interrupt this process.
void limits_go_home(uint8_t cycle_mask) 
{
    56f0:	2f 92       	push	r2
    56f2:	3f 92       	push	r3
    56f4:	4f 92       	push	r4
    56f6:	5f 92       	push	r5
    56f8:	6f 92       	push	r6
    56fa:	7f 92       	push	r7
    56fc:	8f 92       	push	r8
    56fe:	9f 92       	push	r9
    5700:	af 92       	push	r10
    5702:	bf 92       	push	r11
    5704:	cf 92       	push	r12
    5706:	df 92       	push	r13
    5708:	ef 92       	push	r14
    570a:	ff 92       	push	r15
    570c:	0f 93       	push	r16
    570e:	1f 93       	push	r17
    5710:	cf 93       	push	r28
    5712:	df 93       	push	r29
    5714:	cd b7       	in	r28, 0x3d	; 61
    5716:	de b7       	in	r29, 0x3e	; 62
    5718:	ae 97       	sbiw	r28, 0x2e	; 46
    571a:	0f b6       	in	r0, 0x3f	; 63
    571c:	f8 94       	cli
    571e:	de bf       	out	0x3e, r29	; 62
    5720:	0f be       	out	0x3f, r0	; 63
    5722:	cd bf       	out	0x3d, r28	; 61
    5724:	e8 2e       	mov	r14, r24
  if (sys.abort) { return; } // Block if system reset has been issued.
    5726:	80 91 83 05 	lds	r24, 0x0583
    572a:	81 11       	cpse	r24, r1
    572c:	fe c1       	rjmp	.+1020   	; 0x5b2a <limits_go_home+0x43a>

  // Initialize homing in search mode to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    572e:	80 91 83 07 	lds	r24, 0x0783
    5732:	90 91 84 07 	lds	r25, 0x0784
    5736:	a0 91 85 07 	lds	r26, 0x0785
    573a:	b0 91 86 07 	lds	r27, 0x0786
    573e:	8d 8f       	std	Y+29, r24	; 0x1d
    5740:	9e 8f       	std	Y+30, r25	; 0x1e
    5742:	af 8f       	std	Y+31, r26	; 0x1f
    5744:	b8 a3       	std	Y+32, r27	; 0x20
    5746:	1e 01       	movw	r2, r28
    5748:	9d e0       	ldi	r25, 0x0D	; 13
    574a:	29 0e       	add	r2, r25
    574c:	31 1c       	adc	r3, r1
    574e:	de 01       	movw	r26, r28
    5750:	50 96       	adiw	r26, 0x10	; 16
    5752:	bc 8b       	std	Y+20, r27	; 0x14
    5754:	ab 8b       	std	Y+19, r26	; 0x13
    5756:	0f 2e       	mov	r0, r31
    5758:	f4 e6       	ldi	r31, 0x64	; 100
    575a:	af 2e       	mov	r10, r31
    575c:	f7 e0       	ldi	r31, 0x07	; 7
    575e:	bf 2e       	mov	r11, r31
    5760:	f0 2d       	mov	r31, r0
    5762:	be 8b       	std	Y+22, r27	; 0x16
    5764:	ad 8b       	std	Y+21, r26	; 0x15
    5766:	6d 01       	movw	r12, r26
    5768:	81 01       	movw	r16, r2
  uint8_t invert_pin, idx;
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  float target[N_AXIS];
  
  uint8_t limit_pin[N_AXIS], step_pin[N_AXIS];
  float max_travel = 0.0;
    576a:	f1 2c       	mov	r15, r1
    576c:	41 2c       	mov	r4, r1
    576e:	51 2c       	mov	r5, r1
    5770:	71 2c       	mov	r7, r1
    5772:	ef 8a       	std	Y+23, r14	; 0x17
    5774:	94 2c       	mov	r9, r4
    5776:	85 2c       	mov	r8, r5
    5778:	e7 2c       	mov	r14, r7
    577a:	70 2e       	mov	r7, r16
    577c:	72 18       	sub	r7, r2
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize limit and step pin masks
    limit_pin[idx] = get_limit_pin_mask(idx);
    577e:	87 2d       	mov	r24, r7
    5780:	0e 94 5f 25 	call	0x4abe	; 0x4abe <get_limit_pin_mask>
    5784:	d8 01       	movw	r26, r16
    5786:	8d 93       	st	X+, r24
    5788:	8d 01       	movw	r16, r26
    step_pin[idx] = get_step_pin_mask(idx);
    578a:	87 2d       	mov	r24, r7
    578c:	0e 94 4b 25 	call	0x4a96	; 0x4a96 <get_step_pin_mask>
    5790:	f6 01       	movw	r30, r12
    5792:	81 93       	st	Z+, r24
    5794:	6f 01       	movw	r12, r30

    // Determine travel distance to the furthest homing switch based on user max travel settings.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (max_travel > settings.max_travel[idx]) { max_travel = settings.max_travel[idx]; }
    5796:	d5 01       	movw	r26, r10
    5798:	4d 90       	ld	r4, X+
    579a:	5d 90       	ld	r5, X+
    579c:	6d 90       	ld	r6, X+
    579e:	7d 90       	ld	r7, X+
    57a0:	5d 01       	movw	r10, r26
    57a2:	2f 2d       	mov	r18, r15
    57a4:	39 2d       	mov	r19, r9
    57a6:	48 2d       	mov	r20, r8
    57a8:	5e 2d       	mov	r21, r14
    57aa:	c3 01       	movw	r24, r6
    57ac:	b2 01       	movw	r22, r4
    57ae:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    57b2:	88 23       	and	r24, r24
    57b4:	24 f4       	brge	.+8      	; 0x57be <limits_go_home+0xce>
    57b6:	f4 2c       	mov	r15, r4
    57b8:	95 2c       	mov	r9, r5
    57ba:	86 2c       	mov	r8, r6
    57bc:	e7 2c       	mov	r14, r7
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  float target[N_AXIS];
  
  uint8_t limit_pin[N_AXIS], step_pin[N_AXIS];
  float max_travel = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {  
    57be:	ed 89       	ldd	r30, Y+21	; 0x15
    57c0:	fe 89       	ldd	r31, Y+22	; 0x16
    57c2:	0e 17       	cp	r16, r30
    57c4:	1f 07       	cpc	r17, r31
    57c6:	c9 f6       	brne	.-78     	; 0x577a <limits_go_home+0x8a>
    57c8:	7e 2c       	mov	r7, r14
    57ca:	ef 88       	ldd	r14, Y+23	; 0x17

    // Determine travel distance to the furthest homing switch based on user max travel settings.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (max_travel > settings.max_travel[idx]) { max_travel = settings.max_travel[idx]; }
  }
  max_travel *= -HOMING_AXIS_SEARCH_SCALAR; // Ensure homing switches engaged by over-estimating max travel.
    57cc:	20 e0       	ldi	r18, 0x00	; 0
    57ce:	30 e0       	ldi	r19, 0x00	; 0
    57d0:	40 ec       	ldi	r20, 0xC0	; 192
    57d2:	5f eb       	ldi	r21, 0xBF	; 191
    57d4:	6f 2d       	mov	r22, r15
    57d6:	79 2d       	mov	r23, r9
    57d8:	88 2d       	mov	r24, r8
    57da:	97 2d       	mov	r25, r7
    57dc:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    57e0:	6a a3       	std	Y+34, r22	; 0x22
    57e2:	7b a3       	std	Y+35, r23	; 0x23
    57e4:	8c a3       	std	Y+36, r24	; 0x24
    57e6:	9d a3       	std	Y+37, r25	; 0x25
  
  plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
    57e8:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <plan_reset>
    57ec:	f6 e0       	ldi	r31, 0x06	; 6
    57ee:	f9 a3       	std	Y+33, r31	; 0x21
void limits_go_home(uint8_t cycle_mask) 
{
  if (sys.abort) { return; } // Block if system reset has been issued.

  // Initialize homing in search mode to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    57f0:	41 e0       	ldi	r20, 0x01	; 1
    57f2:	4f 8b       	std	Y+23, r20	; 0x17
    57f4:	ce 01       	movw	r24, r28
    57f6:	01 96       	adiw	r24, 0x01	; 1
    57f8:	9e 8b       	std	Y+22, r25	; 0x16
    57fa:	8d 8b       	std	Y+21, r24	; 0x15
      } else {
        target[idx] = 0.0;
      }

      // Set target direction based on cycle mask
      if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] = -target[idx]; }
    57fc:	cd 88       	ldd	r12, Y+21	; 0x15
    57fe:	cb 8e       	std	Y+27, r12	; 0x1b
    5800:	de 88       	ldd	r13, Y+22	; 0x16
    5802:	dc 8e       	std	Y+28, r13	; 0x1c
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;
        
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    5804:	8e 2c       	mov	r8, r14
    5806:	91 2c       	mov	r9, r1
        n_active_axis++;
        if (!approach) { target[idx] = -max_travel; }
    5808:	8a a1       	ldd	r24, Y+34	; 0x22
    580a:	9b a1       	ldd	r25, Y+35	; 0x23
    580c:	ac a1       	ldd	r26, Y+36	; 0x24
    580e:	bd a1       	ldd	r27, Y+37	; 0x25
    5810:	b0 58       	subi	r27, 0x80	; 128
    5812:	8f a3       	std	Y+39, r24	; 0x27
    5814:	98 a7       	std	Y+40, r25	; 0x28
    5816:	a9 a7       	std	Y+41, r26	; 0x29
    5818:	ba a7       	std	Y+42, r27	; 0x2a
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;
        
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    581a:	ee a2       	std	Y+38, r14	; 0x26
    581c:	98 8e       	std	Y+24, r9	; 0x18
      
      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    sys.homing_axis_lock = axislock;
    581e:	0f 2e       	mov	r0, r31
    5820:	f6 e8       	ldi	r31, 0x86	; 134
    5822:	af 2e       	mov	r10, r31
    5824:	f5 e0       	ldi	r31, 0x05	; 5
    5826:	bf 2e       	mov	r11, r31
    5828:	f0 2d       	mov	r31, r0
    582a:	3e 01       	movw	r6, r28
    582c:	93 e1       	ldi	r25, 0x13	; 19
    582e:	69 0e       	add	r6, r25
    5830:	71 1c       	adc	r7, r1
    5832:	52 2c       	mov	r5, r2
    5834:	43 2c       	mov	r4, r3
    5836:	3b 88       	ldd	r3, Y+19	; 0x13
    5838:	2c 88       	ldd	r2, Y+20	; 0x14
    583a:	9a 8e       	std	Y+26, r9	; 0x1a
    583c:	89 8e       	std	Y+25, r8	; 0x19
  
  plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
  
  do {
    // Initialize invert_pin boolean based on approach and invert pin user setting.
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    583e:	80 91 7d 07 	lds	r24, 0x077D
    5842:	86 fd       	sbrc	r24, 6
    5844:	02 c0       	rjmp	.+4      	; 0x584a <limits_go_home+0x15a>
    5846:	0f 89       	ldd	r16, Y+23	; 0x17
    5848:	03 c0       	rjmp	.+6      	; 0x5850 <limits_go_home+0x160>
    else { invert_pin = !approach; }
    584a:	01 e0       	ldi	r16, 0x01	; 1
    584c:	cf 88       	ldd	r12, Y+23	; 0x17
    584e:	0c 25       	eor	r16, r12
      } else {
        target[idx] = 0.0;
      }

      // Set target direction based on cycle mask
      if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] = -target[idx]; }
    5850:	80 90 7e 07 	lds	r8, 0x077E
    5854:	91 2c       	mov	r9, r1
    5856:	dd 88       	ldd	r13, Y+21	; 0x15
    5858:	dd a6       	std	Y+45, r13	; 0x2d
    585a:	ee 88       	ldd	r14, Y+22	; 0x16
    585c:	ee a6       	std	Y+46, r14	; 0x2e
    585e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    5860:	fc 8d       	ldd	r31, Y+28	; 0x1c
    5862:	80 e0       	ldi	r24, 0x00	; 0
    5864:	90 e0       	ldi	r25, 0x00	; 0
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    else { invert_pin = !approach; }

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;
    5866:	10 e0       	ldi	r17, 0x00	; 0
    // Initialize invert_pin boolean based on approach and invert pin user setting.
    if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { invert_pin = approach; }
    else { invert_pin = !approach; }

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    5868:	60 e0       	ldi	r22, 0x00	; 0
    586a:	7e a1       	ldd	r23, Y+38	; 0x26
    uint8_t axislock = 0;
        
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) { 
    586c:	27 2f       	mov	r18, r23
    586e:	38 8d       	ldd	r19, Y+24	; 0x18
    5870:	8b a7       	std	Y+43, r24	; 0x2b
    5872:	49 8d       	ldd	r20, Y+25	; 0x19
    5874:	5a 8d       	ldd	r21, Y+26	; 0x1a
    5876:	08 2e       	mov	r0, r24
    5878:	02 c0       	rjmp	.+4      	; 0x587e <limits_go_home+0x18e>
    587a:	55 95       	asr	r21
    587c:	47 95       	ror	r20
    587e:	0a 94       	dec	r0
    5880:	e2 f7       	brpl	.-8      	; 0x587a <limits_go_home+0x18a>
    5882:	da 01       	movw	r26, r20
    5884:	a1 70       	andi	r26, 0x01	; 1
    5886:	bb 27       	eor	r27, r27
    5888:	40 ff       	sbrs	r20, 0
    588a:	16 c0       	rjmp	.+44     	; 0x58b8 <limits_go_home+0x1c8>
        n_active_axis++;
    588c:	6f 5f       	subi	r22, 0xFF	; 255
        if (!approach) { target[idx] = -max_travel; }
    588e:	ff 88       	ldd	r15, Y+23	; 0x17
    5890:	f1 10       	cpse	r15, r1
    5892:	09 c0       	rjmp	.+18     	; 0x58a6 <limits_go_home+0x1b6>
    5894:	cf a0       	ldd	r12, Y+39	; 0x27
    5896:	d8 a4       	ldd	r13, Y+40	; 0x28
    5898:	e9 a4       	ldd	r14, Y+41	; 0x29
    589a:	fa a4       	ldd	r15, Y+42	; 0x2a
    589c:	c0 82       	st	Z, r12
    589e:	d1 82       	std	Z+1, r13	; 0x01
    58a0:	e2 82       	std	Z+2, r14	; 0x02
    58a2:	f3 82       	std	Z+3, r15	; 0x03
    58a4:	0d c0       	rjmp	.+26     	; 0x58c0 <limits_go_home+0x1d0>
        else { target[idx] = max_travel; }
    58a6:	ca a0       	ldd	r12, Y+34	; 0x22
    58a8:	db a0       	ldd	r13, Y+35	; 0x23
    58aa:	ec a0       	ldd	r14, Y+36	; 0x24
    58ac:	fd a0       	ldd	r15, Y+37	; 0x25
    58ae:	c0 82       	st	Z, r12
    58b0:	d1 82       	std	Z+1, r13	; 0x01
    58b2:	e2 82       	std	Z+2, r14	; 0x02
    58b4:	f3 82       	std	Z+3, r15	; 0x03
    58b6:	04 c0       	rjmp	.+8      	; 0x58c0 <limits_go_home+0x1d0>
      } else {
        target[idx] = 0.0;
    58b8:	10 82       	st	Z, r1
    58ba:	11 82       	std	Z+1, r1	; 0x01
    58bc:	12 82       	std	Z+2, r1	; 0x02
    58be:	13 82       	std	Z+3, r1	; 0x03
      }

      // Set target direction based on cycle mask
      if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] = -target[idx]; }
    58c0:	a4 01       	movw	r20, r8
    58c2:	0b a4       	ldd	r0, Y+43	; 0x2b
    58c4:	02 c0       	rjmp	.+4      	; 0x58ca <limits_go_home+0x1da>
    58c6:	55 95       	asr	r21
    58c8:	47 95       	ror	r20
    58ca:	0a 94       	dec	r0
    58cc:	e2 f7       	brpl	.-8      	; 0x58c6 <limits_go_home+0x1d6>
    58ce:	40 ff       	sbrs	r20, 0
    58d0:	0c c0       	rjmp	.+24     	; 0x58ea <limits_go_home+0x1fa>
    58d2:	c0 80       	ld	r12, Z
    58d4:	d1 80       	ldd	r13, Z+1	; 0x01
    58d6:	e2 80       	ldd	r14, Z+2	; 0x02
    58d8:	f3 80       	ldd	r15, Z+3	; 0x03
    58da:	f7 fa       	bst	r15, 7
    58dc:	f0 94       	com	r15
    58de:	f7 f8       	bld	r15, 7
    58e0:	f0 94       	com	r15
    58e2:	c0 82       	st	Z, r12
    58e4:	d1 82       	std	Z+1, r13	; 0x01
    58e6:	e2 82       	std	Z+2, r14	; 0x02
    58e8:	f3 82       	std	Z+3, r15	; 0x03
      
      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    58ea:	ab 2b       	or	r26, r27
    58ec:	41 f0       	breq	.+16     	; 0x58fe <limits_go_home+0x20e>
    58ee:	a0 e1       	ldi	r26, 0x10	; 16
    58f0:	b0 e0       	ldi	r27, 0x00	; 0
    58f2:	ac 0f       	add	r26, r28
    58f4:	bd 1f       	adc	r27, r29
    58f6:	a8 0f       	add	r26, r24
    58f8:	b9 1f       	adc	r27, r25
    58fa:	4c 91       	ld	r20, X
    58fc:	14 2b       	or	r17, r20
    58fe:	01 96       	adiw	r24, 0x01	; 1
    5900:	34 96       	adiw	r30, 0x04	; 4

    // Initialize and declare variables needed for homing routine.
    uint8_t n_active_axis = 0;
    uint8_t axislock = 0;
        
    for (idx=0; idx<N_AXIS; idx++) {
    5902:	83 30       	cpi	r24, 0x03	; 3
    5904:	91 05       	cpc	r25, r1
    5906:	09 f0       	breq	.+2      	; 0x590a <limits_go_home+0x21a>
    5908:	b1 cf       	rjmp	.-158    	; 0x586c <limits_go_home+0x17c>
    590a:	3c a7       	std	Y+44, r19	; 0x2c
    590c:	2b a7       	std	Y+43, r18	; 0x2b
      if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] = -target[idx]; }
      
      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    590e:	70 e0       	ldi	r23, 0x00	; 0
    5910:	80 e0       	ldi	r24, 0x00	; 0
    5912:	90 e0       	ldi	r25, 0x00	; 0
    5914:	0e 94 fc 39 	call	0x73f8	; 0x73f8 <__floatunsisf>
    5918:	0e 94 27 3c 	call	0x784e	; 0x784e <sqrt>
    sys.homing_axis_lock = axislock;
    591c:	d5 01       	movw	r26, r10
    591e:	1c 93       	st	X, r17
      if (bit_istrue(settings.homing_dir_mask,bit(idx))) { target[idx] = -target[idx]; }
      
      // Apply axislock to the step port pins active in this cycle.
      if (bit_istrue(cycle_mask,bit(idx))) { axislock |= step_pin[idx]; }
    }      
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    5920:	2d 8d       	ldd	r18, Y+29	; 0x1d
    5922:	3e 8d       	ldd	r19, Y+30	; 0x1e
    5924:	4f 8d       	ldd	r20, Y+31	; 0x1f
    5926:	58 a1       	ldd	r21, Y+32	; 0x20
    5928:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    592c:	ab 01       	movw	r20, r22
    592e:	bc 01       	movw	r22, r24
    uint8_t limit_state;
    
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, homing_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan homing motion.
    #else
      plan_buffer_line(target, homing_rate, false); // Bypass mc_line(). Directly plan homing motion.
    5930:	20 e0       	ldi	r18, 0x00	; 0
    5932:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5934:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5936:	0e 94 f4 26 	call	0x4de8	; 0x4de8 <plan_buffer_line>
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    593a:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <st_prep_buffer>
    st_wake_up(); // Initiate motion
    593e:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <st_wake_up>
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
    5942:	0f 2e       	mov	r0, r31
    5944:	fe e0       	ldi	r31, 0x0E	; 14
    5946:	df 2e       	mov	r13, r31
    5948:	f0 2d       	mov	r31, r0
        }
      }
      sys.homing_axis_lock = axislock;
      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
      // Check only for user reset. No time to run protocol_execute_runtime() in this loop.
      if (sys.execute & EXEC_RESET) { protocol_execute_runtime(); return; }
    594a:	0f 2e       	mov	r0, r31
    594c:	f5 e8       	ldi	r31, 0x85	; 133
    594e:	ef 2e       	mov	r14, r31
    5950:	f5 e0       	ldi	r31, 0x05	; 5
    5952:	ff 2e       	mov	r15, r31
    5954:	f0 2d       	mov	r31, r0
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    st_wake_up(); // Initiate motion
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
    5956:	23 b1       	in	r18, 0x03	; 3
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
    5958:	01 11       	cpse	r16, r1
    595a:	2d 25       	eor	r18, r13
    595c:	a5 2d       	mov	r26, r5
    595e:	b4 2d       	mov	r27, r4
    5960:	e3 2d       	mov	r30, r3
    5962:	f2 2d       	mov	r31, r2
      for (idx=0; idx<N_AXIS; idx++) {
        if (axislock & step_pin[idx]) {
    5964:	81 91       	ld	r24, Z+
    5966:	98 2f       	mov	r25, r24
    5968:	91 23       	and	r25, r17
    596a:	29 f0       	breq	.+10     	; 0x5976 <limits_go_home+0x286>
          if (limit_state & limit_pin[idx]) { axislock &= ~(step_pin[idx]); }
    596c:	9c 91       	ld	r25, X
    596e:	92 23       	and	r25, r18
    5970:	11 f0       	breq	.+4      	; 0x5976 <limits_go_home+0x286>
    5972:	80 95       	com	r24
    5974:	18 23       	and	r17, r24
    5976:	11 96       	adiw	r26, 0x01	; 1
    st_wake_up(); // Initiate motion
    do {
      // Check limit state. Lock out cycle axes when they change.
      limit_state = LIMIT_PIN;
      if (invert_pin) { limit_state ^= LIMIT_MASK; }
      for (idx=0; idx<N_AXIS; idx++) {
    5978:	e6 15       	cp	r30, r6
    597a:	f7 05       	cpc	r31, r7
    597c:	99 f7       	brne	.-26     	; 0x5964 <limits_go_home+0x274>
        if (axislock & step_pin[idx]) {
          if (limit_state & limit_pin[idx]) { axislock &= ~(step_pin[idx]); }
        }
      }
      sys.homing_axis_lock = axislock;
    597e:	f5 01       	movw	r30, r10
    5980:	10 83       	st	Z, r17
      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    5982:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <st_prep_buffer>
      // Check only for user reset. No time to run protocol_execute_runtime() in this loop.
      if (sys.execute & EXEC_RESET) { protocol_execute_runtime(); return; }
    5986:	d7 01       	movw	r26, r14
    5988:	8c 91       	ld	r24, X
    598a:	84 ff       	sbrs	r24, 4
    598c:	03 c0       	rjmp	.+6      	; 0x5994 <limits_go_home+0x2a4>
    598e:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
    5992:	cb c0       	rjmp	.+406    	; 0x5b2a <limits_go_home+0x43a>
    } while (STEP_MASK & axislock);
    5994:	81 2f       	mov	r24, r17
    5996:	8c 71       	andi	r24, 0x1C	; 28
    5998:	f1 f6       	brne	.-68     	; 0x5956 <limits_go_home+0x266>
    
    st_reset(); // Immediately force kill steppers and reset step segment buffer.
    599a:	0e 94 32 1a 	call	0x3464	; 0x3464 <st_reset>
    plan_reset(); // Reset planner buffer. Zero planner positions. Ensure homing motion is cleared.
    599e:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <plan_reset>

    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    59a2:	80 91 87 07 	lds	r24, 0x0787
    59a6:	90 91 88 07 	lds	r25, 0x0788
    59aa:	0e 94 e6 2a 	call	0x55cc	; 0x55cc <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    homing_rate = settings.homing_feed_rate;
    59ae:	c0 90 7f 07 	lds	r12, 0x077F
    59b2:	d0 90 80 07 	lds	r13, 0x0780
    59b6:	e0 90 81 07 	lds	r14, 0x0781
    59ba:	f0 90 82 07 	lds	r15, 0x0782
    59be:	cd 8e       	std	Y+29, r12	; 0x1d
    59c0:	de 8e       	std	Y+30, r13	; 0x1e
    59c2:	ef 8e       	std	Y+31, r14	; 0x1f
    59c4:	f8 a2       	std	Y+32, r15	; 0x20
    approach = !approach;
    59c6:	81 e0       	ldi	r24, 0x01	; 1
    59c8:	df 88       	ldd	r13, Y+23	; 0x17
    59ca:	d8 26       	eor	r13, r24
    59cc:	df 8a       	std	Y+23, r13	; 0x17
    59ce:	49 a1       	ldd	r20, Y+33	; 0x21
    59d0:	41 50       	subi	r20, 0x01	; 1
    59d2:	49 a3       	std	Y+33, r20	; 0x21
    
  } while (n_cycle-- > 0);
    59d4:	41 11       	cpse	r20, r1
    59d6:	33 cf       	rjmp	.-410    	; 0x583e <limits_go_home+0x14e>
      #ifdef HOMING_FORCE_SET_ORIGIN
        sys.position[idx] = 0;  // Set axis homed location as axis origin
        target[idx] = settings.homing_pulloff;  
        if ( bit_isfalse(settings.homing_dir_mask,bit(idx)) ) { target[idx] = -target[idx]; }     
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    59d8:	80 90 7e 07 	lds	r8, 0x077E
    59dc:	91 2c       	mov	r9, r1
          target[idx] = settings.max_travel[idx];
          sys.position[idx] = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    59de:	40 90 89 07 	lds	r4, 0x0789
    59e2:	50 90 8a 07 	lds	r5, 0x078A
    59e6:	60 90 8b 07 	lds	r6, 0x078B
    59ea:	70 90 8c 07 	lds	r7, 0x078C
    59ee:	0f 2e       	mov	r0, r31
    59f0:	f0 e4       	ldi	r31, 0x40	; 64
    59f2:	cf 2e       	mov	r12, r31
    59f4:	f7 e0       	ldi	r31, 0x07	; 7
    59f6:	df 2e       	mov	r13, r31
    59f8:	f0 2d       	mov	r31, r0
    59fa:	0f 2e       	mov	r0, r31
    59fc:	f7 e8       	ldi	r31, 0x87	; 135
    59fe:	af 2e       	mov	r10, r31
    5a00:	f5 e0       	ldi	r31, 0x05	; 5
    5a02:	bf 2e       	mov	r11, r31
    5a04:	f0 2d       	mov	r31, r0
    5a06:	ed a4       	ldd	r14, Y+45	; 0x2d
    5a08:	fe a4       	ldd	r15, Y+46	; 0x2e
    5a0a:	00 e0       	ldi	r16, 0x00	; 0
    5a0c:	10 e0       	ldi	r17, 0x00	; 0
    5a0e:	2b a4       	ldd	r2, Y+43	; 0x2b
    5a10:	3c a4       	ldd	r3, Y+44	; 0x2c
  for (idx=0; idx<N_AXIS; idx++) {
    // Set up pull off targets and machine positions for limit switches homed in the negative
    // direction, rather than the traditional positive. Leave non-homed positions as zero and
    // do not move them.
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    5a12:	c1 01       	movw	r24, r2
    5a14:	00 2e       	mov	r0, r16
    5a16:	02 c0       	rjmp	.+4      	; 0x5a1c <limits_go_home+0x32c>
    5a18:	95 95       	asr	r25
    5a1a:	87 95       	ror	r24
    5a1c:	0a 94       	dec	r0
    5a1e:	e2 f7       	brpl	.-8      	; 0x5a18 <limits_go_home+0x328>
    5a20:	80 ff       	sbrs	r24, 0
    5a22:	40 c0       	rjmp	.+128    	; 0x5aa4 <limits_go_home+0x3b4>
      #ifdef HOMING_FORCE_SET_ORIGIN
        sys.position[idx] = 0;  // Set axis homed location as axis origin
        target[idx] = settings.homing_pulloff;  
        if ( bit_isfalse(settings.homing_dir_mask,bit(idx)) ) { target[idx] = -target[idx]; }     
      #else
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    5a24:	c4 01       	movw	r24, r8
    5a26:	00 2e       	mov	r0, r16
    5a28:	02 c0       	rjmp	.+4      	; 0x5a2e <limits_go_home+0x33e>
    5a2a:	95 95       	asr	r25
    5a2c:	87 95       	ror	r24
    5a2e:	0a 94       	dec	r0
    5a30:	e2 f7       	brpl	.-8      	; 0x5a2a <limits_go_home+0x33a>
    5a32:	80 ff       	sbrs	r24, 0
    5a34:	1f c0       	rjmp	.+62     	; 0x5a74 <limits_go_home+0x384>
          target[idx] = settings.max_travel[idx];
    5a36:	d6 01       	movw	r26, r12
    5a38:	94 96       	adiw	r26, 0x24	; 36
    5a3a:	6d 91       	ld	r22, X+
    5a3c:	7d 91       	ld	r23, X+
    5a3e:	8d 91       	ld	r24, X+
    5a40:	9c 91       	ld	r25, X
    5a42:	97 97       	sbiw	r26, 0x27	; 39
    5a44:	f7 01       	movw	r30, r14
    5a46:	60 83       	st	Z, r22
    5a48:	71 83       	std	Z+1, r23	; 0x01
    5a4a:	82 83       	std	Z+2, r24	; 0x02
    5a4c:	93 83       	std	Z+3, r25	; 0x03
          sys.position[idx] = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    5a4e:	a3 01       	movw	r20, r6
    5a50:	92 01       	movw	r18, r4
    5a52:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    5a56:	d6 01       	movw	r26, r12
    5a58:	2d 91       	ld	r18, X+
    5a5a:	3d 91       	ld	r19, X+
    5a5c:	4d 91       	ld	r20, X+
    5a5e:	5c 91       	ld	r21, X
    5a60:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5a64:	0e 94 6a 3b 	call	0x76d4	; 0x76d4 <lround>
    5a68:	f5 01       	movw	r30, r10
    5a6a:	60 83       	st	Z, r22
    5a6c:	71 83       	std	Z+1, r23	; 0x01
    5a6e:	82 83       	std	Z+2, r24	; 0x02
    5a70:	93 83       	std	Z+3, r25	; 0x03
    5a72:	2b c0       	rjmp	.+86     	; 0x5aca <limits_go_home+0x3da>
        } else {
          target[idx] = 0;
    5a74:	d7 01       	movw	r26, r14
    5a76:	1d 92       	st	X+, r1
    5a78:	1d 92       	st	X+, r1
    5a7a:	1d 92       	st	X+, r1
    5a7c:	1c 92       	st	X, r1
    5a7e:	13 97       	sbiw	r26, 0x03	; 3
          sys.position[idx] = settings.homing_pulloff*settings.steps_per_mm[idx];
    5a80:	f6 01       	movw	r30, r12
    5a82:	20 81       	ld	r18, Z
    5a84:	31 81       	ldd	r19, Z+1	; 0x01
    5a86:	42 81       	ldd	r20, Z+2	; 0x02
    5a88:	53 81       	ldd	r21, Z+3	; 0x03
    5a8a:	c3 01       	movw	r24, r6
    5a8c:	b2 01       	movw	r22, r4
    5a8e:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5a92:	0e 94 cb 39 	call	0x7396	; 0x7396 <__fixsfsi>
    5a96:	d5 01       	movw	r26, r10
    5a98:	6d 93       	st	X+, r22
    5a9a:	7d 93       	st	X+, r23
    5a9c:	8d 93       	st	X+, r24
    5a9e:	9c 93       	st	X, r25
    5aa0:	13 97       	sbiw	r26, 0x03	; 3
    5aa2:	13 c0       	rjmp	.+38     	; 0x5aca <limits_go_home+0x3da>
        }
      #endif
      
    } else { // Non-active cycle axis. Set target to not move during pull-off. 
      target[idx] = (float)sys.position[idx]/settings.steps_per_mm[idx];
    5aa4:	f5 01       	movw	r30, r10
    5aa6:	60 81       	ld	r22, Z
    5aa8:	71 81       	ldd	r23, Z+1	; 0x01
    5aaa:	82 81       	ldd	r24, Z+2	; 0x02
    5aac:	93 81       	ldd	r25, Z+3	; 0x03
    5aae:	0e 94 fe 39 	call	0x73fc	; 0x73fc <__floatsisf>
    5ab2:	d6 01       	movw	r26, r12
    5ab4:	2d 91       	ld	r18, X+
    5ab6:	3d 91       	ld	r19, X+
    5ab8:	4d 91       	ld	r20, X+
    5aba:	5c 91       	ld	r21, X
    5abc:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    5ac0:	f7 01       	movw	r30, r14
    5ac2:	60 83       	st	Z, r22
    5ac4:	71 83       	std	Z+1, r23	; 0x01
    5ac6:	82 83       	std	Z+2, r24	; 0x02
    5ac8:	93 83       	std	Z+3, r25	; 0x03
    5aca:	0f 5f       	subi	r16, 0xFF	; 255
    5acc:	1f 4f       	sbci	r17, 0xFF	; 255
    5ace:	f4 e0       	ldi	r31, 0x04	; 4
    5ad0:	ef 0e       	add	r14, r31
    5ad2:	f1 1c       	adc	r15, r1
    5ad4:	44 e0       	ldi	r20, 0x04	; 4
    5ad6:	c4 0e       	add	r12, r20
    5ad8:	d1 1c       	adc	r13, r1
    5ada:	84 e0       	ldi	r24, 0x04	; 4
    5adc:	a8 0e       	add	r10, r24
    5ade:	b1 1c       	adc	r11, r1
  // default, grbl defines machine space as all negative, as do most CNCs. Since limit switches
  // can be on either side of an axes, check and set axes machine zero appropriately. Also,
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  for (idx=0; idx<N_AXIS; idx++) {
    5ae0:	03 30       	cpi	r16, 0x03	; 3
    5ae2:	11 05       	cpc	r17, r1
    5ae4:	09 f0       	breq	.+2      	; 0x5ae8 <limits_go_home+0x3f8>
    5ae6:	95 cf       	rjmp	.-214    	; 0x5a12 <limits_go_home+0x322>
      
    } else { // Non-active cycle axis. Set target to not move during pull-off. 
      target[idx] = (float)sys.position[idx]/settings.steps_per_mm[idx];
    }
  }
  plan_sync_position(); // Sync planner position to current machine position for pull-off move.
    5ae8:	0e 94 d5 29 	call	0x53aa	; 0x53aa <plan_sync_position>
  
  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, settings.homing_seek_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan motion.
  #else
    plan_buffer_line(target, settings.homing_seek_rate, false); // Bypass mc_line(). Directly plan motion.
    5aec:	40 91 83 07 	lds	r20, 0x0783
    5af0:	50 91 84 07 	lds	r21, 0x0784
    5af4:	60 91 85 07 	lds	r22, 0x0785
    5af8:	70 91 86 07 	lds	r23, 0x0786
    5afc:	20 e0       	ldi	r18, 0x00	; 0
    5afe:	ce 01       	movw	r24, r28
    5b00:	01 96       	adiw	r24, 0x01	; 1
    5b02:	0e 94 f4 26 	call	0x4de8	; 0x4de8 <plan_buffer_line>
  #endif
  
  // Initiate pull-off using main motion control routines. 
  // TODO : Clean up state routines so that this motion still shows homing state.
  sys.state = STATE_QUEUED;
    5b06:	88 e0       	ldi	r24, 0x08	; 8
    5b08:	80 93 84 05 	sts	0x0584, r24
  bit_true_atomic(sys.execute, EXEC_CYCLE_START);
    5b0c:	8f b7       	in	r24, 0x3f	; 63
    5b0e:	f8 94       	cli
    5b10:	e5 e8       	ldi	r30, 0x85	; 133
    5b12:	f5 e0       	ldi	r31, 0x05	; 5
    5b14:	90 81       	ld	r25, Z
    5b16:	92 60       	ori	r25, 0x02	; 2
    5b18:	90 83       	st	Z, r25
    5b1a:	8f bf       	out	0x3f, r24	; 63
  protocol_execute_runtime();
    5b1c:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
  protocol_buffer_synchronize(); // Complete pull-off motion.
    5b20:	0e 94 91 17 	call	0x2f22	; 0x2f22 <protocol_buffer_synchronize>
  
  // Set system state to homing before returning. 
  sys.state = STATE_HOMING; 
    5b24:	84 e0       	ldi	r24, 0x04	; 4
    5b26:	80 93 84 05 	sts	0x0584, r24
}
    5b2a:	ae 96       	adiw	r28, 0x2e	; 46
    5b2c:	0f b6       	in	r0, 0x3f	; 63
    5b2e:	f8 94       	cli
    5b30:	de bf       	out	0x3e, r29	; 62
    5b32:	0f be       	out	0x3f, r0	; 63
    5b34:	cd bf       	out	0x3d, r28	; 61
    5b36:	df 91       	pop	r29
    5b38:	cf 91       	pop	r28
    5b3a:	1f 91       	pop	r17
    5b3c:	0f 91       	pop	r16
    5b3e:	ff 90       	pop	r15
    5b40:	ef 90       	pop	r14
    5b42:	df 90       	pop	r13
    5b44:	cf 90       	pop	r12
    5b46:	bf 90       	pop	r11
    5b48:	af 90       	pop	r10
    5b4a:	9f 90       	pop	r9
    5b4c:	8f 90       	pop	r8
    5b4e:	7f 90       	pop	r7
    5b50:	6f 90       	pop	r6
    5b52:	5f 90       	pop	r5
    5b54:	4f 90       	pop	r4
    5b56:	3f 90       	pop	r3
    5b58:	2f 90       	pop	r2
    5b5a:	08 95       	ret

00005b5c <limits_soft_check>:


// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
    5b5c:	af 92       	push	r10
    5b5e:	bf 92       	push	r11
    5b60:	cf 92       	push	r12
    5b62:	df 92       	push	r13
    5b64:	ef 92       	push	r14
    5b66:	ff 92       	push	r15
    5b68:	0f 93       	push	r16
    5b6a:	1f 93       	push	r17
    5b6c:	cf 93       	push	r28
    5b6e:	df 93       	push	r29
    5b70:	ec 01       	movw	r28, r24
    5b72:	04 e6       	ldi	r16, 0x64	; 100
    5b74:	17 e0       	ldi	r17, 0x07	; 7
    5b76:	0f 2e       	mov	r0, r31
    5b78:	f0 e7       	ldi	r31, 0x70	; 112
    5b7a:	af 2e       	mov	r10, r31
    5b7c:	f7 e0       	ldi	r31, 0x07	; 7
    5b7e:	bf 2e       	mov	r11, r31
    5b80:	f0 2d       	mov	r31, r0
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { soft_limit_error = true; }
        if ( target[idx] < ( settings.max_travel[idx] + gc_state.tool_table[ gc_block.modal.tool].xyz[idx])) { soft_limit_error = true; }
      }
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { soft_limit_error = true; }
    5b82:	c9 90       	ld	r12, Y+
    5b84:	d9 90       	ld	r13, Y+
    5b86:	e9 90       	ld	r14, Y+
    5b88:	f9 90       	ld	r15, Y+
    5b8a:	20 e0       	ldi	r18, 0x00	; 0
    5b8c:	30 e0       	ldi	r19, 0x00	; 0
    5b8e:	a9 01       	movw	r20, r18
    5b90:	c7 01       	movw	r24, r14
    5b92:	b6 01       	movw	r22, r12
    5b94:	0e 94 5f 3b 	call	0x76be	; 0x76be <__gesf2>
    5b98:	18 16       	cp	r1, r24
    5b9a:	64 f0       	brlt	.+24     	; 0x5bb4 <limits_soft_check+0x58>
    5b9c:	f8 01       	movw	r30, r16
    5b9e:	21 91       	ld	r18, Z+
    5ba0:	31 91       	ld	r19, Z+
    5ba2:	41 91       	ld	r20, Z+
    5ba4:	51 91       	ld	r21, Z+
    5ba6:	8f 01       	movw	r16, r30
    5ba8:	c7 01       	movw	r24, r14
    5baa:	b6 01       	movw	r22, r12
    5bac:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    5bb0:	88 23       	and	r24, r24
    5bb2:	0c f5       	brge	.+66     	; 0x5bf6 <limits_soft_check+0x9a>
    
    if (soft_limit_error) {
      // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within 
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
    5bb4:	80 91 84 05 	lds	r24, 0x0584
    5bb8:	80 31       	cpi	r24, 0x10	; 16
    5bba:	81 f4       	brne	.+32     	; 0x5bdc <limits_soft_check+0x80>
        bit_true_atomic(sys.execute, EXEC_FEED_HOLD);
    5bbc:	8f b7       	in	r24, 0x3f	; 63
    5bbe:	f8 94       	cli
    5bc0:	e5 e8       	ldi	r30, 0x85	; 133
    5bc2:	f5 e0       	ldi	r31, 0x05	; 5
    5bc4:	90 81       	ld	r25, Z
    5bc6:	98 60       	ori	r25, 0x08	; 8
    5bc8:	90 83       	st	Z, r25
    5bca:	8f bf       	out	0x3f, r24	; 63
        do {
          protocol_execute_runtime();
          if (sys.abort) { return; }
    5bcc:	c3 e8       	ldi	r28, 0x83	; 131
    5bce:	d5 e0       	ldi	r29, 0x05	; 5
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
        bit_true_atomic(sys.execute, EXEC_FEED_HOLD);
        do {
          protocol_execute_runtime();
    5bd0:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
          if (sys.abort) { return; }
    5bd4:	88 81       	ld	r24, Y
    5bd6:	88 23       	and	r24, r24
    5bd8:	d9 f3       	breq	.-10     	; 0x5bd0 <limits_soft_check+0x74>
    5bda:	11 c0       	rjmp	.+34     	; 0x5bfe <limits_soft_check+0xa2>
        } while ( sys.state != STATE_IDLE || sys.state != STATE_QUEUED);
      }
    
      mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    5bdc:	0e 94 d6 09 	call	0x13ac	; 0x13ac <mc_reset>
      bit_true_atomic(sys.execute, (EXEC_ALARM | EXEC_CRIT_EVENT)); // Indicate soft limit critical event
    5be0:	8f b7       	in	r24, 0x3f	; 63
    5be2:	f8 94       	cli
    5be4:	e5 e8       	ldi	r30, 0x85	; 133
    5be6:	f5 e0       	ldi	r31, 0x05	; 5
    5be8:	90 81       	ld	r25, Z
    5bea:	90 66       	ori	r25, 0x60	; 96
    5bec:	90 83       	st	Z, r25
    5bee:	8f bf       	out	0x3f, r24	; 63
      protocol_execute_runtime(); // Execute to enter critical event loop and system abort
    5bf0:	0e 94 4e 16 	call	0x2c9c	; 0x2c9c <protocol_execute_runtime>
      return;
    5bf4:	04 c0       	rjmp	.+8      	; 0x5bfe <limits_soft_check+0xa2>
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
  uint8_t idx;
  uint8_t soft_limit_error = false;
  for (idx=0; idx<N_AXIS; idx++) {
    5bf6:	0a 15       	cp	r16, r10
    5bf8:	1b 05       	cpc	r17, r11
    5bfa:	09 f0       	breq	.+2      	; 0x5bfe <limits_soft_check+0xa2>
    5bfc:	c2 cf       	rjmp	.-124    	; 0x5b82 <limits_soft_check+0x26>
      bit_true_atomic(sys.execute, (EXEC_ALARM | EXEC_CRIT_EVENT)); // Indicate soft limit critical event
      protocol_execute_runtime(); // Execute to enter critical event loop and system abort
      return;
    }
  }
}
    5bfe:	df 91       	pop	r29
    5c00:	cf 91       	pop	r28
    5c02:	1f 91       	pop	r17
    5c04:	0f 91       	pop	r16
    5c06:	ff 90       	pop	r15
    5c08:	ef 90       	pop	r14
    5c0a:	df 90       	pop	r13
    5c0c:	cf 90       	pop	r12
    5c0e:	bf 90       	pop	r11
    5c10:	af 90       	pop	r10
    5c12:	08 95       	ret

00005c14 <printString>:
#include "serial.h"
#include "settings.h"


void printString(const char *s)
{
    5c14:	cf 93       	push	r28
    5c16:	df 93       	push	r29
    5c18:	ec 01       	movw	r28, r24
  while (*s)
    5c1a:	88 81       	ld	r24, Y
    5c1c:	88 23       	and	r24, r24
    5c1e:	31 f0       	breq	.+12     	; 0x5c2c <printString+0x18>
    5c20:	21 96       	adiw	r28, 0x01	; 1
    serial_write(*s++);
    5c22:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <serial_write>
#include "settings.h"


void printString(const char *s)
{
  while (*s)
    5c26:	89 91       	ld	r24, Y+
    5c28:	81 11       	cpse	r24, r1
    5c2a:	fb cf       	rjmp	.-10     	; 0x5c22 <printString+0xe>
    serial_write(*s++);
}
    5c2c:	df 91       	pop	r29
    5c2e:	cf 91       	pop	r28
    5c30:	08 95       	ret

00005c32 <printPgmString>:


// Print a string stored in PGM-memory
void printPgmString(const char *s)
{
    5c32:	cf 93       	push	r28
    5c34:	df 93       	push	r29
  char c;
  while ((c = pgm_read_byte_near(s++)))
    5c36:	ec 01       	movw	r28, r24
    5c38:	21 96       	adiw	r28, 0x01	; 1
    5c3a:	fc 01       	movw	r30, r24
    5c3c:	84 91       	lpm	r24, Z
    5c3e:	88 23       	and	r24, r24
    5c40:	39 f0       	breq	.+14     	; 0x5c50 <printPgmString+0x1e>
    serial_write(c);
    5c42:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <serial_write>

// Print a string stored in PGM-memory
void printPgmString(const char *s)
{
  char c;
  while ((c = pgm_read_byte_near(s++)))
    5c46:	fe 01       	movw	r30, r28
    5c48:	84 91       	lpm	r24, Z
    5c4a:	21 96       	adiw	r28, 0x01	; 1
    5c4c:	81 11       	cpse	r24, r1
    5c4e:	f9 cf       	rjmp	.-14     	; 0x5c42 <printPgmString+0x10>
    serial_write(c);
}
    5c50:	df 91       	pop	r29
    5c52:	cf 91       	pop	r28
    5c54:	08 95       	ret

00005c56 <print_uint8_base2>:
// 			'A' + buf[i - 1] - 10);
// }


void print_uint8_base2(uint8_t n)
{ 
    5c56:	ef 92       	push	r14
    5c58:	ff 92       	push	r15
    5c5a:	0f 93       	push	r16
    5c5c:	1f 93       	push	r17
    5c5e:	cf 93       	push	r28
    5c60:	df 93       	push	r29
    5c62:	cd b7       	in	r28, 0x3d	; 61
    5c64:	de b7       	in	r29, 0x3e	; 62
    5c66:	28 97       	sbiw	r28, 0x08	; 8
    5c68:	0f b6       	in	r0, 0x3f	; 63
    5c6a:	f8 94       	cli
    5c6c:	de bf       	out	0x3e, r29	; 62
    5c6e:	0f be       	out	0x3f, r0	; 63
    5c70:	cd bf       	out	0x3d, r28	; 61
    5c72:	fe 01       	movw	r30, r28
    5c74:	31 96       	adiw	r30, 0x01	; 1
    5c76:	7f 01       	movw	r14, r30
    5c78:	9e 01       	movw	r18, r28
    5c7a:	27 5f       	subi	r18, 0xF7	; 247
    5c7c:	3f 4f       	sbci	r19, 0xFF	; 255
	unsigned char buf[8];
	uint8_t i = 0;

	for (; i < 8; i++) {
		buf[i] = n & 1;
    5c7e:	98 2f       	mov	r25, r24
    5c80:	91 70       	andi	r25, 0x01	; 1
    5c82:	91 93       	st	Z+, r25
		n >>= 1;
    5c84:	86 95       	lsr	r24
void print_uint8_base2(uint8_t n)
{ 
	unsigned char buf[8];
	uint8_t i = 0;

	for (; i < 8; i++) {
    5c86:	e2 17       	cp	r30, r18
    5c88:	f3 07       	cpc	r31, r19
    5c8a:	c9 f7       	brne	.-14     	; 0x5c7e <print_uint8_base2+0x28>
    5c8c:	8e 01       	movw	r16, r28
    5c8e:	07 5f       	subi	r16, 0xF7	; 247
    5c90:	1f 4f       	sbci	r17, 0xFF	; 255
		buf[i] = n & 1;
		n >>= 1;
	}

	for (; i > 0; i--)
		serial_write('0' + buf[i - 1]);
    5c92:	f8 01       	movw	r30, r16
    5c94:	82 91       	ld	r24, -Z
    5c96:	8f 01       	movw	r16, r30
    5c98:	80 5d       	subi	r24, 0xD0	; 208
    5c9a:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <serial_write>
	for (; i < 8; i++) {
		buf[i] = n & 1;
		n >>= 1;
	}

	for (; i > 0; i--)
    5c9e:	0e 15       	cp	r16, r14
    5ca0:	1f 05       	cpc	r17, r15
    5ca2:	b9 f7       	brne	.-18     	; 0x5c92 <print_uint8_base2+0x3c>
		serial_write('0' + buf[i - 1]);
}
    5ca4:	28 96       	adiw	r28, 0x08	; 8
    5ca6:	0f b6       	in	r0, 0x3f	; 63
    5ca8:	f8 94       	cli
    5caa:	de bf       	out	0x3e, r29	; 62
    5cac:	0f be       	out	0x3f, r0	; 63
    5cae:	cd bf       	out	0x3d, r28	; 61
    5cb0:	df 91       	pop	r29
    5cb2:	cf 91       	pop	r28
    5cb4:	1f 91       	pop	r17
    5cb6:	0f 91       	pop	r16
    5cb8:	ff 90       	pop	r15
    5cba:	ef 90       	pop	r14
    5cbc:	08 95       	ret

00005cbe <print_uint8_base10>:


void print_uint8_base10(uint8_t n)
{ 
    5cbe:	1f 93       	push	r17
    5cc0:	cf 93       	push	r28
    5cc2:	df 93       	push	r29
    5cc4:	00 d0       	rcall	.+0      	; 0x5cc6 <print_uint8_base10+0x8>
    5cc6:	1f 92       	push	r1
    5cc8:	cd b7       	in	r28, 0x3d	; 61
    5cca:	de b7       	in	r29, 0x3e	; 62
  if (n == 0) {
    5ccc:	81 11       	cpse	r24, r1
    5cce:	04 c0       	rjmp	.+8      	; 0x5cd8 <print_uint8_base10+0x1a>
    serial_write('0');
    5cd0:	80 e3       	ldi	r24, 0x30	; 48
    5cd2:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <serial_write>
    5cd6:	28 c0       	rjmp	.+80     	; 0x5d28 <print_uint8_base10+0x6a>
}


void print_uint8_base10(uint8_t n)
{ 
  if (n == 0) {
    5cd8:	90 e0       	ldi	r25, 0x00	; 0

  unsigned char buf[3];
  uint8_t i = 0;

  while (n > 0) {
      buf[i++] = n % 10 + '0';
    5cda:	4d ec       	ldi	r20, 0xCD	; 205
    5cdc:	11 e0       	ldi	r17, 0x01	; 1
    5cde:	19 0f       	add	r17, r25
    5ce0:	e1 e0       	ldi	r30, 0x01	; 1
    5ce2:	f0 e0       	ldi	r31, 0x00	; 0
    5ce4:	ec 0f       	add	r30, r28
    5ce6:	fd 1f       	adc	r31, r29
    5ce8:	e9 0f       	add	r30, r25
    5cea:	f1 1d       	adc	r31, r1
    5cec:	84 9f       	mul	r24, r20
    5cee:	91 2d       	mov	r25, r1
    5cf0:	11 24       	eor	r1, r1
    5cf2:	96 95       	lsr	r25
    5cf4:	96 95       	lsr	r25
    5cf6:	96 95       	lsr	r25
    5cf8:	29 2f       	mov	r18, r25
    5cfa:	22 0f       	add	r18, r18
    5cfc:	32 2f       	mov	r19, r18
    5cfe:	33 0f       	add	r19, r19
    5d00:	33 0f       	add	r19, r19
    5d02:	23 0f       	add	r18, r19
    5d04:	82 1b       	sub	r24, r18
    5d06:	80 5d       	subi	r24, 0xD0	; 208
    5d08:	80 83       	st	Z, r24
      n /= 10;
    5d0a:	89 2f       	mov	r24, r25
  } 

  unsigned char buf[3];
  uint8_t i = 0;

  while (n > 0) {
    5d0c:	99 23       	and	r25, r25
    5d0e:	11 f0       	breq	.+4      	; 0x5d14 <print_uint8_base10+0x56>
      buf[i++] = n % 10 + '0';
    5d10:	91 2f       	mov	r25, r17
    5d12:	e4 cf       	rjmp	.-56     	; 0x5cdc <print_uint8_base10+0x1e>
      n /= 10;
  }

  for (; i > 0; i--)
    5d14:	11 23       	and	r17, r17
    5d16:	41 f0       	breq	.+16     	; 0x5d28 <print_uint8_base10+0x6a>
      serial_write(buf[i - 1]);
    5d18:	fe 01       	movw	r30, r28
    5d1a:	e1 0f       	add	r30, r17
    5d1c:	f1 1d       	adc	r31, r1
    5d1e:	80 81       	ld	r24, Z
    5d20:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <serial_write>
  while (n > 0) {
      buf[i++] = n % 10 + '0';
      n /= 10;
  }

  for (; i > 0; i--)
    5d24:	11 50       	subi	r17, 0x01	; 1
    5d26:	c1 f7       	brne	.-16     	; 0x5d18 <print_uint8_base10+0x5a>
      serial_write(buf[i - 1]);
}
    5d28:	0f 90       	pop	r0
    5d2a:	0f 90       	pop	r0
    5d2c:	0f 90       	pop	r0
    5d2e:	df 91       	pop	r29
    5d30:	cf 91       	pop	r28
    5d32:	1f 91       	pop	r17
    5d34:	08 95       	ret

00005d36 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up 
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    5d36:	8f 92       	push	r8
    5d38:	9f 92       	push	r9
    5d3a:	af 92       	push	r10
    5d3c:	bf 92       	push	r11
    5d3e:	cf 92       	push	r12
    5d40:	df 92       	push	r13
    5d42:	ef 92       	push	r14
    5d44:	ff 92       	push	r15
    5d46:	0f 93       	push	r16
    5d48:	1f 93       	push	r17
    5d4a:	cf 93       	push	r28
    5d4c:	df 93       	push	r29
    5d4e:	cd b7       	in	r28, 0x3d	; 61
    5d50:	de b7       	in	r29, 0x3e	; 62
    5d52:	2a 97       	sbiw	r28, 0x0a	; 10
    5d54:	0f b6       	in	r0, 0x3f	; 63
    5d56:	f8 94       	cli
    5d58:	de bf       	out	0x3e, r29	; 62
    5d5a:	0f be       	out	0x3f, r0	; 63
    5d5c:	cd bf       	out	0x3d, r28	; 61
    5d5e:	6b 01       	movw	r12, r22
    5d60:	7c 01       	movw	r14, r24
    5d62:	14 2f       	mov	r17, r20
  if (n < 0) {
    5d64:	20 e0       	ldi	r18, 0x00	; 0
    5d66:	30 e0       	ldi	r19, 0x00	; 0
    5d68:	a9 01       	movw	r20, r18
    5d6a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__cmpsf2>
    5d6e:	88 23       	and	r24, r24
    5d70:	3c f4       	brge	.+14     	; 0x5d80 <printFloat+0x4a>
    serial_write('-');
    5d72:	8d e2       	ldi	r24, 0x2D	; 45
    5d74:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <serial_write>
    n = -n;
    5d78:	f7 fa       	bst	r15, 7
    5d7a:	f0 94       	com	r15
    5d7c:	f7 f8       	bld	r15, 7
    5d7e:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    5d80:	12 30       	cpi	r17, 0x02	; 2
    5d82:	88 f0       	brcs	.+34     	; 0x5da6 <printFloat+0x70>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    5d84:	01 2f       	mov	r16, r17
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    5d86:	20 e0       	ldi	r18, 0x00	; 0
    5d88:	30 e0       	ldi	r19, 0x00	; 0
    5d8a:	48 ec       	ldi	r20, 0xC8	; 200
    5d8c:	52 e4       	ldi	r21, 0x42	; 66
    5d8e:	c7 01       	movw	r24, r14
    5d90:	b6 01       	movw	r22, r12
    5d92:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5d96:	6b 01       	movw	r12, r22
    5d98:	7c 01       	movw	r14, r24
    decimals -= 2;
    5d9a:	02 50       	subi	r16, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    5d9c:	02 30       	cpi	r16, 0x02	; 2
    5d9e:	98 f7       	brcc	.-26     	; 0x5d86 <printFloat+0x50>
    5da0:	81 2f       	mov	r24, r17
    5da2:	81 70       	andi	r24, 0x01	; 1
    5da4:	01 c0       	rjmp	.+2      	; 0x5da8 <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    5da6:	81 2f       	mov	r24, r17
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    5da8:	88 23       	and	r24, r24
    5daa:	51 f0       	breq	.+20     	; 0x5dc0 <printFloat+0x8a>
    5dac:	20 e0       	ldi	r18, 0x00	; 0
    5dae:	30 e0       	ldi	r19, 0x00	; 0
    5db0:	40 e2       	ldi	r20, 0x20	; 32
    5db2:	51 e4       	ldi	r21, 0x41	; 65
    5db4:	c7 01       	movw	r24, r14
    5db6:	b6 01       	movw	r22, r12
    5db8:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5dbc:	6b 01       	movw	r12, r22
    5dbe:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    5dc0:	20 e0       	ldi	r18, 0x00	; 0
    5dc2:	30 e0       	ldi	r19, 0x00	; 0
    5dc4:	40 e0       	ldi	r20, 0x00	; 0
    5dc6:	5f e3       	ldi	r21, 0x3F	; 63
    5dc8:	c7 01       	movw	r24, r14
    5dca:	b6 01       	movw	r22, r12
    5dcc:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
    5dd0:	0e 94 cb 39 	call	0x7396	; 0x7396 <__fixsfsi>
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
    5dd4:	2e e2       	ldi	r18, 0x2E	; 46
    5dd6:	fe 01       	movw	r30, r28
    5dd8:	e1 0f       	add	r30, r17
    5dda:	f1 1d       	adc	r31, r1
    5ddc:	21 83       	std	Z+1, r18	; 0x01
  while(a > 0) {
    5dde:	61 15       	cp	r22, r1
    5de0:	71 05       	cpc	r23, r1
    5de2:	81 05       	cpc	r24, r1
    5de4:	91 05       	cpc	r25, r1
    5de6:	49 f1       	breq	.+82     	; 0x5e3a <printFloat+0x104>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    5de8:	20 e0       	ldi	r18, 0x00	; 0
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    5dea:	01 e0       	ldi	r16, 0x01	; 1
    5dec:	01 0f       	add	r16, r17
    buf[i++] = (a % 10) + '0'; // Get digit
    5dee:	0f 2e       	mov	r0, r31
    5df0:	fa e0       	ldi	r31, 0x0A	; 10
    5df2:	8f 2e       	mov	r8, r31
    5df4:	91 2c       	mov	r9, r1
    5df6:	a1 2c       	mov	r10, r1
    5df8:	b1 2c       	mov	r11, r1
    5dfa:	f0 2d       	mov	r31, r0
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    5dfc:	21 13       	cpse	r18, r17
    5dfe:	01 c0       	rjmp	.+2      	; 0x5e02 <printFloat+0xcc>
    5e00:	20 2f       	mov	r18, r16
    buf[i++] = (a % 10) + '0'; // Get digit
    5e02:	dd 24       	eor	r13, r13
    5e04:	d3 94       	inc	r13
    5e06:	d2 0e       	add	r13, r18
    5e08:	ee 24       	eor	r14, r14
    5e0a:	e3 94       	inc	r14
    5e0c:	f1 2c       	mov	r15, r1
    5e0e:	ec 0e       	add	r14, r28
    5e10:	fd 1e       	adc	r15, r29
    5e12:	e2 0e       	add	r14, r18
    5e14:	f1 1c       	adc	r15, r1
    5e16:	a5 01       	movw	r20, r10
    5e18:	94 01       	movw	r18, r8
    5e1a:	0e 94 87 3c 	call	0x790e	; 0x790e <__udivmodsi4>
    5e1e:	60 5d       	subi	r22, 0xD0	; 208
    5e20:	f7 01       	movw	r30, r14
    5e22:	60 83       	st	Z, r22
    a /= 10;
    5e24:	62 2f       	mov	r22, r18
    5e26:	73 2f       	mov	r23, r19
    5e28:	84 2f       	mov	r24, r20
    5e2a:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    5e2c:	61 15       	cp	r22, r1
    5e2e:	71 05       	cpc	r23, r1
    5e30:	81 05       	cpc	r24, r1
    5e32:	91 05       	cpc	r25, r1
    5e34:	19 f0       	breq	.+6      	; 0x5e3c <printFloat+0x106>
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    5e36:	2d 2d       	mov	r18, r13
    5e38:	e1 cf       	rjmp	.-62     	; 0x5dfc <printFloat+0xc6>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    5e3a:	d1 2c       	mov	r13, r1
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    5e3c:	d1 16       	cp	r13, r17
    5e3e:	70 f4       	brcc	.+28     	; 0x5e5c <printFloat+0x126>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    5e40:	90 e3       	ldi	r25, 0x30	; 48
    5e42:	81 e0       	ldi	r24, 0x01	; 1
    5e44:	8d 0d       	add	r24, r13
    5e46:	e1 e0       	ldi	r30, 0x01	; 1
    5e48:	f0 e0       	ldi	r31, 0x00	; 0
    5e4a:	ec 0f       	add	r30, r28
    5e4c:	fd 1f       	adc	r31, r29
    5e4e:	ed 0d       	add	r30, r13
    5e50:	f1 1d       	adc	r31, r1
    5e52:	90 83       	st	Z, r25
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    5e54:	81 17       	cp	r24, r17
    5e56:	29 f0       	breq	.+10     	; 0x5e62 <printFloat+0x12c>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    5e58:	d8 2e       	mov	r13, r24
    5e5a:	f3 cf       	rjmp	.-26     	; 0x5e42 <printFloat+0x10c>
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    5e5c:	1d 11       	cpse	r17, r13
    5e5e:	0b c0       	rjmp	.+22     	; 0x5e76 <printFloat+0x140>
    5e60:	1d 2d       	mov	r17, r13
    i++;
    buf[i++] = '0'; 
    5e62:	68 94       	set
    5e64:	dd 24       	eor	r13, r13
    5e66:	d1 f8       	bld	r13, 1
    5e68:	d1 0e       	add	r13, r17
  }
  while (i < decimal_places) { 
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    i++;
    5e6a:	1f 5f       	subi	r17, 0xFF	; 255
    buf[i++] = '0'; 
    5e6c:	fe 01       	movw	r30, r28
    5e6e:	e1 0f       	add	r30, r17
    5e70:	f1 1d       	adc	r31, r1
    5e72:	80 e3       	ldi	r24, 0x30	; 48
    5e74:	81 83       	std	Z+1, r24	; 0x01
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    5e76:	dd 20       	and	r13, r13
    5e78:	41 f0       	breq	.+16     	; 0x5e8a <printFloat+0x154>
    serial_write(buf[i-1]);
    5e7a:	fe 01       	movw	r30, r28
    5e7c:	ed 0d       	add	r30, r13
    5e7e:	f1 1d       	adc	r31, r1
    5e80:	80 81       	ld	r24, Z
    5e82:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <serial_write>
    i++;
    buf[i++] = '0'; 
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    5e86:	da 94       	dec	r13
    5e88:	c1 f7       	brne	.-16     	; 0x5e7a <printFloat+0x144>
    serial_write(buf[i-1]);
}
    5e8a:	2a 96       	adiw	r28, 0x0a	; 10
    5e8c:	0f b6       	in	r0, 0x3f	; 63
    5e8e:	f8 94       	cli
    5e90:	de bf       	out	0x3e, r29	; 62
    5e92:	0f be       	out	0x3f, r0	; 63
    5e94:	cd bf       	out	0x3d, r28	; 61
    5e96:	df 91       	pop	r29
    5e98:	cf 91       	pop	r28
    5e9a:	1f 91       	pop	r17
    5e9c:	0f 91       	pop	r16
    5e9e:	ff 90       	pop	r15
    5ea0:	ef 90       	pop	r14
    5ea2:	df 90       	pop	r13
    5ea4:	cf 90       	pop	r12
    5ea6:	bf 90       	pop	r11
    5ea8:	af 90       	pop	r10
    5eaa:	9f 90       	pop	r9
    5eac:	8f 90       	pop	r8
    5eae:	08 95       	ret

00005eb0 <printFloat_CoordValue>:
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
//  - SettingValue: Handles all floating point settings values (always in mm.)
void printFloat_CoordValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) { 
    5eb0:	20 91 7d 07 	lds	r18, 0x077D
    5eb4:	20 ff       	sbrs	r18, 0
    5eb6:	0a c0       	rjmp	.+20     	; 0x5ecc <printFloat_CoordValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    5eb8:	2b e8       	ldi	r18, 0x8B	; 139
    5eba:	32 e4       	ldi	r19, 0x42	; 66
    5ebc:	41 e2       	ldi	r20, 0x21	; 33
    5ebe:	5d e3       	ldi	r21, 0x3D	; 61
    5ec0:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5ec4:	44 e0       	ldi	r20, 0x04	; 4
    5ec6:	0e 94 9b 2e 	call	0x5d36	; 0x5d36 <printFloat>
    5eca:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    5ecc:	43 e0       	ldi	r20, 0x03	; 3
    5ece:	0e 94 9b 2e 	call	0x5d36	; 0x5d36 <printFloat>
    5ed2:	08 95       	ret

00005ed4 <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    5ed4:	20 91 7d 07 	lds	r18, 0x077D
    5ed8:	20 ff       	sbrs	r18, 0
    5eda:	0a c0       	rjmp	.+20     	; 0x5ef0 <printFloat_RateValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    5edc:	2b e8       	ldi	r18, 0x8B	; 139
    5ede:	32 e4       	ldi	r19, 0x42	; 66
    5ee0:	41 e2       	ldi	r20, 0x21	; 33
    5ee2:	5d e3       	ldi	r21, 0x3D	; 61
    5ee4:	0e 94 9a 3b 	call	0x7734	; 0x7734 <__mulsf3>
    5ee8:	41 e0       	ldi	r20, 0x01	; 1
    5eea:	0e 94 9b 2e 	call	0x5d36	; 0x5d36 <printFloat>
    5eee:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    5ef0:	40 e0       	ldi	r20, 0x00	; 0
    5ef2:	0e 94 9b 2e 	call	0x5d36	; 0x5d36 <printFloat>
    5ef6:	08 95       	ret

00005ef8 <printFloat_SettingValue>:
  }
}

void printFloat_SettingValue(float n) { printFloat(n,N_DECIMAL_SETTINGVALUE); }
    5ef8:	43 e0       	ldi	r20, 0x03	; 3
    5efa:	0e 94 9b 2e 	call	0x5d36	; 0x5d36 <printFloat>
    5efe:	08 95       	ret

00005f00 <probe_init>:


// Probe pin initialization routine.
void probe_init() 
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    5f00:	24 98       	cbi	0x04, 4	; 4
  if (bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { 
    5f02:	80 91 7d 07 	lds	r24, 0x077D
    5f06:	88 23       	and	r24, r24
    5f08:	24 f4       	brge	.+8      	; 0x5f12 <probe_init+0x12>
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
    5f0a:	2c 98       	cbi	0x05, 4	; 5
    probe_invert_mask = 0;
    5f0c:	10 92 8d 07 	sts	0x078D, r1
    5f10:	08 95       	ret
  } else {
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    5f12:	2c 9a       	sbi	0x05, 4	; 5
    probe_invert_mask = PROBE_MASK; 
    5f14:	80 e1       	ldi	r24, 0x10	; 16
    5f16:	80 93 8d 07 	sts	0x078D, r24
    5f1a:	08 95       	ret

00005f1c <probe_get_state>:
  }
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    5f1c:	83 b1       	in	r24, 0x03	; 3
    5f1e:	80 71       	andi	r24, 0x10	; 16
    5f20:	90 91 8d 07 	lds	r25, 0x078D
    5f24:	89 27       	eor	r24, r25
    5f26:	08 95       	ret

00005f28 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (sys.probe_state == PROBE_ACTIVE) { 
    5f28:	80 91 94 05 	lds	r24, 0x0594
    5f2c:	81 30       	cpi	r24, 0x01	; 1
    5f2e:	a1 f4       	brne	.+40     	; 0x5f58 <probe_state_monitor+0x30>
    if (probe_get_state()) {
    5f30:	0e 94 8e 2f 	call	0x5f1c	; 0x5f1c <probe_get_state>
    5f34:	88 23       	and	r24, r24
    5f36:	81 f0       	breq	.+32     	; 0x5f58 <probe_state_monitor+0x30>
      sys.probe_state = PROBE_OFF;
    5f38:	10 92 94 05 	sts	0x0594, r1
      memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS);
    5f3c:	8c e0       	ldi	r24, 0x0C	; 12
    5f3e:	e7 e8       	ldi	r30, 0x87	; 135
    5f40:	f5 e0       	ldi	r31, 0x05	; 5
    5f42:	a5 e9       	ldi	r26, 0x95	; 149
    5f44:	b5 e0       	ldi	r27, 0x05	; 5
    5f46:	01 90       	ld	r0, Z+
    5f48:	0d 92       	st	X+, r0
    5f4a:	8a 95       	dec	r24
    5f4c:	e1 f7       	brne	.-8      	; 0x5f46 <probe_state_monitor+0x1e>
      bit_true(sys.execute, EXEC_FEED_HOLD);
    5f4e:	e5 e8       	ldi	r30, 0x85	; 133
    5f50:	f5 e0       	ldi	r31, 0x05	; 5
    5f52:	80 81       	ld	r24, Z
    5f54:	88 60       	ori	r24, 0x08	; 8
    5f56:	80 83       	st	Z, r24
    5f58:	08 95       	ret

00005f5a <report_status_message>:
// from a critical error, such as a triggered hard limit. Interface should always monitor for these
// responses.
// NOTE: In silent mode, all error codes are greater than zero.
// TODO: Install silent mode to return only numeric values, primarily for GUIs.
void report_status_message(uint8_t status_code) 
{
    5f5a:	cf 93       	push	r28
    5f5c:	c8 2f       	mov	r28, r24
  if (status_code == 0) { // STATUS_OK
    5f5e:	81 11       	cpse	r24, r1
    5f60:	05 c0       	rjmp	.+10     	; 0x5f6c <report_status_message+0x12>
    printPgmString(PSTR("ok\r\n"));
    5f62:	8e ed       	ldi	r24, 0xDE	; 222
    5f64:	99 e0       	ldi	r25, 0x09	; 9
    5f66:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5f6a:	61 c0       	rjmp	.+194    	; 0x602e <report_status_message+0xd4>
  } else {
    printPgmString(PSTR("error: "));
    5f6c:	86 ed       	ldi	r24, 0xD6	; 214
    5f6e:	99 e0       	ldi	r25, 0x09	; 9
    5f70:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    switch(status_code) {          
    5f74:	4c 2f       	mov	r20, r28
    5f76:	50 e0       	ldi	r21, 0x00	; 0
    5f78:	fa 01       	movw	r30, r20
    5f7a:	31 97       	sbiw	r30, 0x01	; 1
    5f7c:	e6 31       	cpi	r30, 0x16	; 22
    5f7e:	f1 05       	cpc	r31, r1
    5f80:	08 f0       	brcs	.+2      	; 0x5f84 <report_status_message+0x2a>
    5f82:	4a c0       	rjmp	.+148    	; 0x6018 <report_status_message+0xbe>
    5f84:	e5 51       	subi	r30, 0x15	; 21
    5f86:	ff 4f       	sbci	r31, 0xFF	; 255
    5f88:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
      case STATUS_EXPECTED_COMMAND_LETTER:
      printPgmString(PSTR("Expected command letter")); break;
    5f8c:	8e eb       	ldi	r24, 0xBE	; 190
    5f8e:	99 e0       	ldi	r25, 0x09	; 9
    5f90:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5f94:	48 c0       	rjmp	.+144    	; 0x6026 <report_status_message+0xcc>
      case STATUS_BAD_NUMBER_FORMAT:
      printPgmString(PSTR("Bad number format")); break;
    5f96:	8c ea       	ldi	r24, 0xAC	; 172
    5f98:	99 e0       	ldi	r25, 0x09	; 9
    5f9a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5f9e:	43 c0       	rjmp	.+134    	; 0x6026 <report_status_message+0xcc>
      case STATUS_INVALID_STATEMENT:
      printPgmString(PSTR("Invalid statement")); break;
    5fa0:	8a e9       	ldi	r24, 0x9A	; 154
    5fa2:	99 e0       	ldi	r25, 0x09	; 9
    5fa4:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5fa8:	3e c0       	rjmp	.+124    	; 0x6026 <report_status_message+0xcc>
      case STATUS_NEGATIVE_VALUE:
      printPgmString(PSTR("Value < 0")); break;
    5faa:	80 e9       	ldi	r24, 0x90	; 144
    5fac:	99 e0       	ldi	r25, 0x09	; 9
    5fae:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5fb2:	39 c0       	rjmp	.+114    	; 0x6026 <report_status_message+0xcc>
      case STATUS_SETTING_DISABLED:
      printPgmString(PSTR("Setting disabled")); break;
    5fb4:	8f e7       	ldi	r24, 0x7F	; 127
    5fb6:	99 e0       	ldi	r25, 0x09	; 9
    5fb8:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5fbc:	34 c0       	rjmp	.+104    	; 0x6026 <report_status_message+0xcc>
      case STATUS_SETTING_STEP_PULSE_MIN:
      printPgmString(PSTR("Value < 3 usec")); break;
    5fbe:	80 e7       	ldi	r24, 0x70	; 112
    5fc0:	99 e0       	ldi	r25, 0x09	; 9
    5fc2:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5fc6:	2f c0       	rjmp	.+94     	; 0x6026 <report_status_message+0xcc>
      case STATUS_SETTING_READ_FAIL:
      printPgmString(PSTR("EEPROM read fail. Using defaults")); break;
    5fc8:	8f e4       	ldi	r24, 0x4F	; 79
    5fca:	99 e0       	ldi	r25, 0x09	; 9
    5fcc:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5fd0:	2a c0       	rjmp	.+84     	; 0x6026 <report_status_message+0xcc>
      case STATUS_IDLE_ERROR:
      printPgmString(PSTR("Not idle")); break;
    5fd2:	86 e4       	ldi	r24, 0x46	; 70
    5fd4:	99 e0       	ldi	r25, 0x09	; 9
    5fd6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5fda:	25 c0       	rjmp	.+74     	; 0x6026 <report_status_message+0xcc>
      case STATUS_ALARM_LOCK:
      printPgmString(PSTR("Alarm lock")); break;
    5fdc:	8b e3       	ldi	r24, 0x3B	; 59
    5fde:	99 e0       	ldi	r25, 0x09	; 9
    5fe0:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5fe4:	20 c0       	rjmp	.+64     	; 0x6026 <report_status_message+0xcc>
      case STATUS_SOFT_LIMIT_ERROR:
      printPgmString(PSTR("Homing not enabled")); break;
    5fe6:	88 e2       	ldi	r24, 0x28	; 40
    5fe8:	99 e0       	ldi	r25, 0x09	; 9
    5fea:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5fee:	1b c0       	rjmp	.+54     	; 0x6026 <report_status_message+0xcc>
      case STATUS_OVERFLOW:
      printPgmString(PSTR("Line overflow")); break; 
    5ff0:	8a e1       	ldi	r24, 0x1A	; 26
    5ff2:	99 e0       	ldi	r25, 0x09	; 9
    5ff4:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    5ff8:	16 c0       	rjmp	.+44     	; 0x6026 <report_status_message+0xcc>
      
      // Common g-code parser errors.
      case STATUS_GCODE_MODAL_GROUP_VIOLATION:
      printPgmString(PSTR("Modal group violation")); break;
    5ffa:	84 e0       	ldi	r24, 0x04	; 4
    5ffc:	99 e0       	ldi	r25, 0x09	; 9
    5ffe:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6002:	11 c0       	rjmp	.+34     	; 0x6026 <report_status_message+0xcc>
      case STATUS_GCODE_UNSUPPORTED_COMMAND:
      printPgmString(PSTR("Unsupported command")); break;
    6004:	80 ef       	ldi	r24, 0xF0	; 240
    6006:	98 e0       	ldi	r25, 0x08	; 8
    6008:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    600c:	0c c0       	rjmp	.+24     	; 0x6026 <report_status_message+0xcc>
      case STATUS_GCODE_UNDEFINED_FEED_RATE:
      printPgmString(PSTR("Undefined feed rate")); break;
    600e:	8c ed       	ldi	r24, 0xDC	; 220
    6010:	98 e0       	ldi	r25, 0x08	; 8
    6012:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6016:	07 c0       	rjmp	.+14     	; 0x6026 <report_status_message+0xcc>
      default:
        // Remaining g-code parser errors with error codes
        printPgmString(PSTR("Invalid gcode ID:"));
    6018:	8a ec       	ldi	r24, 0xCA	; 202
    601a:	98 e0       	ldi	r25, 0x08	; 8
    601c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
        print_uint8_base10(status_code); // Print error code for user reference
    6020:	8c 2f       	mov	r24, r28
    6022:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
    }
    printPgmString(PSTR("\r\n"));
    6026:	87 ec       	ldi	r24, 0xC7	; 199
    6028:	98 e0       	ldi	r25, 0x08	; 8
    602a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }
}
    602e:	cf 91       	pop	r28
    6030:	08 95       	ret

00006032 <report_alarm_message>:

// Prints alarm messages.
void report_alarm_message(int8_t alarm_code)
{
    6032:	cf 93       	push	r28
    6034:	c8 2f       	mov	r28, r24
  printPgmString(PSTR("ALARM: "));
    6036:	8f eb       	ldi	r24, 0xBF	; 191
    6038:	98 e0       	ldi	r25, 0x08	; 8
    603a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  switch (alarm_code) {
    603e:	ce 3f       	cpi	r28, 0xFE	; 254
    6040:	51 f0       	breq	.+20     	; 0x6056 <report_alarm_message+0x24>
    6042:	cf 3f       	cpi	r28, 0xFF	; 255
    6044:	19 f0       	breq	.+6      	; 0x604c <report_alarm_message+0x1a>
    6046:	cd 3f       	cpi	r28, 0xFD	; 253
    6048:	79 f4       	brne	.+30     	; 0x6068 <report_alarm_message+0x36>
    604a:	0a c0       	rjmp	.+20     	; 0x6060 <report_alarm_message+0x2e>
    case ALARM_LIMIT_ERROR: 
    printPgmString(PSTR("Hard/soft limit")); break;
    604c:	8f ea       	ldi	r24, 0xAF	; 175
    604e:	98 e0       	ldi	r25, 0x08	; 8
    6050:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6054:	09 c0       	rjmp	.+18     	; 0x6068 <report_alarm_message+0x36>
    case ALARM_ABORT_CYCLE: 
    printPgmString(PSTR("Abort during cycle")); break;
    6056:	8c e9       	ldi	r24, 0x9C	; 156
    6058:	98 e0       	ldi	r25, 0x08	; 8
    605a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    605e:	04 c0       	rjmp	.+8      	; 0x6068 <report_alarm_message+0x36>
    case ALARM_PROBE_FAIL:
    printPgmString(PSTR("Probe fail")); break;
    6060:	81 e9       	ldi	r24, 0x91	; 145
    6062:	98 e0       	ldi	r25, 0x08	; 8
    6064:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }
  printPgmString(PSTR("\r\n"));
    6068:	8e e8       	ldi	r24, 0x8E	; 142
    606a:	98 e0       	ldi	r25, 0x08	; 8
    606c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  delay_ms(500); // Force delay to ensure message clears serial write buffer.
    6070:	84 ef       	ldi	r24, 0xF4	; 244
    6072:	91 e0       	ldi	r25, 0x01	; 1
    6074:	0e 94 e6 2a 	call	0x55cc	; 0x55cc <delay_ms>
}
    6078:	cf 91       	pop	r28
    607a:	08 95       	ret

0000607c <report_feedback_message>:
// messages such as setup warnings, switch toggling, and how to exit alarms.
// NOTE: For interfaces, messages are always placed within brackets. And if silent mode
// is installed, the message number codes are less than zero.
// TODO: Install silence feedback messages option in settings
void report_feedback_message(uint8_t message_code)
{
    607c:	cf 93       	push	r28
    607e:	c8 2f       	mov	r28, r24
  printPgmString(PSTR("["));
    6080:	8c e8       	ldi	r24, 0x8C	; 140
    6082:	98 e0       	ldi	r25, 0x08	; 8
    6084:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  switch(message_code) {
    6088:	c3 30       	cpi	r28, 0x03	; 3
    608a:	a9 f0       	breq	.+42     	; 0x60b6 <report_feedback_message+0x3a>
    608c:	28 f4       	brcc	.+10     	; 0x6098 <report_feedback_message+0x1c>
    608e:	c1 30       	cpi	r28, 0x01	; 1
    6090:	41 f0       	breq	.+16     	; 0x60a2 <report_feedback_message+0x26>
    6092:	c2 30       	cpi	r28, 0x02	; 2
    6094:	59 f0       	breq	.+22     	; 0x60ac <report_feedback_message+0x30>
    6096:	1d c0       	rjmp	.+58     	; 0x60d2 <report_feedback_message+0x56>
    6098:	c4 30       	cpi	r28, 0x04	; 4
    609a:	91 f0       	breq	.+36     	; 0x60c0 <report_feedback_message+0x44>
    609c:	c5 30       	cpi	r28, 0x05	; 5
    609e:	a9 f0       	breq	.+42     	; 0x60ca <report_feedback_message+0x4e>
    60a0:	18 c0       	rjmp	.+48     	; 0x60d2 <report_feedback_message+0x56>
    case MESSAGE_CRITICAL_EVENT:
    printPgmString(PSTR("Reset to continue")); break;
    60a2:	8a e7       	ldi	r24, 0x7A	; 122
    60a4:	98 e0       	ldi	r25, 0x08	; 8
    60a6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    60aa:	13 c0       	rjmp	.+38     	; 0x60d2 <report_feedback_message+0x56>
    case MESSAGE_ALARM_LOCK:
    printPgmString(PSTR("'$H'|'$X' to unlock")); break;
    60ac:	86 e6       	ldi	r24, 0x66	; 102
    60ae:	98 e0       	ldi	r25, 0x08	; 8
    60b0:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    60b4:	0e c0       	rjmp	.+28     	; 0x60d2 <report_feedback_message+0x56>
    case MESSAGE_ALARM_UNLOCK:
    printPgmString(PSTR("Caution: Unlocked")); break;
    60b6:	84 e5       	ldi	r24, 0x54	; 84
    60b8:	98 e0       	ldi	r25, 0x08	; 8
    60ba:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    60be:	09 c0       	rjmp	.+18     	; 0x60d2 <report_feedback_message+0x56>
    case MESSAGE_ENABLED:
    printPgmString(PSTR("Enabled")); break;
    60c0:	8c e4       	ldi	r24, 0x4C	; 76
    60c2:	98 e0       	ldi	r25, 0x08	; 8
    60c4:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    60c8:	04 c0       	rjmp	.+8      	; 0x60d2 <report_feedback_message+0x56>
    case MESSAGE_DISABLED:
    printPgmString(PSTR("Disabled")); break; 
    60ca:	83 e4       	ldi	r24, 0x43	; 67
    60cc:	98 e0       	ldi	r25, 0x08	; 8
    60ce:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }
  printPgmString(PSTR("]\r\n"));
    60d2:	8f e3       	ldi	r24, 0x3F	; 63
    60d4:	98 e0       	ldi	r25, 0x08	; 8
    60d6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
}
    60da:	cf 91       	pop	r28
    60dc:	08 95       	ret

000060de <report_init_message>:


// Welcome message
void report_init_message()
{
  printPgmString(PSTR("\r\nGrbl " GRBL_VERSION " [" GRBL_VERSION_BUILD "] ['$' for help]\r\n"));
    60de:	85 e1       	ldi	r24, 0x15	; 21
    60e0:	98 e0       	ldi	r25, 0x08	; 8
    60e2:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    60e6:	08 95       	ret

000060e8 <report_grbl_help>:
}

// Grbl help message
void report_grbl_help() {
  printPgmString(PSTR("$$ (view Grbl settings)\r\n"
    60e8:	81 ed       	ldi	r24, 0xD1	; 209
    60ea:	96 e0       	ldi	r25, 0x06	; 6
    60ec:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    60f0:	08 95       	ret

000060f2 <report_grbl_settings>:
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    60f2:	cf 92       	push	r12
    60f4:	df 92       	push	r13
    60f6:	ef 92       	push	r14
    60f8:	ff 92       	push	r15
    60fa:	0f 93       	push	r16
    60fc:	1f 93       	push	r17
    60fe:	cf 93       	push	r28
    6100:	df 93       	push	r29
  // Print Grbl settings.
  printPgmString(PSTR("$0=")); print_uint8_base10(settings.pulse_microseconds);
    6102:	8d ec       	ldi	r24, 0xCD	; 205
    6104:	96 e0       	ldi	r25, 0x06	; 6
    6106:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    610a:	80 91 70 07 	lds	r24, 0x0770
    610e:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (step pulse, usec)\r\n$1=")); print_uint8_base10(settings.stepper_idle_lock_time);
    6112:	84 eb       	ldi	r24, 0xB4	; 180
    6114:	96 e0       	ldi	r25, 0x06	; 6
    6116:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    611a:	80 91 73 07 	lds	r24, 0x0773
    611e:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (step idle delay, msec)\r\n$2=")); print_uint8_base10(settings.step_invert_mask); 
    6122:	86 e9       	ldi	r24, 0x96	; 150
    6124:	96 e0       	ldi	r25, 0x06	; 6
    6126:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    612a:	c1 e7       	ldi	r28, 0x71	; 113
    612c:	d7 e0       	ldi	r29, 0x07	; 7
    612e:	88 81       	ld	r24, Y
    6130:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (step port invert mask:")); print_uint8_base2(settings.step_invert_mask);  
    6134:	8d e7       	ldi	r24, 0x7D	; 125
    6136:	96 e0       	ldi	r25, 0x06	; 6
    6138:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    613c:	88 81       	ld	r24, Y
    613e:	0e 94 2b 2e 	call	0x5c56	; 0x5c56 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$3=")); print_uint8_base10(settings.dir_invert_mask); 
    6142:	86 e7       	ldi	r24, 0x76	; 118
    6144:	96 e0       	ldi	r25, 0x06	; 6
    6146:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    614a:	c2 e7       	ldi	r28, 0x72	; 114
    614c:	d7 e0       	ldi	r29, 0x07	; 7
    614e:	88 81       	ld	r24, Y
    6150:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (dir port invert mask:")); print_uint8_base2(settings.dir_invert_mask);  
    6154:	8e e5       	ldi	r24, 0x5E	; 94
    6156:	96 e0       	ldi	r25, 0x06	; 6
    6158:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    615c:	88 81       	ld	r24, Y
    615e:	0e 94 2b 2e 	call	0x5c56	; 0x5c56 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$4=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE));
    6162:	87 e5       	ldi	r24, 0x57	; 87
    6164:	96 e0       	ldi	r25, 0x06	; 6
    6166:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    616a:	cd e7       	ldi	r28, 0x7D	; 125
    616c:	d7 e0       	ldi	r29, 0x07	; 7
    616e:	88 81       	ld	r24, Y
    6170:	82 fb       	bst	r24, 2
    6172:	88 27       	eor	r24, r24
    6174:	80 f9       	bld	r24, 0
    6176:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (step enable invert, bool)\r\n$5=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_LIMIT_PINS));
    617a:	86 e3       	ldi	r24, 0x36	; 54
    617c:	96 e0       	ldi	r25, 0x06	; 6
    617e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6182:	88 81       	ld	r24, Y
    6184:	86 fb       	bst	r24, 6
    6186:	88 27       	eor	r24, r24
    6188:	80 f9       	bld	r24, 0
    618a:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (limit pins invert, bool)\r\n$6=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_INVERT_PROBE_PIN));
    618e:	86 e1       	ldi	r24, 0x16	; 22
    6190:	96 e0       	ldi	r25, 0x06	; 6
    6192:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6196:	88 81       	ld	r24, Y
    6198:	88 1f       	adc	r24, r24
    619a:	88 27       	eor	r24, r24
    619c:	88 1f       	adc	r24, r24
    619e:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (probe pin invert, bool)\r\n$10=")); print_uint8_base10(settings.status_report_mask);
    61a2:	86 ef       	ldi	r24, 0xF6	; 246
    61a4:	95 e0       	ldi	r25, 0x05	; 5
    61a6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    61aa:	04 e7       	ldi	r16, 0x74	; 116
    61ac:	17 e0       	ldi	r17, 0x07	; 7
    61ae:	f8 01       	movw	r30, r16
    61b0:	80 81       	ld	r24, Z
    61b2:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (status report mask:")); print_uint8_base2(settings.status_report_mask);
    61b6:	80 ee       	ldi	r24, 0xE0	; 224
    61b8:	95 e0       	ldi	r25, 0x05	; 5
    61ba:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    61be:	f8 01       	movw	r30, r16
    61c0:	80 81       	ld	r24, Z
    61c2:	0e 94 2b 2e 	call	0x5c56	; 0x5c56 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$11=")); printFloat_SettingValue(settings.junction_deviation);
    61c6:	88 ed       	ldi	r24, 0xD8	; 216
    61c8:	95 e0       	ldi	r25, 0x05	; 5
    61ca:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    61ce:	60 91 75 07 	lds	r22, 0x0775
    61d2:	70 91 76 07 	lds	r23, 0x0776
    61d6:	80 91 77 07 	lds	r24, 0x0777
    61da:	90 91 78 07 	lds	r25, 0x0778
    61de:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
  printPgmString(PSTR(" (junction deviation, mm)\r\n$12=")); printFloat_SettingValue(settings.arc_tolerance);
    61e2:	88 eb       	ldi	r24, 0xB8	; 184
    61e4:	95 e0       	ldi	r25, 0x05	; 5
    61e6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    61ea:	60 91 79 07 	lds	r22, 0x0779
    61ee:	70 91 7a 07 	lds	r23, 0x077A
    61f2:	80 91 7b 07 	lds	r24, 0x077B
    61f6:	90 91 7c 07 	lds	r25, 0x077C
    61fa:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
  printPgmString(PSTR(" (arc tolerance, mm)\r\n$13=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_REPORT_INCHES));
    61fe:	8d e9       	ldi	r24, 0x9D	; 157
    6200:	95 e0       	ldi	r25, 0x05	; 5
    6202:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6206:	88 81       	ld	r24, Y
    6208:	81 70       	andi	r24, 0x01	; 1
    620a:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (report inches, bool)\r\n$14=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_AUTO_START));
    620e:	80 e8       	ldi	r24, 0x80	; 128
    6210:	95 e0       	ldi	r25, 0x05	; 5
    6212:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6216:	88 81       	ld	r24, Y
    6218:	86 95       	lsr	r24
    621a:	81 70       	andi	r24, 0x01	; 1
    621c:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (auto start, bool)\r\n$20=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE));
    6220:	86 e6       	ldi	r24, 0x66	; 102
    6222:	95 e0       	ldi	r25, 0x05	; 5
    6224:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6228:	88 81       	ld	r24, Y
    622a:	85 fb       	bst	r24, 5
    622c:	88 27       	eor	r24, r24
    622e:	80 f9       	bld	r24, 0
    6230:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (soft limits, bool)\r\n$21=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE));
    6234:	8b e4       	ldi	r24, 0x4B	; 75
    6236:	95 e0       	ldi	r25, 0x05	; 5
    6238:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    623c:	88 81       	ld	r24, Y
    623e:	83 fb       	bst	r24, 3
    6240:	88 27       	eor	r24, r24
    6242:	80 f9       	bld	r24, 0
    6244:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (hard limits, bool)\r\n$22=")); print_uint8_base10(bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE));
    6248:	80 e3       	ldi	r24, 0x30	; 48
    624a:	95 e0       	ldi	r25, 0x05	; 5
    624c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6250:	88 81       	ld	r24, Y
    6252:	82 95       	swap	r24
    6254:	81 70       	andi	r24, 0x01	; 1
    6256:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (homing cycle, bool)\r\n$23=")); print_uint8_base10(settings.homing_dir_mask);
    625a:	84 e1       	ldi	r24, 0x14	; 20
    625c:	95 e0       	ldi	r25, 0x05	; 5
    625e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6262:	ce e7       	ldi	r28, 0x7E	; 126
    6264:	d7 e0       	ldi	r29, 0x07	; 7
    6266:	88 81       	ld	r24, Y
    6268:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (homing dir invert mask:")); print_uint8_base2(settings.homing_dir_mask);  
    626c:	8a ef       	ldi	r24, 0xFA	; 250
    626e:	94 e0       	ldi	r25, 0x04	; 4
    6270:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6274:	88 81       	ld	r24, Y
    6276:	0e 94 2b 2e 	call	0x5c56	; 0x5c56 <print_uint8_base2>
  printPgmString(PSTR(")\r\n$24=")); printFloat_SettingValue(settings.homing_feed_rate);
    627a:	82 ef       	ldi	r24, 0xF2	; 242
    627c:	94 e0       	ldi	r25, 0x04	; 4
    627e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6282:	60 91 7f 07 	lds	r22, 0x077F
    6286:	70 91 80 07 	lds	r23, 0x0780
    628a:	80 91 81 07 	lds	r24, 0x0781
    628e:	90 91 82 07 	lds	r25, 0x0782
    6292:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing feed, mm/min)\r\n$25=")); printFloat_SettingValue(settings.homing_seek_rate);
    6296:	85 ed       	ldi	r24, 0xD5	; 213
    6298:	94 e0       	ldi	r25, 0x04	; 4
    629a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    629e:	60 91 83 07 	lds	r22, 0x0783
    62a2:	70 91 84 07 	lds	r23, 0x0784
    62a6:	80 91 85 07 	lds	r24, 0x0785
    62aa:	90 91 86 07 	lds	r25, 0x0786
    62ae:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing seek, mm/min)\r\n$26=")); print_uint8_base10(settings.homing_debounce_delay);
    62b2:	88 eb       	ldi	r24, 0xB8	; 184
    62b4:	94 e0       	ldi	r25, 0x04	; 4
    62b6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    62ba:	80 91 87 07 	lds	r24, 0x0787
    62be:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR(" (homing debounce, msec)\r\n$27=")); printFloat_SettingValue(settings.homing_pulloff);
    62c2:	89 e9       	ldi	r24, 0x99	; 153
    62c4:	94 e0       	ldi	r25, 0x04	; 4
    62c6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    62ca:	60 91 89 07 	lds	r22, 0x0789
    62ce:	70 91 8a 07 	lds	r23, 0x078A
    62d2:	80 91 8b 07 	lds	r24, 0x078B
    62d6:	90 91 8c 07 	lds	r25, 0x078C
    62da:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
  printPgmString(PSTR(" (homing pull-off, mm)\r\n"));
    62de:	80 e8       	ldi	r24, 0x80	; 128
    62e0:	94 e0       	ldi	r25, 0x04	; 4
    62e2:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
    62e6:	0f 2e       	mov	r0, r31
    62e8:	f4 e6       	ldi	r31, 0x64	; 100
    62ea:	df 2e       	mov	r13, r31
    62ec:	f0 2d       	mov	r31, r0
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    62ee:	10 e0       	ldi	r17, 0x00	; 0
    62f0:	0f 2e       	mov	r0, r31
    62f2:	f0 e4       	ldi	r31, 0x40	; 64
    62f4:	ef 2e       	mov	r14, r31
    62f6:	f7 e0       	ldi	r31, 0x07	; 7
    62f8:	ff 2e       	mov	r15, r31
    62fa:	f0 2d       	mov	r31, r0
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    62fc:	c1 2c       	mov	r12, r1
    62fe:	7a c0       	rjmp	.+244    	; 0x63f4 <report_grbl_settings+0x302>
  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
      printPgmString(PSTR("$"));
    6300:	8e e7       	ldi	r24, 0x7E	; 126
    6302:	94 e0       	ldi	r25, 0x04	; 4
    6304:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
      print_uint8_base10(val+idx);
    6308:	80 2f       	mov	r24, r16
    630a:	8d 0d       	add	r24, r13
    630c:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
      printPgmString(PSTR("="));
    6310:	8c e7       	ldi	r24, 0x7C	; 124
    6312:	94 e0       	ldi	r25, 0x04	; 4
    6314:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
      switch (set_idx) {
    6318:	11 30       	cpi	r17, 0x01	; 1
    631a:	69 f0       	breq	.+26     	; 0x6336 <report_grbl_settings+0x244>
    631c:	28 f0       	brcs	.+10     	; 0x6328 <report_grbl_settings+0x236>
    631e:	12 30       	cpi	r17, 0x02	; 2
    6320:	89 f0       	breq	.+34     	; 0x6344 <report_grbl_settings+0x252>
    6322:	13 30       	cpi	r17, 0x03	; 3
    6324:	e1 f0       	breq	.+56     	; 0x635e <report_grbl_settings+0x26c>
    6326:	24 c0       	rjmp	.+72     	; 0x6370 <report_grbl_settings+0x27e>
        case 0: printFloat_SettingValue(settings.steps_per_mm[idx]); break;
    6328:	68 81       	ld	r22, Y
    632a:	79 81       	ldd	r23, Y+1	; 0x01
    632c:	8a 81       	ldd	r24, Y+2	; 0x02
    632e:	9b 81       	ldd	r25, Y+3	; 0x03
    6330:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
    6334:	1d c0       	rjmp	.+58     	; 0x6370 <report_grbl_settings+0x27e>
        case 1: printFloat_SettingValue(settings.max_rate[idx]); break;
    6336:	6c 85       	ldd	r22, Y+12	; 0x0c
    6338:	7d 85       	ldd	r23, Y+13	; 0x0d
    633a:	8e 85       	ldd	r24, Y+14	; 0x0e
    633c:	9f 85       	ldd	r25, Y+15	; 0x0f
    633e:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
    6342:	16 c0       	rjmp	.+44     	; 0x6370 <report_grbl_settings+0x27e>
        case 2: printFloat_SettingValue(settings.acceleration[idx]/(60*60)); break;
    6344:	20 e0       	ldi	r18, 0x00	; 0
    6346:	30 e0       	ldi	r19, 0x00	; 0
    6348:	41 e6       	ldi	r20, 0x61	; 97
    634a:	55 e4       	ldi	r21, 0x45	; 69
    634c:	68 8d       	ldd	r22, Y+24	; 0x18
    634e:	79 8d       	ldd	r23, Y+25	; 0x19
    6350:	8a 8d       	ldd	r24, Y+26	; 0x1a
    6352:	9b 8d       	ldd	r25, Y+27	; 0x1b
    6354:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    6358:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
    635c:	09 c0       	rjmp	.+18     	; 0x6370 <report_grbl_settings+0x27e>
        case 3: printFloat_SettingValue(-settings.max_travel[idx]); break;
    635e:	8c a1       	ldd	r24, Y+36	; 0x24
    6360:	9d a1       	ldd	r25, Y+37	; 0x25
    6362:	ae a1       	ldd	r26, Y+38	; 0x26
    6364:	bf a1       	ldd	r27, Y+39	; 0x27
    6366:	bc 01       	movw	r22, r24
    6368:	cd 01       	movw	r24, r26
    636a:	90 58       	subi	r25, 0x80	; 128
    636c:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <printFloat_SettingValue>
      }
      printPgmString(PSTR(" ("));
    6370:	89 e7       	ldi	r24, 0x79	; 121
    6372:	94 e0       	ldi	r25, 0x04	; 4
    6374:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
      switch (idx) {
    6378:	01 30       	cpi	r16, 0x01	; 1
    637a:	49 f0       	breq	.+18     	; 0x638e <report_grbl_settings+0x29c>
    637c:	18 f0       	brcs	.+6      	; 0x6384 <report_grbl_settings+0x292>
    637e:	02 30       	cpi	r16, 0x02	; 2
    6380:	59 f0       	breq	.+22     	; 0x6398 <report_grbl_settings+0x2a6>
    6382:	0e c0       	rjmp	.+28     	; 0x63a0 <report_grbl_settings+0x2ae>
        case X_AXIS: printPgmString(PSTR("x")); break;
    6384:	87 e7       	ldi	r24, 0x77	; 119
    6386:	94 e0       	ldi	r25, 0x04	; 4
    6388:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    638c:	09 c0       	rjmp	.+18     	; 0x63a0 <report_grbl_settings+0x2ae>
        case Y_AXIS: printPgmString(PSTR("y")); break;
    638e:	85 e7       	ldi	r24, 0x75	; 117
    6390:	94 e0       	ldi	r25, 0x04	; 4
    6392:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6396:	04 c0       	rjmp	.+8      	; 0x63a0 <report_grbl_settings+0x2ae>
        case Z_AXIS: printPgmString(PSTR("z")); break;
    6398:	83 e7       	ldi	r24, 0x73	; 115
    639a:	94 e0       	ldi	r25, 0x04	; 4
    639c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
      }
      switch (set_idx) {
    63a0:	11 30       	cpi	r17, 0x01	; 1
    63a2:	59 f0       	breq	.+22     	; 0x63ba <report_grbl_settings+0x2c8>
    63a4:	28 f0       	brcs	.+10     	; 0x63b0 <report_grbl_settings+0x2be>
    63a6:	12 30       	cpi	r17, 0x02	; 2
    63a8:	69 f0       	breq	.+26     	; 0x63c4 <report_grbl_settings+0x2d2>
    63aa:	13 30       	cpi	r17, 0x03	; 3
    63ac:	81 f0       	breq	.+32     	; 0x63ce <report_grbl_settings+0x2dc>
    63ae:	13 c0       	rjmp	.+38     	; 0x63d6 <report_grbl_settings+0x2e4>
        case 0: printPgmString(PSTR(", step/mm")); break;
    63b0:	89 e6       	ldi	r24, 0x69	; 105
    63b2:	94 e0       	ldi	r25, 0x04	; 4
    63b4:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    63b8:	0e c0       	rjmp	.+28     	; 0x63d6 <report_grbl_settings+0x2e4>
        case 1: printPgmString(PSTR(" max rate, mm/min")); break;
    63ba:	87 e5       	ldi	r24, 0x57	; 87
    63bc:	94 e0       	ldi	r25, 0x04	; 4
    63be:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    63c2:	09 c0       	rjmp	.+18     	; 0x63d6 <report_grbl_settings+0x2e4>
        case 2: printPgmString(PSTR(" accel, mm/sec^2")); break;
    63c4:	86 e4       	ldi	r24, 0x46	; 70
    63c6:	94 e0       	ldi	r25, 0x04	; 4
    63c8:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    63cc:	04 c0       	rjmp	.+8      	; 0x63d6 <report_grbl_settings+0x2e4>
        case 3: printPgmString(PSTR(" max travel, mm")); break;
    63ce:	86 e3       	ldi	r24, 0x36	; 54
    63d0:	94 e0       	ldi	r25, 0x04	; 4
    63d2:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
      }      
      printPgmString(PSTR(")\r\n"));
    63d6:	82 e3       	ldi	r24, 0x32	; 50
    63d8:	94 e0       	ldi	r25, 0x04	; 4
    63da:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    for (idx=0; idx<N_AXIS; idx++) {
    63de:	0f 5f       	subi	r16, 0xFF	; 255
    63e0:	24 96       	adiw	r28, 0x04	; 4
    63e2:	03 30       	cpi	r16, 0x03	; 3
    63e4:	09 f0       	breq	.+2      	; 0x63e8 <report_grbl_settings+0x2f6>
    63e6:	8c cf       	rjmp	.-232    	; 0x6300 <report_grbl_settings+0x20e>
        case 2: printPgmString(PSTR(" accel, mm/sec^2")); break;
        case 3: printPgmString(PSTR(" max travel, mm")); break;
      }      
      printPgmString(PSTR(")\r\n"));
    }
    val += AXIS_SETTINGS_INCREMENT;
    63e8:	fa e0       	ldi	r31, 0x0A	; 10
    63ea:	df 0e       	add	r13, r31
  printPgmString(PSTR(" (homing pull-off, mm)\r\n"));

  // Print axis settings
  uint8_t idx, set_idx;
  uint8_t val = AXIS_SETTINGS_START_VAL;
  for (set_idx=0; set_idx<AXIS_N_SETTINGS; set_idx++) {
    63ec:	1f 5f       	subi	r17, 0xFF	; 255
    63ee:	8c e8       	ldi	r24, 0x8C	; 140
    63f0:	d8 16       	cp	r13, r24
    63f2:	19 f0       	breq	.+6      	; 0x63fa <report_grbl_settings+0x308>
    63f4:	e7 01       	movw	r28, r14
}


// Grbl global settings print out.
// NOTE: The numbering scheme here must correlate to storing in settings.c
void report_grbl_settings() {
    63f6:	0c 2d       	mov	r16, r12
    63f8:	83 cf       	rjmp	.-250    	; 0x6300 <report_grbl_settings+0x20e>
      }      
      printPgmString(PSTR(")\r\n"));
    }
    val += AXIS_SETTINGS_INCREMENT;
  }  
}
    63fa:	df 91       	pop	r29
    63fc:	cf 91       	pop	r28
    63fe:	1f 91       	pop	r17
    6400:	0f 91       	pop	r16
    6402:	ff 90       	pop	r15
    6404:	ef 90       	pop	r14
    6406:	df 90       	pop	r13
    6408:	cf 90       	pop	r12
    640a:	08 95       	ret

0000640c <report_probe_parameters>:

// Prints current probe parameters. Upon a probe command, these parameters are updated upon a
// successful probe or upon a failed probe with the G38.3 without errors command (if supported). 
// These values are retained until Grbl is power-cycled, whereby they will be re-zeroed.
void report_probe_parameters()
{
    640c:	bf 92       	push	r11
    640e:	cf 92       	push	r12
    6410:	df 92       	push	r13
    6412:	ef 92       	push	r14
    6414:	ff 92       	push	r15
    6416:	0f 93       	push	r16
    6418:	1f 93       	push	r17
    641a:	cf 93       	push	r28
    641c:	df 93       	push	r29
  uint8_t i;
  float print_position;
 
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:")); 
    641e:	8c e2       	ldi	r24, 0x2C	; 44
    6420:	94 e0       	ldi	r25, 0x04	; 4
    6422:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6426:	05 e9       	ldi	r16, 0x95	; 149
    6428:	15 e0       	ldi	r17, 0x05	; 5
    642a:	c0 e4       	ldi	r28, 0x40	; 64
    642c:	d7 e0       	ldi	r29, 0x07	; 7
  for (i=0; i< N_AXIS; i++) {
    642e:	b1 2c       	mov	r11, r1
    print_position = sys.probe_position[i]/settings.steps_per_mm[i];
    6430:	f8 01       	movw	r30, r16
    6432:	61 91       	ld	r22, Z+
    6434:	71 91       	ld	r23, Z+
    6436:	81 91       	ld	r24, Z+
    6438:	91 91       	ld	r25, Z+
    643a:	8f 01       	movw	r16, r30
    643c:	c9 90       	ld	r12, Y+
    643e:	d9 90       	ld	r13, Y+
    6440:	e9 90       	ld	r14, Y+
    6442:	f9 90       	ld	r15, Y+
    6444:	0e 94 fe 39 	call	0x73fc	; 0x73fc <__floatsisf>
    6448:	a7 01       	movw	r20, r14
    644a:	96 01       	movw	r18, r12
    644c:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    printFloat_CoordValue(print_position);
    6450:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6454:	f1 e0       	ldi	r31, 0x01	; 1
    6456:	fb 15       	cp	r31, r11
    6458:	20 f0       	brcs	.+8      	; 0x6462 <report_probe_parameters+0x56>
    645a:	8a e2       	ldi	r24, 0x2A	; 42
    645c:	94 e0       	ldi	r25, 0x04	; 4
    645e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  uint8_t i;
  float print_position;
 
  // Report in terms of machine position.
  printPgmString(PSTR("[PRB:")); 
  for (i=0; i< N_AXIS; i++) {
    6462:	b3 94       	inc	r11
    6464:	83 e0       	ldi	r24, 0x03	; 3
    6466:	b8 12       	cpse	r11, r24
    6468:	e3 cf       	rjmp	.-58     	; 0x6430 <report_probe_parameters+0x24>
    print_position = sys.probe_position[i]/settings.steps_per_mm[i];
    printFloat_CoordValue(print_position);
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
  }  
  printPgmString(PSTR("]\r\n"));
    646a:	86 e2       	ldi	r24, 0x26	; 38
    646c:	94 e0       	ldi	r25, 0x04	; 4
    646e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
}
    6472:	df 91       	pop	r29
    6474:	cf 91       	pop	r28
    6476:	1f 91       	pop	r17
    6478:	0f 91       	pop	r16
    647a:	ff 90       	pop	r15
    647c:	ef 90       	pop	r14
    647e:	df 90       	pop	r13
    6480:	cf 90       	pop	r12
    6482:	bf 90       	pop	r11
    6484:	08 95       	ret

00006486 <report_ngc_parameters>:


// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
    6486:	df 92       	push	r13
    6488:	ef 92       	push	r14
    648a:	ff 92       	push	r15
    648c:	0f 93       	push	r16
    648e:	1f 93       	push	r17
    6490:	cf 93       	push	r28
    6492:	df 93       	push	r29
    6494:	cd b7       	in	r28, 0x3d	; 61
    6496:	de b7       	in	r29, 0x3e	; 62
    6498:	2c 97       	sbiw	r28, 0x0c	; 12
    649a:	0f b6       	in	r0, 0x3f	; 63
    649c:	f8 94       	cli
    649e:	de bf       	out	0x3e, r29	; 62
    64a0:	0f be       	out	0x3f, r0	; 63
    64a2:	cd bf       	out	0x3d, r28	; 61
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
    64a4:	e1 2c       	mov	r14, r1
      case 6: printPgmString(PSTR("28")); break;
      case 7: printPgmString(PSTR("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }
    printPgmString(PSTR(":"));
    for (i=0; i<N_AXIS; i++) {
    64a6:	d1 2c       	mov	r13, r1
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
    if (!(settings_read_coord_data(coord_select,coord_data))) {
    64a8:	be 01       	movw	r22, r28
    64aa:	6f 5f       	subi	r22, 0xFF	; 255
    64ac:	7f 4f       	sbci	r23, 0xFF	; 255
    64ae:	8e 2d       	mov	r24, r14
    64b0:	0e 94 6d 23 	call	0x46da	; 0x46da <settings_read_coord_data>
    64b4:	81 11       	cpse	r24, r1
    64b6:	04 c0       	rjmp	.+8      	; 0x64c0 <report_ngc_parameters+0x3a>
      report_status_message(STATUS_SETTING_READ_FAIL);
    64b8:	87 e0       	ldi	r24, 0x07	; 7
    64ba:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    64be:	9f c0       	rjmp	.+318    	; 0x65fe <report_ngc_parameters+0x178>
      return;
    }
    printPgmString(PSTR("[G"));
    64c0:	83 e2       	ldi	r24, 0x23	; 35
    64c2:	94 e0       	ldi	r25, 0x04	; 4
    64c4:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    switch (coord_select) {
    64c8:	86 e0       	ldi	r24, 0x06	; 6
    64ca:	e8 16       	cp	r14, r24
    64cc:	21 f0       	breq	.+8      	; 0x64d6 <report_ngc_parameters+0x50>
    64ce:	e7 e0       	ldi	r30, 0x07	; 7
    64d0:	ee 16       	cp	r14, r30
    64d2:	31 f0       	breq	.+12     	; 0x64e0 <report_ngc_parameters+0x5a>
    64d4:	0a c0       	rjmp	.+20     	; 0x64ea <report_ngc_parameters+0x64>
      case 6: printPgmString(PSTR("28")); break;
    64d6:	80 e2       	ldi	r24, 0x20	; 32
    64d8:	94 e0       	ldi	r25, 0x04	; 4
    64da:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    64de:	09 c0       	rjmp	.+18     	; 0x64f2 <report_ngc_parameters+0x6c>
      case 7: printPgmString(PSTR("30")); break;
    64e0:	8d e1       	ldi	r24, 0x1D	; 29
    64e2:	94 e0       	ldi	r25, 0x04	; 4
    64e4:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    64e8:	04 c0       	rjmp	.+8      	; 0x64f2 <report_ngc_parameters+0x6c>
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    64ea:	86 e3       	ldi	r24, 0x36	; 54
    64ec:	8e 0d       	add	r24, r14
    64ee:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
    }
    printPgmString(PSTR(":"));
    64f2:	8b e1       	ldi	r24, 0x1B	; 27
    64f4:	94 e0       	ldi	r25, 0x04	; 4
    64f6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    64fa:	8e 01       	movw	r16, r28
    64fc:	0f 5f       	subi	r16, 0xFF	; 255
    64fe:	1f 4f       	sbci	r17, 0xFF	; 255
    for (i=0; i<N_AXIS; i++) {
    6500:	fd 2c       	mov	r15, r13
      printFloat_CoordValue(coord_data[i]);
    6502:	f8 01       	movw	r30, r16
    6504:	61 91       	ld	r22, Z+
    6506:	71 91       	ld	r23, Z+
    6508:	81 91       	ld	r24, Z+
    650a:	91 91       	ld	r25, Z+
    650c:	8f 01       	movw	r16, r30
    650e:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6512:	f1 e0       	ldi	r31, 0x01	; 1
    6514:	ff 15       	cp	r31, r15
    6516:	28 f0       	brcs	.+10     	; 0x6522 <report_ngc_parameters+0x9c>
    6518:	89 e1       	ldi	r24, 0x19	; 25
    651a:	94 e0       	ldi	r25, 0x04	; 4
    651c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6520:	04 c0       	rjmp	.+8      	; 0x652a <report_ngc_parameters+0xa4>
      else { printPgmString(PSTR("]\r\n")); }
    6522:	85 e1       	ldi	r24, 0x15	; 21
    6524:	94 e0       	ldi	r25, 0x04	; 4
    6526:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
      case 6: printPgmString(PSTR("28")); break;
      case 7: printPgmString(PSTR("30")); break;
      default: print_uint8_base10(coord_select+54); break; // G54-G59
    }
    printPgmString(PSTR(":"));
    for (i=0; i<N_AXIS; i++) {
    652a:	f3 94       	inc	r15
    652c:	83 e0       	ldi	r24, 0x03	; 3
    652e:	f8 12       	cpse	r15, r24
    6530:	e8 cf       	rjmp	.-48     	; 0x6502 <report_ngc_parameters+0x7c>
// Prints Grbl NGC parameters (coordinate offsets, probing)
void report_ngc_parameters()
{
  float coord_data[N_AXIS];
  uint8_t coord_select, i;
  for (coord_select = 0; coord_select <= SETTING_INDEX_NCOORD; coord_select++) {
    6532:	e3 94       	inc	r14
    6534:	e8 e0       	ldi	r30, 0x08	; 8
    6536:	ee 12       	cpse	r14, r30
    6538:	b7 cf       	rjmp	.-146    	; 0x64a8 <report_ngc_parameters+0x22>
      printFloat_CoordValue(coord_data[i]);
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
      else { printPgmString(PSTR("]\r\n")); }
    }
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
    653a:	8f e0       	ldi	r24, 0x0F	; 15
    653c:	94 e0       	ldi	r25, 0x04	; 4
    653e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6542:	09 e3       	ldi	r16, 0x39	; 57
    6544:	16 e0       	ldi	r17, 0x06	; 6
  for (i=0; i<N_AXIS; i++) {
    6546:	f1 2c       	mov	r15, r1
    printFloat_CoordValue(gc_state.coord_offset[i]);
    6548:	f8 01       	movw	r30, r16
    654a:	61 91       	ld	r22, Z+
    654c:	71 91       	ld	r23, Z+
    654e:	81 91       	ld	r24, Z+
    6550:	91 91       	ld	r25, Z+
    6552:	8f 01       	movw	r16, r30
    6554:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6558:	f1 e0       	ldi	r31, 0x01	; 1
    655a:	ff 15       	cp	r31, r15
    655c:	28 f0       	brcs	.+10     	; 0x6568 <report_ngc_parameters+0xe2>
    655e:	8d e0       	ldi	r24, 0x0D	; 13
    6560:	94 e0       	ldi	r25, 0x04	; 4
    6562:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6566:	04 c0       	rjmp	.+8      	; 0x6570 <report_ngc_parameters+0xea>
    else { printPgmString(PSTR("]\r\n")); }
    6568:	89 e0       	ldi	r24, 0x09	; 9
    656a:	94 e0       	ldi	r25, 0x04	; 4
    656c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
      else { printPgmString(PSTR("]\r\n")); }
    }
  }
  printPgmString(PSTR("[G92:")); // Print G92,G92.1 which are not persistent in memory
  for (i=0; i<N_AXIS; i++) {
    6570:	f3 94       	inc	r15
    6572:	83 e0       	ldi	r24, 0x03	; 3
    6574:	f8 12       	cpse	r15, r24
    6576:	e8 cf       	rjmp	.-48     	; 0x6548 <report_ngc_parameters+0xc2>
    6578:	01 ee       	ldi	r16, 0xE1	; 225
    657a:	15 e0       	ldi	r17, 0x05	; 5
    657c:	ff 24       	eor	r15, r15
    657e:	f3 94       	inc	r15
    else { printPgmString(PSTR("]\r\n")); }
  } 

  // Print tool table which are not persisted to memory
  for (i=1; i < N_TOOL_TABLE; i++) {
	printPgmString(PSTR("[T"));
    6580:	86 e0       	ldi	r24, 0x06	; 6
    6582:	94 e0       	ldi	r25, 0x04	; 4
    6584:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
	print_uint8_base10( i);
    6588:	8f 2d       	mov	r24, r15
    658a:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
	printPgmString(PSTR(" R"));
    658e:	83 e0       	ldi	r24, 0x03	; 3
    6590:	94 e0       	ldi	r25, 0x04	; 4
    6592:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
	printFloat_CoordValue( gc_state.tool_table[i].r);
    6596:	f8 01       	movw	r30, r16
    6598:	60 81       	ld	r22, Z
    659a:	71 81       	ldd	r23, Z+1	; 0x01
    659c:	82 81       	ldd	r24, Z+2	; 0x02
    659e:	93 81       	ldd	r25, Z+3	; 0x03
    65a0:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
	printPgmString(PSTR(" XYZ "));
    65a4:	8d ef       	ldi	r24, 0xFD	; 253
    65a6:	93 e0       	ldi	r25, 0x03	; 3
    65a8:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
	for ( coord_select=0; coord_select<N_AXIS; coord_select++) {
		printFloat_CoordValue(gc_state.tool_table[i].xyz[ coord_select]);
    65ac:	f8 01       	movw	r30, r16
    65ae:	64 81       	ldd	r22, Z+4	; 0x04
    65b0:	75 81       	ldd	r23, Z+5	; 0x05
    65b2:	86 81       	ldd	r24, Z+6	; 0x06
    65b4:	97 81       	ldd	r25, Z+7	; 0x07
    65b6:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
		if (coord_select < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    65ba:	8b ef       	ldi	r24, 0xFB	; 251
    65bc:	93 e0       	ldi	r25, 0x03	; 3
    65be:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
	print_uint8_base10( i);
	printPgmString(PSTR(" R"));
	printFloat_CoordValue( gc_state.tool_table[i].r);
	printPgmString(PSTR(" XYZ "));
	for ( coord_select=0; coord_select<N_AXIS; coord_select++) {
		printFloat_CoordValue(gc_state.tool_table[i].xyz[ coord_select]);
    65c2:	f8 01       	movw	r30, r16
    65c4:	60 85       	ldd	r22, Z+8	; 0x08
    65c6:	71 85       	ldd	r23, Z+9	; 0x09
    65c8:	82 85       	ldd	r24, Z+10	; 0x0a
    65ca:	93 85       	ldd	r25, Z+11	; 0x0b
    65cc:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
		if (coord_select < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    65d0:	8b ef       	ldi	r24, 0xFB	; 251
    65d2:	93 e0       	ldi	r25, 0x03	; 3
    65d4:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
	print_uint8_base10( i);
	printPgmString(PSTR(" R"));
	printFloat_CoordValue( gc_state.tool_table[i].r);
	printPgmString(PSTR(" XYZ "));
	for ( coord_select=0; coord_select<N_AXIS; coord_select++) {
		printFloat_CoordValue(gc_state.tool_table[i].xyz[ coord_select]);
    65d8:	f8 01       	movw	r30, r16
    65da:	64 85       	ldd	r22, Z+12	; 0x0c
    65dc:	75 85       	ldd	r23, Z+13	; 0x0d
    65de:	86 85       	ldd	r24, Z+14	; 0x0e
    65e0:	97 85       	ldd	r25, Z+15	; 0x0f
    65e2:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
		if (coord_select < (N_AXIS-1)) { printPgmString(PSTR(",")); }
	}
	printPgmString(PSTR("]\r\n"));
    65e6:	87 ef       	ldi	r24, 0xF7	; 247
    65e8:	93 e0       	ldi	r25, 0x03	; 3
    65ea:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    else { printPgmString(PSTR("]\r\n")); }
  } 

  // Print tool table which are not persisted to memory
  for (i=1; i < N_TOOL_TABLE; i++) {
    65ee:	f3 94       	inc	r15
    65f0:	00 5f       	subi	r16, 0xF0	; 240
    65f2:	1f 4f       	sbci	r17, 0xFF	; 255
    65f4:	f5 e0       	ldi	r31, 0x05	; 5
    65f6:	ff 12       	cpse	r15, r31
    65f8:	c3 cf       	rjmp	.-122    	; 0x6580 <report_ngc_parameters+0xfa>
		if (coord_select < (N_AXIS-1)) { printPgmString(PSTR(",")); }
	}
	printPgmString(PSTR("]\r\n"));
  }

  report_probe_parameters(); // Print probe parameters. Not persistent in memory.
    65fa:	0e 94 06 32 	call	0x640c	; 0x640c <report_probe_parameters>
}
    65fe:	2c 96       	adiw	r28, 0x0c	; 12
    6600:	0f b6       	in	r0, 0x3f	; 63
    6602:	f8 94       	cli
    6604:	de bf       	out	0x3e, r29	; 62
    6606:	0f be       	out	0x3f, r0	; 63
    6608:	cd bf       	out	0x3d, r28	; 61
    660a:	df 91       	pop	r29
    660c:	cf 91       	pop	r28
    660e:	1f 91       	pop	r17
    6610:	0f 91       	pop	r16
    6612:	ff 90       	pop	r15
    6614:	ef 90       	pop	r14
    6616:	df 90       	pop	r13
    6618:	08 95       	ret

0000661a <report_gcode_modes>:


// Print current gcode parser mode state
void report_gcode_modes()
{
  switch (gc_state.modal.motion) {
    661a:	80 91 bd 05 	lds	r24, 0x05BD
    661e:	82 30       	cpi	r24, 0x02	; 2
    6620:	a9 f0       	breq	.+42     	; 0x664c <report_gcode_modes+0x32>
    6622:	28 f4       	brcc	.+10     	; 0x662e <report_gcode_modes+0x14>
    6624:	88 23       	and	r24, r24
    6626:	41 f0       	breq	.+16     	; 0x6638 <report_gcode_modes+0x1e>
    6628:	81 30       	cpi	r24, 0x01	; 1
    662a:	59 f0       	breq	.+22     	; 0x6642 <report_gcode_modes+0x28>
    662c:	1d c0       	rjmp	.+58     	; 0x6668 <report_gcode_modes+0x4e>
    662e:	83 30       	cpi	r24, 0x03	; 3
    6630:	91 f0       	breq	.+36     	; 0x6656 <report_gcode_modes+0x3c>
    6632:	85 30       	cpi	r24, 0x05	; 5
    6634:	a9 f0       	breq	.+42     	; 0x6660 <report_gcode_modes+0x46>
    6636:	18 c0       	rjmp	.+48     	; 0x6668 <report_gcode_modes+0x4e>
    case MOTION_MODE_SEEK : printPgmString(PSTR("[G0")); break;
    6638:	83 ef       	ldi	r24, 0xF3	; 243
    663a:	93 e0       	ldi	r25, 0x03	; 3
    663c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6640:	13 c0       	rjmp	.+38     	; 0x6668 <report_gcode_modes+0x4e>
    case MOTION_MODE_LINEAR : printPgmString(PSTR("[G1")); break;
    6642:	8f ee       	ldi	r24, 0xEF	; 239
    6644:	93 e0       	ldi	r25, 0x03	; 3
    6646:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    664a:	0e c0       	rjmp	.+28     	; 0x6668 <report_gcode_modes+0x4e>
    case MOTION_MODE_CW_ARC : printPgmString(PSTR("[G2")); break;
    664c:	8b ee       	ldi	r24, 0xEB	; 235
    664e:	93 e0       	ldi	r25, 0x03	; 3
    6650:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6654:	09 c0       	rjmp	.+18     	; 0x6668 <report_gcode_modes+0x4e>
    case MOTION_MODE_CCW_ARC : printPgmString(PSTR("[G3")); break;
    6656:	87 ee       	ldi	r24, 0xE7	; 231
    6658:	93 e0       	ldi	r25, 0x03	; 3
    665a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    665e:	04 c0       	rjmp	.+8      	; 0x6668 <report_gcode_modes+0x4e>
    case MOTION_MODE_NONE : printPgmString(PSTR("[G80")); break;
    6660:	82 ee       	ldi	r24, 0xE2	; 226
    6662:	93 e0       	ldi	r25, 0x03	; 3
    6664:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }

  printPgmString(PSTR(" G"));
    6668:	8f ed       	ldi	r24, 0xDF	; 223
    666a:	93 e0       	ldi	r25, 0x03	; 3
    666c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  print_uint8_base10(gc_state.modal.coord_select+54);
    6670:	80 91 c2 05 	lds	r24, 0x05C2
    6674:	8a 5c       	subi	r24, 0xCA	; 202
    6676:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  
  switch (gc_state.modal.plane_select) {
    667a:	80 91 c1 05 	lds	r24, 0x05C1
    667e:	81 30       	cpi	r24, 0x01	; 1
    6680:	49 f0       	breq	.+18     	; 0x6694 <report_gcode_modes+0x7a>
    6682:	18 f0       	brcs	.+6      	; 0x668a <report_gcode_modes+0x70>
    6684:	82 30       	cpi	r24, 0x02	; 2
    6686:	59 f0       	breq	.+22     	; 0x669e <report_gcode_modes+0x84>
    6688:	0e c0       	rjmp	.+28     	; 0x66a6 <report_gcode_modes+0x8c>
    case PLANE_SELECT_XY : printPgmString(PSTR(" G17")); break;
    668a:	8a ed       	ldi	r24, 0xDA	; 218
    668c:	93 e0       	ldi	r25, 0x03	; 3
    668e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6692:	09 c0       	rjmp	.+18     	; 0x66a6 <report_gcode_modes+0x8c>
    case PLANE_SELECT_ZX : printPgmString(PSTR(" G18")); break;
    6694:	85 ed       	ldi	r24, 0xD5	; 213
    6696:	93 e0       	ldi	r25, 0x03	; 3
    6698:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    669c:	04 c0       	rjmp	.+8      	; 0x66a6 <report_gcode_modes+0x8c>
    case PLANE_SELECT_YZ : printPgmString(PSTR(" G19")); break;
    669e:	80 ed       	ldi	r24, 0xD0	; 208
    66a0:	93 e0       	ldi	r25, 0x03	; 3
    66a2:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }
  
  if (gc_state.modal.units == UNITS_MODE_MM) { printPgmString(PSTR(" G21")); }
    66a6:	80 91 bf 05 	lds	r24, 0x05BF
    66aa:	81 11       	cpse	r24, r1
    66ac:	05 c0       	rjmp	.+10     	; 0x66b8 <report_gcode_modes+0x9e>
    66ae:	8b ec       	ldi	r24, 0xCB	; 203
    66b0:	93 e0       	ldi	r25, 0x03	; 3
    66b2:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    66b6:	04 c0       	rjmp	.+8      	; 0x66c0 <report_gcode_modes+0xa6>
  else { printPgmString(PSTR(" G20")); }
    66b8:	86 ec       	ldi	r24, 0xC6	; 198
    66ba:	93 e0       	ldi	r25, 0x03	; 3
    66bc:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  
  if (gc_state.modal.distance == DISTANCE_MODE_ABSOLUTE) { printPgmString(PSTR(" G90")); }
    66c0:	80 91 c0 05 	lds	r24, 0x05C0
    66c4:	81 11       	cpse	r24, r1
    66c6:	05 c0       	rjmp	.+10     	; 0x66d2 <report_gcode_modes+0xb8>
    66c8:	81 ec       	ldi	r24, 0xC1	; 193
    66ca:	93 e0       	ldi	r25, 0x03	; 3
    66cc:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    66d0:	04 c0       	rjmp	.+8      	; 0x66da <report_gcode_modes+0xc0>
  else { printPgmString(PSTR(" G91")); }
    66d2:	8c eb       	ldi	r24, 0xBC	; 188
    66d4:	93 e0       	ldi	r25, 0x03	; 3
    66d6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  
  if (gc_state.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { printPgmString(PSTR(" G93")); }
    66da:	80 91 be 05 	lds	r24, 0x05BE
    66de:	81 30       	cpi	r24, 0x01	; 1
    66e0:	29 f4       	brne	.+10     	; 0x66ec <report_gcode_modes+0xd2>
    66e2:	87 eb       	ldi	r24, 0xB7	; 183
    66e4:	93 e0       	ldi	r25, 0x03	; 3
    66e6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    66ea:	04 c0       	rjmp	.+8      	; 0x66f4 <report_gcode_modes+0xda>
  else { printPgmString(PSTR(" G94")); }
    66ec:	82 eb       	ldi	r24, 0xB2	; 178
    66ee:	93 e0       	ldi	r25, 0x03	; 3
    66f0:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    
  switch (gc_state.modal.program_flow) {
    66f4:	80 91 c3 05 	lds	r24, 0x05C3
    66f8:	81 30       	cpi	r24, 0x01	; 1
    66fa:	49 f0       	breq	.+18     	; 0x670e <report_gcode_modes+0xf4>
    66fc:	18 f0       	brcs	.+6      	; 0x6704 <report_gcode_modes+0xea>
    66fe:	82 30       	cpi	r24, 0x02	; 2
    6700:	59 f0       	breq	.+22     	; 0x6718 <report_gcode_modes+0xfe>
    6702:	0e c0       	rjmp	.+28     	; 0x6720 <report_gcode_modes+0x106>
    case PROGRAM_FLOW_RUNNING : printPgmString(PSTR(" M0")); break;
    6704:	8e ea       	ldi	r24, 0xAE	; 174
    6706:	93 e0       	ldi	r25, 0x03	; 3
    6708:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    670c:	09 c0       	rjmp	.+18     	; 0x6720 <report_gcode_modes+0x106>
    case PROGRAM_FLOW_PAUSED : printPgmString(PSTR(" M1")); break;
    670e:	8a ea       	ldi	r24, 0xAA	; 170
    6710:	93 e0       	ldi	r25, 0x03	; 3
    6712:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6716:	04 c0       	rjmp	.+8      	; 0x6720 <report_gcode_modes+0x106>
    case PROGRAM_FLOW_COMPLETED : printPgmString(PSTR(" M2")); break;
    6718:	86 ea       	ldi	r24, 0xA6	; 166
    671a:	93 e0       	ldi	r25, 0x03	; 3
    671c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }

  switch (gc_state.modal.spindle) {
    6720:	80 91 c5 05 	lds	r24, 0x05C5
    6724:	81 30       	cpi	r24, 0x01	; 1
    6726:	21 f0       	breq	.+8      	; 0x6730 <report_gcode_modes+0x116>
    6728:	68 f0       	brcs	.+26     	; 0x6744 <report_gcode_modes+0x12a>
    672a:	82 30       	cpi	r24, 0x02	; 2
    672c:	31 f0       	breq	.+12     	; 0x673a <report_gcode_modes+0x120>
    672e:	0e c0       	rjmp	.+28     	; 0x674c <report_gcode_modes+0x132>
    case SPINDLE_ENABLE_CW : printPgmString(PSTR(" M3")); break;
    6730:	82 ea       	ldi	r24, 0xA2	; 162
    6732:	93 e0       	ldi	r25, 0x03	; 3
    6734:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6738:	09 c0       	rjmp	.+18     	; 0x674c <report_gcode_modes+0x132>
    case SPINDLE_ENABLE_CCW : printPgmString(PSTR(" M4")); break;
    673a:	8e e9       	ldi	r24, 0x9E	; 158
    673c:	93 e0       	ldi	r25, 0x03	; 3
    673e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6742:	04 c0       	rjmp	.+8      	; 0x674c <report_gcode_modes+0x132>
    case SPINDLE_DISABLE : printPgmString(PSTR(" M5")); break;
    6744:	8a e9       	ldi	r24, 0x9A	; 154
    6746:	93 e0       	ldi	r25, 0x03	; 3
    6748:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }
  
  switch (gc_state.modal.coolant) {
    674c:	80 91 c4 05 	lds	r24, 0x05C4
    6750:	81 30       	cpi	r24, 0x01	; 1
    6752:	71 f0       	breq	.+28     	; 0x6770 <report_gcode_modes+0x156>
    6754:	18 f0       	brcs	.+6      	; 0x675c <report_gcode_modes+0x142>
    6756:	82 30       	cpi	r24, 0x02	; 2
    6758:	31 f0       	breq	.+12     	; 0x6766 <report_gcode_modes+0x14c>
    675a:	0e c0       	rjmp	.+28     	; 0x6778 <report_gcode_modes+0x15e>
    case COOLANT_DISABLE : printPgmString(PSTR(" M9")); break;
    675c:	86 e9       	ldi	r24, 0x96	; 150
    675e:	93 e0       	ldi	r25, 0x03	; 3
    6760:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6764:	09 c0       	rjmp	.+18     	; 0x6778 <report_gcode_modes+0x15e>
    case COOLANT_FLOOD_ENABLE : printPgmString(PSTR(" M8")); break;
    6766:	82 e9       	ldi	r24, 0x92	; 146
    6768:	93 e0       	ldi	r25, 0x03	; 3
    676a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    676e:	04 c0       	rjmp	.+8      	; 0x6778 <report_gcode_modes+0x15e>
    #ifdef ENABLE_M7
      case COOLANT_MIST_ENABLE : printPgmString(PSTR(" M7")); break;
    6770:	8e e8       	ldi	r24, 0x8E	; 142
    6772:	93 e0       	ldi	r25, 0x03	; 3
    6774:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    #endif
  }
  
  printPgmString(PSTR(" T"));
    6778:	8b e8       	ldi	r24, 0x8B	; 139
    677a:	93 e0       	ldi	r25, 0x03	; 3
    677c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  print_uint8_base10(gc_state.modal.tool);
    6780:	80 91 c6 05 	lds	r24, 0x05C6
    6784:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  
  printPgmString(PSTR(" H"));
    6788:	88 e8       	ldi	r24, 0x88	; 136
    678a:	93 e0       	ldi	r25, 0x03	; 3
    678c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  print_uint8_base10(gc_state.modal.tool_comp);
    6790:	80 91 c7 05 	lds	r24, 0x05C7
    6794:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>

  printPgmString(PSTR(" F"));
    6798:	85 e8       	ldi	r24, 0x85	; 133
    679a:	93 e0       	ldi	r25, 0x03	; 3
    679c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  printFloat_RateValue(gc_state.feed_rate);
    67a0:	60 91 cc 05 	lds	r22, 0x05CC
    67a4:	70 91 cd 05 	lds	r23, 0x05CD
    67a8:	80 91 ce 05 	lds	r24, 0x05CE
    67ac:	90 91 cf 05 	lds	r25, 0x05CF
    67b0:	0e 94 6a 2f 	call	0x5ed4	; 0x5ed4 <printFloat_RateValue>

  printPgmString(PSTR("]\r\n"));
    67b4:	81 e8       	ldi	r24, 0x81	; 129
    67b6:	93 e0       	ldi	r25, 0x03	; 3
    67b8:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    67bc:	08 95       	ret

000067be <report_startup_line>:
}

// Prints specified startup line
void report_startup_line(uint8_t n, char *line)
{
    67be:	1f 93       	push	r17
    67c0:	cf 93       	push	r28
    67c2:	df 93       	push	r29
    67c4:	18 2f       	mov	r17, r24
    67c6:	eb 01       	movw	r28, r22
  printPgmString(PSTR("$N")); print_uint8_base10(n);
    67c8:	8e e7       	ldi	r24, 0x7E	; 126
    67ca:	93 e0       	ldi	r25, 0x03	; 3
    67cc:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    67d0:	81 2f       	mov	r24, r17
    67d2:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString(PSTR("=")); printString(line);
    67d6:	8c e7       	ldi	r24, 0x7C	; 124
    67d8:	93 e0       	ldi	r25, 0x03	; 3
    67da:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    67de:	ce 01       	movw	r24, r28
    67e0:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <printString>
  printPgmString(PSTR("\r\n"));
    67e4:	89 e7       	ldi	r24, 0x79	; 121
    67e6:	93 e0       	ldi	r25, 0x03	; 3
    67e8:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
}
    67ec:	df 91       	pop	r29
    67ee:	cf 91       	pop	r28
    67f0:	1f 91       	pop	r17
    67f2:	08 95       	ret

000067f4 <report_build_info>:


// Prints build info line
void report_build_info(char *line)
{
    67f4:	cf 93       	push	r28
    67f6:	df 93       	push	r29
    67f8:	ec 01       	movw	r28, r24
  printPgmString(PSTR("[" GRBL_VERSION "." GRBL_VERSION_BUILD "-"));
    67fa:	87 e6       	ldi	r24, 0x67	; 103
    67fc:	93 e0       	ldi	r25, 0x03	; 3
    67fe:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  print_uint8_base10( BLOCK_BUFFER_SIZE);
    6802:	84 e1       	ldi	r24, 0x14	; 20
    6804:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  printPgmString( PSTR( ":"));
    6808:	85 e6       	ldi	r24, 0x65	; 101
    680a:	93 e0       	ldi	r25, 0x03	; 3
    680c:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  printString(line);
    6810:	ce 01       	movw	r24, r28
    6812:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <printString>
  printPgmString(PSTR("]\r\n"));
    6816:	81 e6       	ldi	r24, 0x61	; 97
    6818:	93 e0       	ldi	r25, 0x03	; 3
    681a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
}
    681e:	df 91       	pop	r29
    6820:	cf 91       	pop	r28
    6822:	08 95       	ret

00006824 <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly, 
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    6824:	7f 92       	push	r7
    6826:	8f 92       	push	r8
    6828:	9f 92       	push	r9
    682a:	af 92       	push	r10
    682c:	bf 92       	push	r11
    682e:	cf 92       	push	r12
    6830:	df 92       	push	r13
    6832:	ef 92       	push	r14
    6834:	ff 92       	push	r15
    6836:	0f 93       	push	r16
    6838:	1f 93       	push	r17
    683a:	cf 93       	push	r28
    683c:	df 93       	push	r29
    683e:	cd b7       	in	r28, 0x3d	; 61
    6840:	de b7       	in	r29, 0x3e	; 62
    6842:	68 97       	sbiw	r28, 0x18	; 24
    6844:	0f b6       	in	r0, 0x3f	; 63
    6846:	f8 94       	cli
    6848:	de bf       	out	0x3e, r29	; 62
    684a:	0f be       	out	0x3f, r0	; 63
    684c:	cd bf       	out	0x3d, r28	; 61
  // the system power on location (0,0,0) and work coordinate position (G54 and G92 applied). Eventually
  // to be added are distance to go on block, processed block id, and feed rate. Also a settings bitmask
  // for a user to select the desired real-time data.
  uint8_t i;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys.position,sizeof(sys.position));
    684e:	8c e0       	ldi	r24, 0x0C	; 12
    6850:	e7 e8       	ldi	r30, 0x87	; 135
    6852:	f5 e0       	ldi	r31, 0x05	; 5
    6854:	de 01       	movw	r26, r28
    6856:	11 96       	adiw	r26, 0x01	; 1
    6858:	01 90       	ld	r0, Z+
    685a:	0d 92       	st	X+, r0
    685c:	8a 95       	dec	r24
    685e:	e1 f7       	brne	.-8      	; 0x6858 <report_realtime_status+0x34>
  float print_position[N_AXIS];
 
  // Report current machine state
  switch (sys.state) {
    6860:	80 91 84 05 	lds	r24, 0x0584
    6864:	90 e0       	ldi	r25, 0x00	; 0
    6866:	81 32       	cpi	r24, 0x21	; 33
    6868:	91 05       	cpc	r25, r1
    686a:	38 f5       	brcc	.+78     	; 0x68ba <report_realtime_status+0x96>
    686c:	fc 01       	movw	r30, r24
    686e:	ef 5f       	subi	r30, 0xFF	; 255
    6870:	fe 4f       	sbci	r31, 0xFE	; 254
    6872:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
    case STATE_IDLE: printPgmString(PSTR("<Idle")); break;
    6876:	8b e5       	ldi	r24, 0x5B	; 91
    6878:	93 e0       	ldi	r25, 0x03	; 3
    687a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    687e:	1d c0       	rjmp	.+58     	; 0x68ba <report_realtime_status+0x96>
    case STATE_QUEUED: printPgmString(PSTR("<Queue")); break;
    6880:	84 e5       	ldi	r24, 0x54	; 84
    6882:	93 e0       	ldi	r25, 0x03	; 3
    6884:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6888:	18 c0       	rjmp	.+48     	; 0x68ba <report_realtime_status+0x96>
    case STATE_CYCLE: printPgmString(PSTR("<Run")); break;
    688a:	8f e4       	ldi	r24, 0x4F	; 79
    688c:	93 e0       	ldi	r25, 0x03	; 3
    688e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    6892:	13 c0       	rjmp	.+38     	; 0x68ba <report_realtime_status+0x96>
    case STATE_HOLD: printPgmString(PSTR("<Hold")); break;
    6894:	89 e4       	ldi	r24, 0x49	; 73
    6896:	93 e0       	ldi	r25, 0x03	; 3
    6898:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    689c:	0e c0       	rjmp	.+28     	; 0x68ba <report_realtime_status+0x96>
    case STATE_HOMING: printPgmString(PSTR("<Home")); break;
    689e:	83 e4       	ldi	r24, 0x43	; 67
    68a0:	93 e0       	ldi	r25, 0x03	; 3
    68a2:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    68a6:	09 c0       	rjmp	.+18     	; 0x68ba <report_realtime_status+0x96>
    case STATE_ALARM: printPgmString(PSTR("<Alarm")); break;
    68a8:	8c e3       	ldi	r24, 0x3C	; 60
    68aa:	93 e0       	ldi	r25, 0x03	; 3
    68ac:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    68b0:	04 c0       	rjmp	.+8      	; 0x68ba <report_realtime_status+0x96>
    case STATE_CHECK_MODE: printPgmString(PSTR("<Check")); break;
    68b2:	85 e3       	ldi	r24, 0x35	; 53
    68b4:	93 e0       	ldi	r25, 0x03	; 3
    68b6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }
 
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    68ba:	80 91 74 07 	lds	r24, 0x0774
    68be:	80 ff       	sbrs	r24, 0
    68c0:	36 c0       	rjmp	.+108    	; 0x692e <report_realtime_status+0x10a>
    printPgmString(PSTR(",MPos:")); 
    68c2:	8e e2       	ldi	r24, 0x2E	; 46
    68c4:	93 e0       	ldi	r25, 0x03	; 3
    68c6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    68ca:	ce 01       	movw	r24, r28
    68cc:	01 96       	adiw	r24, 0x01	; 1
    68ce:	6c 01       	movw	r12, r24
    68d0:	0f 2e       	mov	r0, r31
    68d2:	f0 e4       	ldi	r31, 0x40	; 64
    68d4:	ef 2e       	mov	r14, r31
    68d6:	f7 e0       	ldi	r31, 0x07	; 7
    68d8:	ff 2e       	mov	r15, r31
    68da:	f0 2d       	mov	r31, r0
    68dc:	8e 01       	movw	r16, r28
    68de:	03 5f       	subi	r16, 0xF3	; 243
    68e0:	1f 4f       	sbci	r17, 0xFF	; 255
    for (i=0; i< N_AXIS; i++) {
    68e2:	71 2c       	mov	r7, r1
      print_position[i] = current_position[i]/settings.steps_per_mm[i];
    68e4:	f6 01       	movw	r30, r12
    68e6:	61 91       	ld	r22, Z+
    68e8:	71 91       	ld	r23, Z+
    68ea:	81 91       	ld	r24, Z+
    68ec:	91 91       	ld	r25, Z+
    68ee:	6f 01       	movw	r12, r30
    68f0:	f7 01       	movw	r30, r14
    68f2:	81 90       	ld	r8, Z+
    68f4:	91 90       	ld	r9, Z+
    68f6:	a1 90       	ld	r10, Z+
    68f8:	b1 90       	ld	r11, Z+
    68fa:	7f 01       	movw	r14, r30
    68fc:	0e 94 fe 39 	call	0x73fc	; 0x73fc <__floatsisf>
    6900:	a5 01       	movw	r20, r10
    6902:	94 01       	movw	r18, r8
    6904:	0e 94 63 39 	call	0x72c6	; 0x72c6 <__divsf3>
    6908:	f8 01       	movw	r30, r16
    690a:	61 93       	st	Z+, r22
    690c:	71 93       	st	Z+, r23
    690e:	81 93       	st	Z+, r24
    6910:	91 93       	st	Z+, r25
    6912:	8f 01       	movw	r16, r30
      printFloat_CoordValue(print_position[i]);
    6914:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    6918:	f1 e0       	ldi	r31, 0x01	; 1
    691a:	f7 15       	cp	r31, r7
    691c:	20 f0       	brcs	.+8      	; 0x6926 <report_realtime_status+0x102>
    691e:	8c e2       	ldi	r24, 0x2C	; 44
    6920:	93 e0       	ldi	r25, 0x03	; 3
    6922:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
  }
 
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (i=0; i< N_AXIS; i++) {
    6926:	73 94       	inc	r7
    6928:	33 e0       	ldi	r19, 0x03	; 3
    692a:	73 12       	cpse	r7, r19
    692c:	db cf       	rjmp	.-74     	; 0x68e4 <report_realtime_status+0xc0>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    692e:	80 91 74 07 	lds	r24, 0x0774
    6932:	81 ff       	sbrs	r24, 1
    6934:	52 c0       	rjmp	.+164    	; 0x69da <report_realtime_status+0x1b6>
    printPgmString(PSTR(",WPos:")); 
    6936:	85 e2       	ldi	r24, 0x25	; 37
    6938:	93 e0       	ldi	r25, 0x03	; 3
    693a:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    693e:	0f 2e       	mov	r0, r31
    6940:	fd e2       	ldi	r31, 0x2D	; 45
    6942:	cf 2e       	mov	r12, r31
    6944:	f6 e0       	ldi	r31, 0x06	; 6
    6946:	df 2e       	mov	r13, r31
    6948:	f0 2d       	mov	r31, r0
    694a:	7e 01       	movw	r14, r28
    694c:	8d e0       	ldi	r24, 0x0D	; 13
    694e:	e8 0e       	add	r14, r24
    6950:	f1 1c       	adc	r15, r1
    6952:	00 e0       	ldi	r16, 0x00	; 0
    6954:	10 e0       	ldi	r17, 0x00	; 0
    for (i=0; i< N_AXIS; i++) {
      print_position[i] -= gc_state.coord_system[i]+gc_state.coord_offset[i];
      print_position[i] -= gc_state.tool_table[ gc_state.modal.tool_comp].xyz[i];
    6956:	0f 2e       	mov	r0, r31
    6958:	f7 ec       	ldi	r31, 0xC7	; 199
    695a:	af 2e       	mov	r10, r31
    695c:	f5 e0       	ldi	r31, 0x05	; 5
    695e:	bf 2e       	mov	r11, r31
    6960:	f0 2d       	mov	r31, r0
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printPgmString(PSTR(",WPos:")); 
    for (i=0; i< N_AXIS; i++) {
      print_position[i] -= gc_state.coord_system[i]+gc_state.coord_offset[i];
    6962:	f6 01       	movw	r30, r12
    6964:	61 91       	ld	r22, Z+
    6966:	71 91       	ld	r23, Z+
    6968:	81 91       	ld	r24, Z+
    696a:	91 91       	ld	r25, Z+
    696c:	6f 01       	movw	r12, r30
    696e:	20 85       	ldd	r18, Z+8	; 0x08
    6970:	31 85       	ldd	r19, Z+9	; 0x09
    6972:	42 85       	ldd	r20, Z+10	; 0x0a
    6974:	53 85       	ldd	r21, Z+11	; 0x0b
    6976:	0e 94 83 38 	call	0x7106	; 0x7106 <__addsf3>
    697a:	9b 01       	movw	r18, r22
    697c:	ac 01       	movw	r20, r24
    697e:	f7 01       	movw	r30, r14
    6980:	60 81       	ld	r22, Z
    6982:	71 81       	ldd	r23, Z+1	; 0x01
    6984:	82 81       	ldd	r24, Z+2	; 0x02
    6986:	93 81       	ldd	r25, Z+3	; 0x03
    6988:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
      print_position[i] -= gc_state.tool_table[ gc_state.modal.tool_comp].xyz[i];
    698c:	f5 01       	movw	r30, r10
    698e:	20 81       	ld	r18, Z
    6990:	f8 01       	movw	r30, r16
    6992:	34 e0       	ldi	r19, 0x04	; 4
    6994:	23 9f       	mul	r18, r19
    6996:	e0 0d       	add	r30, r0
    6998:	f1 1d       	adc	r31, r1
    699a:	11 24       	eor	r1, r1
    699c:	ee 0f       	add	r30, r30
    699e:	ff 1f       	adc	r31, r31
    69a0:	ee 0f       	add	r30, r30
    69a2:	ff 1f       	adc	r31, r31
    69a4:	eb 52       	subi	r30, 0x2B	; 43
    69a6:	fa 4f       	sbci	r31, 0xFA	; 250
    69a8:	20 81       	ld	r18, Z
    69aa:	31 81       	ldd	r19, Z+1	; 0x01
    69ac:	42 81       	ldd	r20, Z+2	; 0x02
    69ae:	53 81       	ldd	r21, Z+3	; 0x03
    69b0:	0e 94 82 38 	call	0x7104	; 0x7104 <__subsf3>
    69b4:	f7 01       	movw	r30, r14
    69b6:	61 93       	st	Z+, r22
    69b8:	71 93       	st	Z+, r23
    69ba:	81 93       	st	Z+, r24
    69bc:	91 93       	st	Z+, r25
    69be:	7f 01       	movw	r14, r30

      printFloat_CoordValue(print_position[i]);
    69c0:	0e 94 58 2f 	call	0x5eb0	; 0x5eb0 <printFloat_CoordValue>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    69c4:	02 30       	cpi	r16, 0x02	; 2
    69c6:	20 f4       	brcc	.+8      	; 0x69d0 <report_realtime_status+0x1ac>
    69c8:	83 e2       	ldi	r24, 0x23	; 35
    69ca:	93 e0       	ldi	r25, 0x03	; 3
    69cc:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    69d0:	0f 5f       	subi	r16, 0xFF	; 255
    69d2:	1f 4f       	sbci	r17, 0xFF	; 255
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printPgmString(PSTR(",WPos:")); 
    for (i=0; i< N_AXIS; i++) {
    69d4:	03 30       	cpi	r16, 0x03	; 3
    69d6:	11 05       	cpc	r17, r1
    69d8:	21 f6       	brne	.-120    	; 0x6962 <report_realtime_status+0x13e>
      if (i < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
        
  // Returns the number of active blocks are in the planner buffer.
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_PLANNER_BUFFER)) {
    69da:	80 91 74 07 	lds	r24, 0x0774
    69de:	82 ff       	sbrs	r24, 2
    69e0:	08 c0       	rjmp	.+16     	; 0x69f2 <report_realtime_status+0x1ce>
    printPgmString(PSTR(",Buf:"));
    69e2:	8d e1       	ldi	r24, 0x1D	; 29
    69e4:	93 e0       	ldi	r25, 0x03	; 3
    69e6:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    print_uint8_base10(plan_get_block_buffer_count());
    69ea:	0e 94 06 2a 	call	0x540c	; 0x540c <plan_get_block_buffer_count>
    69ee:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
  }

  // Report serial read buffer status
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_SERIAL_RX)) {
    69f2:	80 91 74 07 	lds	r24, 0x0774
    69f6:	83 ff       	sbrs	r24, 3
    69f8:	08 c0       	rjmp	.+16     	; 0x6a0a <report_realtime_status+0x1e6>
    printPgmString(PSTR(",RX:"));
    69fa:	88 e1       	ldi	r24, 0x18	; 24
    69fc:	93 e0       	ldi	r25, 0x03	; 3
    69fe:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
    print_uint8_base10(serial_get_rx_buffer_count());
    6a02:	0e 94 6d 15 	call	0x2ada	; 0x2ada <serial_get_rx_buffer_count>
    6a06:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <print_uint8_base10>
/*
  printPgmString(PSTR(",RAM:"));
  printInteger( freeRam());
*/

  printPgmString(PSTR(">\r\n"));
    6a0a:	84 e1       	ldi	r24, 0x14	; 20
    6a0c:	93 e0       	ldi	r25, 0x03	; 3
    6a0e:	0e 94 19 2e 	call	0x5c32	; 0x5c32 <printPgmString>
}
    6a12:	68 96       	adiw	r28, 0x18	; 24
    6a14:	0f b6       	in	r0, 0x3f	; 63
    6a16:	f8 94       	cli
    6a18:	de bf       	out	0x3e, r29	; 62
    6a1a:	0f be       	out	0x3f, r0	; 63
    6a1c:	cd bf       	out	0x3d, r28	; 61
    6a1e:	df 91       	pop	r29
    6a20:	cf 91       	pop	r28
    6a22:	1f 91       	pop	r17
    6a24:	0f 91       	pop	r16
    6a26:	ff 90       	pop	r15
    6a28:	ef 90       	pop	r14
    6a2a:	df 90       	pop	r13
    6a2c:	cf 90       	pop	r12
    6a2e:	bf 90       	pop	r11
    6a30:	af 90       	pop	r10
    6a32:	9f 90       	pop	r9
    6a34:	8f 90       	pop	r8
    6a36:	7f 90       	pop	r7
    6a38:	08 95       	ret

00006a3a <system_init>:
#include "print.h"


void system_init() 
{
  PINOUT_DDR &= ~(PINOUT_MASK); // Configure as input pins
    6a3a:	87 b1       	in	r24, 0x07	; 7
    6a3c:	88 7f       	andi	r24, 0xF8	; 248
    6a3e:	87 b9       	out	0x07, r24	; 7
  PINOUT_PORT |= PINOUT_MASK;   // Enable internal pull-up resistors. Normal high operation.
    6a40:	88 b1       	in	r24, 0x08	; 8
    6a42:	87 60       	ori	r24, 0x07	; 7
    6a44:	88 b9       	out	0x08, r24	; 8
  PINOUT_PCMSK |= PINOUT_MASK;  // Enable specific pins of the Pin Change Interrupt
    6a46:	ec e6       	ldi	r30, 0x6C	; 108
    6a48:	f0 e0       	ldi	r31, 0x00	; 0
    6a4a:	80 81       	ld	r24, Z
    6a4c:	87 60       	ori	r24, 0x07	; 7
    6a4e:	80 83       	st	Z, r24
  PCICR |= (1 << PINOUT_INT);   // Enable Pin Change Interrupt
    6a50:	e8 e6       	ldi	r30, 0x68	; 104
    6a52:	f0 e0       	ldi	r31, 0x00	; 0
    6a54:	80 81       	ld	r24, Z
    6a56:	82 60       	ori	r24, 0x02	; 2
    6a58:	80 83       	st	Z, r24
    6a5a:	08 95       	ret

00006a5c <__vector_4>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the runtime command execute variable to have the main program execute these when 
// its ready. This works exactly like the character-based runtime commands when picked off
// directly from the incoming serial data stream.
ISR(PINOUT_INT_vect) 
{
    6a5c:	1f 92       	push	r1
    6a5e:	0f 92       	push	r0
    6a60:	0f b6       	in	r0, 0x3f	; 63
    6a62:	0f 92       	push	r0
    6a64:	11 24       	eor	r1, r1
    6a66:	2f 93       	push	r18
    6a68:	3f 93       	push	r19
    6a6a:	4f 93       	push	r20
    6a6c:	5f 93       	push	r21
    6a6e:	6f 93       	push	r22
    6a70:	7f 93       	push	r23
    6a72:	8f 93       	push	r24
    6a74:	9f 93       	push	r25
    6a76:	af 93       	push	r26
    6a78:	bf 93       	push	r27
    6a7a:	ef 93       	push	r30
    6a7c:	ff 93       	push	r31
  // Enter only if any pinout pin is actively low.
  if ((PINOUT_PIN & PINOUT_MASK) ^ PINOUT_MASK) { 
    6a7e:	86 b1       	in	r24, 0x06	; 6
    6a80:	90 e0       	ldi	r25, 0x00	; 0
    6a82:	80 95       	com	r24
    6a84:	90 95       	com	r25
    6a86:	87 70       	andi	r24, 0x07	; 7
    6a88:	99 27       	eor	r25, r25
    6a8a:	89 2b       	or	r24, r25
    6a8c:	d1 f0       	breq	.+52     	; 0x6ac2 <__vector_4+0x66>
    if (bit_isfalse(PINOUT_PIN,bit(PIN_RESET))) {
    6a8e:	30 99       	sbic	0x06, 0	; 6
    6a90:	03 c0       	rjmp	.+6      	; 0x6a98 <__vector_4+0x3c>
      mc_reset();
    6a92:	0e 94 d6 09 	call	0x13ac	; 0x13ac <mc_reset>
    6a96:	15 c0       	rjmp	.+42     	; 0x6ac2 <__vector_4+0x66>
    } else if (bit_isfalse(PINOUT_PIN,bit(PIN_FEED_HOLD))) {
    6a98:	31 99       	sbic	0x06, 1	; 6
    6a9a:	09 c0       	rjmp	.+18     	; 0x6aae <__vector_4+0x52>
      bit_true_atomic(sys.execute, EXEC_FEED_HOLD);
    6a9c:	8f b7       	in	r24, 0x3f	; 63
    6a9e:	f8 94       	cli
    6aa0:	e5 e8       	ldi	r30, 0x85	; 133
    6aa2:	f5 e0       	ldi	r31, 0x05	; 5
    6aa4:	90 81       	ld	r25, Z
    6aa6:	98 60       	ori	r25, 0x08	; 8
    6aa8:	90 83       	st	Z, r25
    6aaa:	8f bf       	out	0x3f, r24	; 63
    6aac:	0a c0       	rjmp	.+20     	; 0x6ac2 <__vector_4+0x66>
    } else if (bit_isfalse(PINOUT_PIN,bit(PIN_CYCLE_START))) {
    6aae:	32 99       	sbic	0x06, 2	; 6
    6ab0:	08 c0       	rjmp	.+16     	; 0x6ac2 <__vector_4+0x66>
      bit_true_atomic(sys.execute, EXEC_CYCLE_START);
    6ab2:	8f b7       	in	r24, 0x3f	; 63
    6ab4:	f8 94       	cli
    6ab6:	e5 e8       	ldi	r30, 0x85	; 133
    6ab8:	f5 e0       	ldi	r31, 0x05	; 5
    6aba:	90 81       	ld	r25, Z
    6abc:	92 60       	ori	r25, 0x02	; 2
    6abe:	90 83       	st	Z, r25
    6ac0:	8f bf       	out	0x3f, r24	; 63
    } 
  }
}
    6ac2:	ff 91       	pop	r31
    6ac4:	ef 91       	pop	r30
    6ac6:	bf 91       	pop	r27
    6ac8:	af 91       	pop	r26
    6aca:	9f 91       	pop	r25
    6acc:	8f 91       	pop	r24
    6ace:	7f 91       	pop	r23
    6ad0:	6f 91       	pop	r22
    6ad2:	5f 91       	pop	r21
    6ad4:	4f 91       	pop	r20
    6ad6:	3f 91       	pop	r19
    6ad8:	2f 91       	pop	r18
    6ada:	0f 90       	pop	r0
    6adc:	0f be       	out	0x3f, r0	; 63
    6ade:	0f 90       	pop	r0
    6ae0:	1f 90       	pop	r1
    6ae2:	18 95       	reti

00006ae4 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
    6ae4:	1f 93       	push	r17
    6ae6:	cf 93       	push	r28
    6ae8:	df 93       	push	r29
    6aea:	ec 01       	movw	r28, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    6aec:	10 e0       	ldi	r17, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    6aee:	be 01       	movw	r22, r28
    6af0:	81 2f       	mov	r24, r17
    6af2:	0e 94 3b 23 	call	0x4676	; 0x4676 <settings_read_startup_line>
    6af6:	81 11       	cpse	r24, r1
    6af8:	04 c0       	rjmp	.+8      	; 0x6b02 <system_execute_startup+0x1e>
      report_status_message(STATUS_SETTING_READ_FAIL);
    6afa:	87 e0       	ldi	r24, 0x07	; 7
    6afc:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    6b00:	0b c0       	rjmp	.+22     	; 0x6b18 <system_execute_startup+0x34>
    } else {
      if (line[0] != 0) {
    6b02:	88 81       	ld	r24, Y
    6b04:	88 23       	and	r24, r24
    6b06:	41 f0       	breq	.+16     	; 0x6b18 <system_execute_startup+0x34>
        printString(line); // Echo startup line to indicate execution.
    6b08:	ce 01       	movw	r24, r28
    6b0a:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <printString>
        report_status_message(gc_execute_line(line));
    6b0e:	ce 01       	movw	r24, r28
    6b10:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <gc_execute_line>
    6b14:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    6b18:	1f 5f       	subi	r17, 0xFF	; 255
    6b1a:	12 30       	cpi	r17, 0x02	; 2
    6b1c:	41 f7       	brne	.-48     	; 0x6aee <system_execute_startup+0xa>
        printString(line); // Echo startup line to indicate execution.
        report_status_message(gc_execute_line(line));
      }
    } 
  }  
}
    6b1e:	df 91       	pop	r29
    6b20:	cf 91       	pop	r28
    6b22:	1f 91       	pop	r17
    6b24:	08 95       	ret

00006b26 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle, 
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
    6b26:	cf 92       	push	r12
    6b28:	df 92       	push	r13
    6b2a:	ef 92       	push	r14
    6b2c:	ff 92       	push	r15
    6b2e:	1f 93       	push	r17
    6b30:	cf 93       	push	r28
    6b32:	df 93       	push	r29
    6b34:	cd b7       	in	r28, 0x3d	; 61
    6b36:	de b7       	in	r29, 0x3e	; 62
    6b38:	29 97       	sbiw	r28, 0x09	; 9
    6b3a:	0f b6       	in	r0, 0x3f	; 63
    6b3c:	f8 94       	cli
    6b3e:	de bf       	out	0x3e, r29	; 62
    6b40:	0f be       	out	0x3f, r0	; 63
    6b42:	cd bf       	out	0x3d, r28	; 61
    6b44:	7c 01       	movw	r14, r24
  uint8_t char_counter = 1; 
    6b46:	81 e0       	ldi	r24, 0x01	; 1
    6b48:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    6b4a:	f7 01       	movw	r30, r14
    6b4c:	81 81       	ldd	r24, Z+1	; 0x01
    6b4e:	83 34       	cpi	r24, 0x43	; 67
    6b50:	b9 f0       	breq	.+46     	; 0x6b80 <system_execute_line+0x5a>
    6b52:	18 f4       	brcc	.+6      	; 0x6b5a <system_execute_line+0x34>
    6b54:	88 23       	and	r24, r24
    6b56:	31 f0       	breq	.+12     	; 0x6b64 <system_execute_line+0x3e>
    6b58:	40 c0       	rjmp	.+128    	; 0x6bda <system_execute_line+0xb4>
    6b5a:	87 34       	cpi	r24, 0x47	; 71
    6b5c:	39 f0       	breq	.+14     	; 0x6b6c <system_execute_line+0x46>
    6b5e:	88 35       	cpi	r24, 0x58	; 88
    6b60:	51 f1       	breq	.+84     	; 0x6bb6 <system_execute_line+0x90>
    6b62:	3b c0       	rjmp	.+118    	; 0x6bda <system_execute_line+0xb4>
    case 0 : report_grbl_help(); break;
    6b64:	0e 94 74 30 	call	0x60e8	; 0x60e8 <report_grbl_help>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6b68:	80 e0       	ldi	r24, 0x00	; 0
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    6b6a:	39 c1       	rjmp	.+626    	; 0x6dde <system_execute_line+0x2b8>
    case 'G' : // Prints gcode parser state
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6b6c:	82 e0       	ldi	r24, 0x02	; 2
    6b6e:	89 83       	std	Y+1, r24	; 0x01
    6b70:	f7 01       	movw	r30, r14
    6b72:	82 81       	ldd	r24, Z+2	; 0x02
    6b74:	81 11       	cpse	r24, r1
    6b76:	11 c1       	rjmp	.+546    	; 0x6d9a <system_execute_line+0x274>
      else { report_gcode_modes(); }
    6b78:	0e 94 0d 33 	call	0x661a	; 0x661a <report_gcode_modes>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6b7c:	80 e0       	ldi	r24, 0x00	; 0
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case 'G' : // Prints gcode parser state
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      else { report_gcode_modes(); }
      break;   
    6b7e:	2f c1       	rjmp	.+606    	; 0x6dde <system_execute_line+0x2b8>
    case 'C' : // Set check g-code mode [IDLE/CHECK]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6b80:	82 e0       	ldi	r24, 0x02	; 2
    6b82:	89 83       	std	Y+1, r24	; 0x01
    6b84:	f7 01       	movw	r30, r14
    6b86:	82 81       	ldd	r24, Z+2	; 0x02
    6b88:	81 11       	cpse	r24, r1
    6b8a:	09 c1       	rjmp	.+530    	; 0x6d9e <system_execute_line+0x278>
      // Perform reset when toggling off. Check g-code mode should only work if Grbl
      // is idle and ready, regardless of alarm locks. This is mainly to keep things
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
    6b8c:	80 91 84 05 	lds	r24, 0x0584
    6b90:	82 30       	cpi	r24, 0x02	; 2
    6b92:	39 f4       	brne	.+14     	; 0x6ba2 <system_execute_line+0x7c>
        mc_reset(); 
    6b94:	0e 94 d6 09 	call	0x13ac	; 0x13ac <mc_reset>
        report_feedback_message(MESSAGE_DISABLED);
    6b98:	85 e0       	ldi	r24, 0x05	; 5
    6b9a:	0e 94 3e 30 	call	0x607c	; 0x607c <report_feedback_message>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6b9e:	80 e0       	ldi	r24, 0x00	; 0
    6ba0:	1e c1       	rjmp	.+572    	; 0x6dde <system_execute_line+0x2b8>
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
        mc_reset(); 
        report_feedback_message(MESSAGE_DISABLED);
      } else {
        if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    6ba2:	81 11       	cpse	r24, r1
    6ba4:	fe c0       	rjmp	.+508    	; 0x6da2 <system_execute_line+0x27c>
        sys.state = STATE_CHECK_MODE;
    6ba6:	82 e0       	ldi	r24, 0x02	; 2
    6ba8:	80 93 84 05 	sts	0x0584, r24
        report_feedback_message(MESSAGE_ENABLED);
    6bac:	84 e0       	ldi	r24, 0x04	; 4
    6bae:	0e 94 3e 30 	call	0x607c	; 0x607c <report_feedback_message>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6bb2:	80 e0       	ldi	r24, 0x00	; 0
    6bb4:	14 c1       	rjmp	.+552    	; 0x6dde <system_execute_line+0x2b8>
        sys.state = STATE_CHECK_MODE;
        report_feedback_message(MESSAGE_ENABLED);
      }
      break; 
    case 'X' : // Disable alarm lock [ALARM]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6bb6:	82 e0       	ldi	r24, 0x02	; 2
    6bb8:	89 83       	std	Y+1, r24	; 0x01
    6bba:	f7 01       	movw	r30, r14
    6bbc:	82 81       	ldd	r24, Z+2	; 0x02
    6bbe:	81 11       	cpse	r24, r1
    6bc0:	f2 c0       	rjmp	.+484    	; 0x6da6 <system_execute_line+0x280>
      if (sys.state == STATE_ALARM) { 
    6bc2:	80 91 84 05 	lds	r24, 0x0584
    6bc6:	81 30       	cpi	r24, 0x01	; 1
    6bc8:	09 f0       	breq	.+2      	; 0x6bcc <system_execute_line+0xa6>
    6bca:	ef c0       	rjmp	.+478    	; 0x6daa <system_execute_line+0x284>
        report_feedback_message(MESSAGE_ALARM_UNLOCK);
    6bcc:	83 e0       	ldi	r24, 0x03	; 3
    6bce:	0e 94 3e 30 	call	0x607c	; 0x607c <report_feedback_message>
        sys.state = STATE_IDLE;
    6bd2:	10 92 84 05 	sts	0x0584, r1
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6bd6:	80 e0       	ldi	r24, 0x00	; 0
    6bd8:	02 c1       	rjmp	.+516    	; 0x6dde <system_execute_line+0x2b8>
    // handled by the planner. It would be possible for the jog subprogram to insert blocks into the
    // block buffer without having the planner plan them. It would need to manage de/ac-celerations 
    // on its own carefully. This approach could be effective and possibly size/memory efficient.        
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    6bda:	90 91 84 05 	lds	r25, 0x0584
    6bde:	92 30       	cpi	r25, 0x02	; 2
    6be0:	08 f0       	brcs	.+2      	; 0x6be4 <system_execute_line+0xbe>
    6be2:	e5 c0       	rjmp	.+458    	; 0x6dae <system_execute_line+0x288>
      switch( line[char_counter] ) {
    6be4:	88 34       	cpi	r24, 0x48	; 72
    6be6:	01 f1       	breq	.+64     	; 0x6c28 <system_execute_line+0x102>
    6be8:	28 f4       	brcc	.+10     	; 0x6bf4 <system_execute_line+0xce>
    6bea:	83 32       	cpi	r24, 0x23	; 35
    6bec:	99 f0       	breq	.+38     	; 0x6c14 <system_execute_line+0xee>
    6bee:	84 32       	cpi	r24, 0x24	; 36
    6bf0:	39 f0       	breq	.+14     	; 0x6c00 <system_execute_line+0xda>
    6bf2:	70 c0       	rjmp	.+224    	; 0x6cd4 <system_execute_line+0x1ae>
    6bf4:	89 34       	cpi	r24, 0x49	; 73
    6bf6:	39 f1       	breq	.+78     	; 0x6c46 <system_execute_line+0x120>
    6bf8:	8e 34       	cpi	r24, 0x4E	; 78
    6bfa:	09 f4       	brne	.+2      	; 0x6bfe <system_execute_line+0xd8>
    6bfc:	4e c0       	rjmp	.+156    	; 0x6c9a <system_execute_line+0x174>
    6bfe:	6a c0       	rjmp	.+212    	; 0x6cd4 <system_execute_line+0x1ae>
        case '$' : // Prints Grbl settings [IDLE/ALARM]
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6c00:	82 e0       	ldi	r24, 0x02	; 2
    6c02:	89 83       	std	Y+1, r24	; 0x01
    6c04:	f7 01       	movw	r30, r14
    6c06:	82 81       	ldd	r24, Z+2	; 0x02
    6c08:	81 11       	cpse	r24, r1
    6c0a:	d3 c0       	rjmp	.+422    	; 0x6db2 <system_execute_line+0x28c>
          else { report_grbl_settings(); }
    6c0c:	0e 94 79 30 	call	0x60f2	; 0x60f2 <report_grbl_settings>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6c10:	80 e0       	ldi	r24, 0x00	; 0
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[char_counter] ) {
        case '$' : // Prints Grbl settings [IDLE/ALARM]
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_grbl_settings(); }
          break;
    6c12:	e5 c0       	rjmp	.+458    	; 0x6dde <system_execute_line+0x2b8>
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6c14:	82 e0       	ldi	r24, 0x02	; 2
    6c16:	89 83       	std	Y+1, r24	; 0x01
    6c18:	f7 01       	movw	r30, r14
    6c1a:	82 81       	ldd	r24, Z+2	; 0x02
    6c1c:	81 11       	cpse	r24, r1
    6c1e:	cb c0       	rjmp	.+406    	; 0x6db6 <system_execute_line+0x290>
          else { report_ngc_parameters(); }
    6c20:	0e 94 43 32 	call	0x6486	; 0x6486 <report_ngc_parameters>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6c24:	80 e0       	ldi	r24, 0x00	; 0
          else { report_grbl_settings(); }
          break;
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;          
    6c26:	db c0       	rjmp	.+438    	; 0x6dde <system_execute_line+0x2b8>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
    6c28:	80 91 7d 07 	lds	r24, 0x077D
    6c2c:	84 ff       	sbrs	r24, 4
    6c2e:	c5 c0       	rjmp	.+394    	; 0x6dba <system_execute_line+0x294>
            // Only perform homing if Grbl is idle or lost.
            mc_homing_cycle(); 
    6c30:	0e 94 20 09 	call	0x1240	; 0x1240 <mc_homing_cycle>
            if (!sys.abort) { system_execute_startup(line); } // Execute startup scripts after successful homing.
    6c34:	80 91 83 05 	lds	r24, 0x0583
    6c38:	81 11       	cpse	r24, r1
    6c3a:	c1 c0       	rjmp	.+386    	; 0x6dbe <system_execute_line+0x298>
    6c3c:	c7 01       	movw	r24, r14
    6c3e:	0e 94 72 35 	call	0x6ae4	; 0x6ae4 <system_execute_startup>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6c42:	80 e0       	ldi	r24, 0x00	; 0
    6c44:	cc c0       	rjmp	.+408    	; 0x6dde <system_execute_line+0x2b8>
            mc_homing_cycle(); 
            if (!sys.abort) { system_execute_startup(line); } // Execute startup scripts after successful homing.
          } else { return(STATUS_SETTING_DISABLED); }
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
    6c46:	82 e0       	ldi	r24, 0x02	; 2
    6c48:	89 83       	std	Y+1, r24	; 0x01
    6c4a:	f7 01       	movw	r30, r14
    6c4c:	82 81       	ldd	r24, Z+2	; 0x02
    6c4e:	81 11       	cpse	r24, r1
    6c50:	0f c0       	rjmp	.+30     	; 0x6c70 <system_execute_line+0x14a>
            if (!(settings_read_build_info(line))) {
    6c52:	c7 01       	movw	r24, r14
    6c54:	0e 94 58 23 	call	0x46b0	; 0x46b0 <settings_read_build_info>
    6c58:	81 11       	cpse	r24, r1
    6c5a:	05 c0       	rjmp	.+10     	; 0x6c66 <system_execute_line+0x140>
              report_status_message(STATUS_SETTING_READ_FAIL);
    6c5c:	87 e0       	ldi	r24, 0x07	; 7
    6c5e:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6c62:	80 e0       	ldi	r24, 0x00	; 0
    6c64:	bc c0       	rjmp	.+376    	; 0x6dde <system_execute_line+0x2b8>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            if (!(settings_read_build_info(line))) {
              report_status_message(STATUS_SETTING_READ_FAIL);
            } else {
              report_build_info(line);
    6c66:	c7 01       	movw	r24, r14
    6c68:	0e 94 fa 33 	call	0x67f4	; 0x67f4 <report_build_info>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6c6c:	80 e0       	ldi	r24, 0x00	; 0
    6c6e:	b7 c0       	rjmp	.+366    	; 0x6dde <system_execute_line+0x2b8>
              report_status_message(STATUS_SETTING_READ_FAIL);
            } else {
              report_build_info(line);
            }
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6c70:	8d 33       	cpi	r24, 0x3D	; 61
    6c72:	09 f0       	breq	.+2      	; 0x6c76 <system_execute_line+0x150>
    6c74:	a6 c0       	rjmp	.+332    	; 0x6dc2 <system_execute_line+0x29c>
    6c76:	83 e0       	ldi	r24, 0x03	; 3
            helper_var = char_counter; // Set helper variable as counter to start of user info line.
            do {
              line[char_counter-helper_var] = line[char_counter];
    6c78:	f7 01       	movw	r30, r14
    6c7a:	e8 0f       	add	r30, r24
    6c7c:	f1 1d       	adc	r31, r1
    6c7e:	90 81       	ld	r25, Z
    6c80:	df 01       	movw	r26, r30
    6c82:	13 97       	sbiw	r26, 0x03	; 3
    6c84:	9c 93       	st	X, r25
            } while (line[char_counter++] != 0);
    6c86:	8f 5f       	subi	r24, 0xFF	; 255
    6c88:	90 81       	ld	r25, Z
    6c8a:	91 11       	cpse	r25, r1
    6c8c:	f5 cf       	rjmp	.-22     	; 0x6c78 <system_execute_line+0x152>
    6c8e:	89 83       	std	Y+1, r24	; 0x01
            settings_store_build_info(line);
    6c90:	c7 01       	movw	r24, r14
    6c92:	0e 94 4c 22 	call	0x4498	; 0x4498 <settings_store_build_info>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6c96:	80 e0       	ldi	r24, 0x00	; 0
    6c98:	a2 c0       	rjmp	.+324    	; 0x6dde <system_execute_line+0x2b8>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break;                 
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    6c9a:	82 e0       	ldi	r24, 0x02	; 2
    6c9c:	89 83       	std	Y+1, r24	; 0x01
    6c9e:	f7 01       	movw	r30, r14
    6ca0:	82 81       	ldd	r24, Z+2	; 0x02
    6ca2:	81 11       	cpse	r24, r1
    6ca4:	13 c0       	rjmp	.+38     	; 0x6ccc <system_execute_line+0x1a6>
    6ca6:	10 e0       	ldi	r17, 0x00	; 0
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    6ca8:	b7 01       	movw	r22, r14
    6caa:	81 2f       	mov	r24, r17
    6cac:	0e 94 3b 23 	call	0x4676	; 0x4676 <settings_read_startup_line>
    6cb0:	81 11       	cpse	r24, r1
    6cb2:	04 c0       	rjmp	.+8      	; 0x6cbc <system_execute_line+0x196>
                report_status_message(STATUS_SETTING_READ_FAIL);
    6cb4:	87 e0       	ldi	r24, 0x07	; 7
    6cb6:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <report_status_message>
    6cba:	04 c0       	rjmp	.+8      	; 0x6cc4 <system_execute_line+0x19e>
              } else {
                report_startup_line(helper_var,line);
    6cbc:	b7 01       	movw	r22, r14
    6cbe:	81 2f       	mov	r24, r17
    6cc0:	0e 94 df 33 	call	0x67be	; 0x67be <report_startup_line>
            settings_store_build_info(line);
          }
          break;                 
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    6cc4:	1f 5f       	subi	r17, 0xFF	; 255
    6cc6:	12 30       	cpi	r17, 0x02	; 2
    6cc8:	79 f7       	brne	.-34     	; 0x6ca8 <system_execute_line+0x182>
    6cca:	7d c0       	rjmp	.+250    	; 0x6dc6 <system_execute_line+0x2a0>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    6ccc:	91 11       	cpse	r25, r1
    6cce:	7d c0       	rjmp	.+250    	; 0x6dca <system_execute_line+0x2a4>
            helper_var = true;  // Set helper_var to flag storing method. 
    6cd0:	11 e0       	ldi	r17, 0x01	; 1
    6cd2:	01 c0       	rjmp	.+2      	; 0x6cd6 <system_execute_line+0x1b0>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
    6cd4:	10 e0       	ldi	r17, 0x00	; 0
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6cd6:	ae 01       	movw	r20, r28
    6cd8:	4e 5f       	subi	r20, 0xFE	; 254
    6cda:	5f 4f       	sbci	r21, 0xFF	; 255
    6cdc:	be 01       	movw	r22, r28
    6cde:	6f 5f       	subi	r22, 0xFF	; 255
    6ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    6ce2:	c7 01       	movw	r24, r14
    6ce4:	0e 94 1a 2a 	call	0x5434	; 0x5434 <read_float>
    6ce8:	88 23       	and	r24, r24
    6cea:	09 f4       	brne	.+2      	; 0x6cee <system_execute_line+0x1c8>
    6cec:	70 c0       	rjmp	.+224    	; 0x6dce <system_execute_line+0x2a8>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6cee:	89 81       	ldd	r24, Y+1	; 0x01
    6cf0:	21 e0       	ldi	r18, 0x01	; 1
    6cf2:	28 0f       	add	r18, r24
    6cf4:	29 83       	std	Y+1, r18	; 0x01
    6cf6:	f7 01       	movw	r30, r14
    6cf8:	e8 0f       	add	r30, r24
    6cfa:	f1 1d       	adc	r31, r1
    6cfc:	80 81       	ld	r24, Z
    6cfe:	8d 33       	cpi	r24, 0x3D	; 61
    6d00:	09 f0       	breq	.+2      	; 0x6d04 <system_execute_line+0x1de>
    6d02:	67 c0       	rjmp	.+206    	; 0x6dd2 <system_execute_line+0x2ac>
          if (helper_var) { // Store startup line
    6d04:	11 23       	and	r17, r17
    6d06:	39 f1       	breq	.+78     	; 0x6d56 <system_execute_line+0x230>
    6d08:	42 2f       	mov	r20, r18
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    6d0a:	30 e0       	ldi	r19, 0x00	; 0
    6d0c:	84 2f       	mov	r24, r20
    6d0e:	90 e0       	ldi	r25, 0x00	; 0
    6d10:	f7 01       	movw	r30, r14
    6d12:	e8 0f       	add	r30, r24
    6d14:	f9 1f       	adc	r31, r25
    6d16:	50 81       	ld	r21, Z
    6d18:	82 1b       	sub	r24, r18
    6d1a:	93 0b       	sbc	r25, r19
    6d1c:	d7 01       	movw	r26, r14
    6d1e:	a8 0f       	add	r26, r24
    6d20:	b9 1f       	adc	r27, r25
    6d22:	5c 93       	st	X, r21
            } while (line[char_counter++] != 0);
    6d24:	4f 5f       	subi	r20, 0xFF	; 255
    6d26:	80 81       	ld	r24, Z
    6d28:	81 11       	cpse	r24, r1
    6d2a:	f0 cf       	rjmp	.-32     	; 0x6d0c <system_execute_line+0x1e6>
    6d2c:	49 83       	std	Y+1, r20	; 0x01
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    6d2e:	c7 01       	movw	r24, r14
    6d30:	0e 94 5d 0a 	call	0x14ba	; 0x14ba <gc_execute_line>
    6d34:	18 2f       	mov	r17, r24
            if (helper_var) { return(helper_var); }
    6d36:	81 11       	cpse	r24, r1
    6d38:	4e c0       	rjmp	.+156    	; 0x6dd6 <system_execute_line+0x2b0>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    6d3a:	6a 81       	ldd	r22, Y+2	; 0x02
    6d3c:	7b 81       	ldd	r23, Y+3	; 0x03
    6d3e:	8c 81       	ldd	r24, Y+4	; 0x04
    6d40:	9d 81       	ldd	r25, Y+5	; 0x05
    6d42:	0e 94 68 3c 	call	0x78d0	; 0x78d0 <trunc>
    6d46:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    6d4a:	86 2f       	mov	r24, r22
              settings_store_startup_line(helper_var,line);
    6d4c:	b7 01       	movw	r22, r14
    6d4e:	0e 94 42 22 	call	0x4484	; 0x4484 <settings_store_startup_line>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6d52:	81 2f       	mov	r24, r17
    6d54:	44 c0       	rjmp	.+136    	; 0x6dde <system_execute_line+0x2b8>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6d56:	ae 01       	movw	r20, r28
    6d58:	4a 5f       	subi	r20, 0xFA	; 250
    6d5a:	5f 4f       	sbci	r21, 0xFF	; 255
    6d5c:	be 01       	movw	r22, r28
    6d5e:	6f 5f       	subi	r22, 0xFF	; 255
    6d60:	7f 4f       	sbci	r23, 0xFF	; 255
    6d62:	c7 01       	movw	r24, r14
    6d64:	0e 94 1a 2a 	call	0x5434	; 0x5434 <read_float>
    6d68:	88 23       	and	r24, r24
    6d6a:	b1 f1       	breq	.+108    	; 0x6dd8 <system_execute_line+0x2b2>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
    6d6c:	89 81       	ldd	r24, Y+1	; 0x01
    6d6e:	f7 01       	movw	r30, r14
    6d70:	e8 0f       	add	r30, r24
    6d72:	f1 1d       	adc	r31, r1
    6d74:	80 81       	ld	r24, Z
    6d76:	81 11       	cpse	r24, r1
    6d78:	31 c0       	rjmp	.+98     	; 0x6ddc <system_execute_line+0x2b6>
            return(settings_store_global_setting((uint8_t)parameter, value));
    6d7a:	ce 80       	ldd	r12, Y+6	; 0x06
    6d7c:	df 80       	ldd	r13, Y+7	; 0x07
    6d7e:	e8 84       	ldd	r14, Y+8	; 0x08
    6d80:	f9 84       	ldd	r15, Y+9	; 0x09
    6d82:	6a 81       	ldd	r22, Y+2	; 0x02
    6d84:	7b 81       	ldd	r23, Y+3	; 0x03
    6d86:	8c 81       	ldd	r24, Y+4	; 0x04
    6d88:	9d 81       	ldd	r25, Y+5	; 0x05
    6d8a:	0e 94 d0 39 	call	0x73a0	; 0x73a0 <__fixunssfsi>
    6d8e:	86 2f       	mov	r24, r22
    6d90:	b7 01       	movw	r22, r14
    6d92:	a6 01       	movw	r20, r12
    6d94:	0e 94 c3 23 	call	0x4786	; 0x4786 <settings_store_global_setting>
    6d98:	22 c0       	rjmp	.+68     	; 0x6dde <system_execute_line+0x2b8>
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case 'G' : // Prints gcode parser state
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6d9a:	83 e0       	ldi	r24, 0x03	; 3
    6d9c:	20 c0       	rjmp	.+64     	; 0x6dde <system_execute_line+0x2b8>
      else { report_gcode_modes(); }
      break;   
    case 'C' : // Set check g-code mode [IDLE/CHECK]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6d9e:	83 e0       	ldi	r24, 0x03	; 3
    6da0:	1e c0       	rjmp	.+60     	; 0x6dde <system_execute_line+0x2b8>
      // simple and consistent.
      if ( sys.state == STATE_CHECK_MODE ) { 
        mc_reset(); 
        report_feedback_message(MESSAGE_DISABLED);
      } else {
        if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    6da2:	88 e0       	ldi	r24, 0x08	; 8
    6da4:	1c c0       	rjmp	.+56     	; 0x6dde <system_execute_line+0x2b8>
        sys.state = STATE_CHECK_MODE;
        report_feedback_message(MESSAGE_ENABLED);
      }
      break; 
    case 'X' : // Disable alarm lock [ALARM]
      if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6da6:	83 e0       	ldi	r24, 0x03	; 3
    6da8:	1a c0       	rjmp	.+52     	; 0x6dde <system_execute_line+0x2b8>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6daa:	80 e0       	ldi	r24, 0x00	; 0
    6dac:	18 c0       	rjmp	.+48     	; 0x6dde <system_execute_line+0x2b8>
    // handled by the planner. It would be possible for the jog subprogram to insert blocks into the
    // block buffer without having the planner plan them. It would need to manage de/ac-celerations 
    // on its own carefully. This approach could be effective and possibly size/memory efficient.        
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    6dae:	88 e0       	ldi	r24, 0x08	; 8
    6db0:	16 c0       	rjmp	.+44     	; 0x6dde <system_execute_line+0x2b8>
      switch( line[char_counter] ) {
        case '$' : // Prints Grbl settings [IDLE/ALARM]
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6db2:	83 e0       	ldi	r24, 0x03	; 3
    6db4:	14 c0       	rjmp	.+40     	; 0x6dde <system_execute_line+0x2b8>
          else { report_grbl_settings(); }
          break;
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6db6:	83 e0       	ldi	r24, 0x03	; 3
    6db8:	12 c0       	rjmp	.+36     	; 0x6dde <system_execute_line+0x2b8>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
            // Only perform homing if Grbl is idle or lost.
            mc_homing_cycle(); 
            if (!sys.abort) { system_execute_startup(line); } // Execute startup scripts after successful homing.
          } else { return(STATUS_SETTING_DISABLED); }
    6dba:	85 e0       	ldi	r24, 0x05	; 5
    6dbc:	10 c0       	rjmp	.+32     	; 0x6dde <system_execute_line+0x2b8>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6dbe:	80 e0       	ldi	r24, 0x00	; 0
    6dc0:	0e c0       	rjmp	.+28     	; 0x6dde <system_execute_line+0x2b8>
              report_status_message(STATUS_SETTING_READ_FAIL);
            } else {
              report_build_info(line);
            }
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6dc2:	83 e0       	ldi	r24, 0x03	; 3
    6dc4:	0c c0       	rjmp	.+24     	; 0x6dde <system_execute_line+0x2b8>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6dc6:	80 e0       	ldi	r24, 0x00	; 0
    6dc8:	0a c0       	rjmp	.+20     	; 0x6dde <system_execute_line+0x2b8>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    6dca:	88 e0       	ldi	r24, 0x08	; 8
    6dcc:	08 c0       	rjmp	.+16     	; 0x6dde <system_execute_line+0x2b8>
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6dce:	82 e0       	ldi	r24, 0x02	; 2
    6dd0:	06 c0       	rjmp	.+12     	; 0x6dde <system_execute_line+0x2b8>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6dd2:	83 e0       	ldi	r24, 0x03	; 3
    6dd4:	04 c0       	rjmp	.+8      	; 0x6dde <system_execute_line+0x2b8>
    6dd6:	03 c0       	rjmp	.+6      	; 0x6dde <system_execute_line+0x2b8>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6dd8:	82 e0       	ldi	r24, 0x02	; 2
    6dda:	01 c0       	rjmp	.+2      	; 0x6dde <system_execute_line+0x2b8>
            if(line[char_counter] != 0) { return(STATUS_INVALID_STATEMENT); }
    6ddc:	83 e0       	ldi	r24, 0x03	; 3
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    6dde:	29 96       	adiw	r28, 0x09	; 9
    6de0:	0f b6       	in	r0, 0x3f	; 63
    6de2:	f8 94       	cli
    6de4:	de bf       	out	0x3e, r29	; 62
    6de6:	0f be       	out	0x3f, r0	; 63
    6de8:	cd bf       	out	0x3d, r28	; 61
    6dea:	df 91       	pop	r29
    6dec:	cf 91       	pop	r28
    6dee:	1f 91       	pop	r17
    6df0:	ff 90       	pop	r15
    6df2:	ef 90       	pop	r14
    6df4:	df 90       	pop	r13
    6df6:	cf 90       	pop	r12
    6df8:	08 95       	ret

00006dfa <status_init>:
volatile uint8_t status_ticks;

void status_init()
{
	// set to output
	STATUS_LED_DDR |= (1<<STATUS_LED_BIT);
    6dfa:	25 9a       	sbi	0x04, 5	; 4
	//STATUS_LED_PORT |= 1<<STATUS_LED_BIT;

	TCCR2B = 0x00;			//Disable Timer2 while we set it up
    6dfc:	e1 eb       	ldi	r30, 0xB1	; 177
    6dfe:	f0 e0       	ldi	r31, 0x00	; 0
    6e00:	10 82       	st	Z, r1

	TCNT2	= 1;
    6e02:	81 e0       	ldi	r24, 0x01	; 1
    6e04:	80 93 b2 00 	sts	0x00B2, r24
	TIFR2   = 0x00;			//Timer2 INT Flag Reg: Clear Timer Overflow Flag
    6e08:	17 ba       	out	0x17, r1	; 23
	TIMSK2  = 1 << TOIE2;	//Timer2 INT Reg: Timer2 Overflow Interrupt Enable
    6e0a:	80 93 70 00 	sts	0x0070, r24

	TCCR2A  = 0x00;			//Timer2 Control Reg A: Normal port operation, Wave Gen Mode normal
    6e0e:	10 92 b0 00 	sts	0x00B0, r1
	TCCR2B  = (1<<CS22) | (1<<CS21) | (1<<CS20);	//0x07;			//Timer2 Control Reg B: Timer Prescaler set to 1024
    6e12:	87 e0       	ldi	r24, 0x07	; 7
    6e14:	80 83       	st	Z, r24

	status_led = 0;
    6e16:	10 92 8f 07 	sts	0x078F, r1
//	status_state = PROGRAM_FLOW_COMPLETED;
	status_ticks = 62;
    6e1a:	8e e3       	ldi	r24, 0x3E	; 62
    6e1c:	80 93 8e 07 	sts	0x078E, r24
    6e20:	08 95       	ret

00006e22 <__vector_9>:
}

//Timer2 Overflow Interrupt Vector, called every 1ms
ISR(TIMER2_OVF_vect) {
    6e22:	1f 92       	push	r1
    6e24:	0f 92       	push	r0
    6e26:	0f b6       	in	r0, 0x3f	; 63
    6e28:	0f 92       	push	r0
    6e2a:	11 24       	eor	r1, r1
    6e2c:	8f 93       	push	r24
    6e2e:	9f 93       	push	r25
    6e30:	af 93       	push	r26
    6e32:	bf 93       	push	r27
    6e34:	ef 93       	push	r30
    6e36:	ff 93       	push	r31

	status_ticks--;
    6e38:	80 91 8e 07 	lds	r24, 0x078E
    6e3c:	81 50       	subi	r24, 0x01	; 1
    6e3e:	80 93 8e 07 	sts	0x078E, r24
	if ( status_ticks == 0) {
    6e42:	80 91 8e 07 	lds	r24, 0x078E
    6e46:	81 11       	cpse	r24, r1
    6e48:	64 c0       	rjmp	.+200    	; 0x6f12 <__vector_9+0xf0>

		if ( status_led) {
    6e4a:	80 91 8f 07 	lds	r24, 0x078F
    6e4e:	88 23       	and	r24, r24
    6e50:	71 f1       	breq	.+92     	; 0x6eae <__vector_9+0x8c>
			switch (sys.state) {
    6e52:	80 91 84 05 	lds	r24, 0x0584
    6e56:	90 e0       	ldi	r25, 0x00	; 0
    6e58:	81 32       	cpi	r24, 0x21	; 33
    6e5a:	91 05       	cpc	r25, r1
    6e5c:	08 f5       	brcc	.+66     	; 0x6ea0 <__vector_9+0x7e>
    6e5e:	fc 01       	movw	r30, r24
    6e60:	ee 5d       	subi	r30, 0xDE	; 222
    6e62:	fe 4f       	sbci	r31, 0xFE	; 254
    6e64:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
			case STATE_IDLE:	status_ticks = 60; break;
    6e68:	8c e3       	ldi	r24, 0x3C	; 60
    6e6a:	80 93 8e 07 	sts	0x078E, r24
    6e6e:	1b c0       	rjmp	.+54     	; 0x6ea6 <__vector_9+0x84>

			case STATE_QUEUED:	status_ticks = 40; break;
    6e70:	88 e2       	ldi	r24, 0x28	; 40
    6e72:	80 93 8e 07 	sts	0x078E, r24
    6e76:	17 c0       	rjmp	.+46     	; 0x6ea6 <__vector_9+0x84>
			case STATE_HOLD:	status_ticks = 20; break;
    6e78:	84 e1       	ldi	r24, 0x14	; 20
    6e7a:	80 93 8e 07 	sts	0x078E, r24
    6e7e:	13 c0       	rjmp	.+38     	; 0x6ea6 <__vector_9+0x84>

			case STATE_CYCLE:	status_ticks = 62; break;
    6e80:	8e e3       	ldi	r24, 0x3E	; 62
    6e82:	80 93 8e 07 	sts	0x078E, r24
    6e86:	0f c0       	rjmp	.+30     	; 0x6ea6 <__vector_9+0x84>

			case STATE_HOMING:	status_ticks = 90; break;
    6e88:	8a e5       	ldi	r24, 0x5A	; 90
    6e8a:	80 93 8e 07 	sts	0x078E, r24
    6e8e:	0b c0       	rjmp	.+22     	; 0x6ea6 <__vector_9+0x84>
			case STATE_ALARM:	status_ticks = 16; break;
    6e90:	80 e1       	ldi	r24, 0x10	; 16
    6e92:	80 93 8e 07 	sts	0x078E, r24
    6e96:	07 c0       	rjmp	.+14     	; 0x6ea6 <__vector_9+0x84>

			case STATE_CHECK_MODE:	status_ticks = 120; break;
    6e98:	88 e7       	ldi	r24, 0x78	; 120
    6e9a:	80 93 8e 07 	sts	0x078E, r24
    6e9e:	03 c0       	rjmp	.+6      	; 0x6ea6 <__vector_9+0x84>
			default: status_ticks = 2;
    6ea0:	82 e0       	ldi	r24, 0x02	; 2
    6ea2:	80 93 8e 07 	sts	0x078E, r24
			}
			STATUS_LED_PORT &= ~(1<<STATUS_LED_BIT);
    6ea6:	2d 98       	cbi	0x05, 5	; 5
			status_led = 0;
    6ea8:	10 92 8f 07 	sts	0x078F, r1
    6eac:	2e c0       	rjmp	.+92     	; 0x6f0a <__vector_9+0xe8>
		} else {
			switch (sys.state) {
    6eae:	80 91 84 05 	lds	r24, 0x0584
    6eb2:	90 e0       	ldi	r25, 0x00	; 0
    6eb4:	81 32       	cpi	r24, 0x21	; 33
    6eb6:	91 05       	cpc	r25, r1
    6eb8:	08 f5       	brcc	.+66     	; 0x6efc <__vector_9+0xda>
    6eba:	fc 01       	movw	r30, r24
    6ebc:	ed 5b       	subi	r30, 0xBD	; 189
    6ebe:	fe 4f       	sbci	r31, 0xFE	; 254
    6ec0:	0c 94 a9 3c 	jmp	0x7952	; 0x7952 <__tablejump2__>
			case STATE_IDLE:	status_ticks = 2; break;
    6ec4:	82 e0       	ldi	r24, 0x02	; 2
    6ec6:	80 93 8e 07 	sts	0x078E, r24
    6eca:	1b c0       	rjmp	.+54     	; 0x6f02 <__vector_9+0xe0>

			case STATE_QUEUED:	status_ticks = 22; break;
    6ecc:	86 e1       	ldi	r24, 0x16	; 22
    6ece:	80 93 8e 07 	sts	0x078E, r24
    6ed2:	17 c0       	rjmp	.+46     	; 0x6f02 <__vector_9+0xe0>
			case STATE_HOLD:	status_ticks = 42; break;
    6ed4:	8a e2       	ldi	r24, 0x2A	; 42
    6ed6:	80 93 8e 07 	sts	0x078E, r24
    6eda:	13 c0       	rjmp	.+38     	; 0x6f02 <__vector_9+0xe0>

			case STATE_CYCLE:	status_ticks = 62; break;
    6edc:	8e e3       	ldi	r24, 0x3E	; 62
    6ede:	80 93 8e 07 	sts	0x078E, r24
    6ee2:	0f c0       	rjmp	.+30     	; 0x6f02 <__vector_9+0xe0>

			case STATE_HOMING:	status_ticks = 24; break;
    6ee4:	88 e1       	ldi	r24, 0x18	; 24
    6ee6:	80 93 8e 07 	sts	0x078E, r24
    6eea:	0b c0       	rjmp	.+22     	; 0x6f02 <__vector_9+0xe0>
			case STATE_ALARM:	status_ticks = 16; break;
    6eec:	80 e1       	ldi	r24, 0x10	; 16
    6eee:	80 93 8e 07 	sts	0x078E, r24
    6ef2:	07 c0       	rjmp	.+14     	; 0x6f02 <__vector_9+0xe0>
			case STATE_CHECK_MODE:	status_ticks = 124; break;
    6ef4:	8c e7       	ldi	r24, 0x7C	; 124
    6ef6:	80 93 8e 07 	sts	0x078E, r24
    6efa:	03 c0       	rjmp	.+6      	; 0x6f02 <__vector_9+0xe0>

			default: status_ticks = 248;
    6efc:	88 ef       	ldi	r24, 0xF8	; 248
    6efe:	80 93 8e 07 	sts	0x078E, r24
			}

			STATUS_LED_PORT |= 1<<STATUS_LED_BIT;
    6f02:	2d 9a       	sbi	0x05, 5	; 5
			status_led = 1;
    6f04:	81 e0       	ldi	r24, 0x01	; 1
    6f06:	80 93 8f 07 	sts	0x078F, r24
		}

		TCNT2 = 1;
    6f0a:	81 e0       	ldi	r24, 0x01	; 1
    6f0c:	80 93 b2 00 	sts	0x00B2, r24
		TIFR2 = 0;
    6f10:	17 ba       	out	0x17, r1	; 23
	}
};
    6f12:	ff 91       	pop	r31
    6f14:	ef 91       	pop	r30
    6f16:	bf 91       	pop	r27
    6f18:	af 91       	pop	r26
    6f1a:	9f 91       	pop	r25
    6f1c:	8f 91       	pop	r24
    6f1e:	0f 90       	pop	r0
    6f20:	0f be       	out	0x3f, r0	; 63
    6f22:	0f 90       	pop	r0
    6f24:	1f 90       	pop	r1
    6f26:	18 95       	reti

00006f28 <TWI_init>:

// initialize the Master TWI, uses included parameters from twim.h
void TWI_init(){
  //SCL_CLOCK and transfer rate set in twim.h
  /* initialize TWI clock: TWPS = 0 => prescaler = 1 */
  TWCR = (TWI_ACK);
    6f28:	85 ec       	ldi	r24, 0xC5	; 197
    6f2a:	80 93 bc 00 	sts	0x00BC, r24
  TWSR = (0<<TWPS1) | (0<<TWPS0);                  /* no prescaler */
    6f2e:	10 92 b9 00 	sts	0x00B9, r1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
    6f32:	8c e0       	ldi	r24, 0x0C	; 12
    6f34:	80 93 b8 00 	sts	0x00B8, r24
  TWI_busy=0;
    6f38:	10 92 a5 05 	sts	0x05A5, r1
    6f3c:	08 95       	ret

00006f3e <TWI_master_start_write>:
}

// master write to slave
void TWI_master_start_write(uint8_t slave_addr, uint16_t write_bytes) {//7 bit slave address, number of bytes to write
    TWI_busy=1;
    6f3e:	91 e0       	ldi	r25, 0x01	; 1
    6f40:	90 93 a5 05 	sts	0x05A5, r25
    if(write_bytes>TWI_BUFFER_MAX){
    6f44:	6b 30       	cpi	r22, 0x0B	; 11
    6f46:	71 05       	cpc	r23, r1
    6f48:	38 f0       	brcs	.+14     	; 0x6f58 <TWI_master_start_write+0x1a>
        TWI_write_bytes=TWI_BUFFER_MAX;
    6f4a:	2a e0       	ldi	r18, 0x0A	; 10
    6f4c:	30 e0       	ldi	r19, 0x00	; 0
    6f4e:	30 93 80 05 	sts	0x0580, r19
    6f52:	20 93 7f 05 	sts	0x057F, r18
    6f56:	04 c0       	rjmp	.+8      	; 0x6f60 <TWI_master_start_write+0x22>
    }else{
        TWI_write_bytes=write_bytes;
    6f58:	70 93 80 05 	sts	0x0580, r23
    6f5c:	60 93 7f 05 	sts	0x057F, r22
    }
    TWI_operation=TWI_OP_WRITE_ONLY;
    6f60:	91 e0       	ldi	r25, 0x01	; 1
    6f62:	90 93 a6 05 	sts	0x05A6, r25
    TWI_master_state = TWI_WRITE_STATE;
    6f66:	90 93 81 05 	sts	0x0581, r25
    TWI_target_slave_addr = slave_addr;
    6f6a:	80 93 a4 05 	sts	0x05A4, r24
    TWCR = TWI_START; // start TWI master mode
    6f6e:	85 ea       	ldi	r24, 0xA5	; 165
    6f70:	80 93 bc 00 	sts	0x00BC, r24
    6f74:	08 95       	ret

00006f76 <__vector_24>:
// Routine to service interrupts from the TWI hardware.
// The most important thing is that this routine runs fast and returns control
// to the hardware asap. 
// See pages 229, 232, 235, and 238 of the ATmega328 datasheed for detailed 
// explaination of the logic below.
ISR(TWI_vect){
    6f76:	1f 92       	push	r1
    6f78:	0f 92       	push	r0
    6f7a:	0f b6       	in	r0, 0x3f	; 63
    6f7c:	0f 92       	push	r0
    6f7e:	11 24       	eor	r1, r1
    6f80:	2f 93       	push	r18
    6f82:	3f 93       	push	r19
    6f84:	8f 93       	push	r24
    6f86:	9f 93       	push	r25
    6f88:	ef 93       	push	r30
    6f8a:	ff 93       	push	r31

    TWI_status = TWSR & TWI_TWSR_status_mask;
    6f8c:	80 91 b9 00 	lds	r24, 0x00B9
    6f90:	88 7f       	andi	r24, 0xF8	; 248
    6f92:	80 93 82 05 	sts	0x0582, r24
    switch(TWI_status){
    6f96:	80 91 82 05 	lds	r24, 0x0582
    6f9a:	88 32       	cpi	r24, 0x28	; 40
    6f9c:	91 f1       	breq	.+100    	; 0x7002 <__vector_24+0x8c>
    6f9e:	40 f4       	brcc	.+16     	; 0x6fb0 <__vector_24+0x3a>
    6fa0:	80 31       	cpi	r24, 0x10	; 16
    6fa2:	81 f0       	breq	.+32     	; 0x6fc4 <__vector_24+0x4e>
    6fa4:	88 31       	cpi	r24, 0x18	; 24
    6fa6:	69 f1       	breq	.+90     	; 0x7002 <__vector_24+0x8c>
    6fa8:	88 30       	cpi	r24, 0x08	; 8
    6faa:	09 f0       	breq	.+2      	; 0x6fae <__vector_24+0x38>
    6fac:	98 c0       	rjmp	.+304    	; 0x70de <__vector_24+0x168>
    6fae:	0a c0       	rjmp	.+20     	; 0x6fc4 <__vector_24+0x4e>
    6fb0:	80 35       	cpi	r24, 0x50	; 80
    6fb2:	09 f4       	brne	.+2      	; 0x6fb6 <__vector_24+0x40>
    6fb4:	57 c0       	rjmp	.+174    	; 0x7064 <__vector_24+0xee>
    6fb6:	88 35       	cpi	r24, 0x58	; 88
    6fb8:	09 f4       	brne	.+2      	; 0x6fbc <__vector_24+0x46>
    6fba:	7a c0       	rjmp	.+244    	; 0x70b0 <__vector_24+0x13a>
    6fbc:	80 34       	cpi	r24, 0x40	; 64
    6fbe:	09 f0       	breq	.+2      	; 0x6fc2 <__vector_24+0x4c>
    6fc0:	8e c0       	rjmp	.+284    	; 0x70de <__vector_24+0x168>
    6fc2:	61 c0       	rjmp	.+194    	; 0x7086 <__vector_24+0x110>
        case TWI_repeated_start_sent:
        case TWI_start_sent:
        	switch(TWI_master_state){
    6fc4:	80 91 81 05 	lds	r24, 0x0581
    6fc8:	81 30       	cpi	r24, 0x01	; 1
    6fca:	19 f0       	breq	.+6      	; 0x6fd2 <__vector_24+0x5c>
    6fcc:	82 30       	cpi	r24, 0x02	; 2
    6fce:	59 f0       	breq	.+22     	; 0x6fe6 <__vector_24+0x70>
    6fd0:	14 c0       	rjmp	.+40     	; 0x6ffa <__vector_24+0x84>
        		case TWI_WRITE_STATE:
        			TWI_buffer_pos=0; // point to 1st byte
    6fd2:	10 92 b2 05 	sts	0x05B2, r1
    6fd6:	10 92 b1 05 	sts	0x05B1, r1
        			TWDR = (TWI_target_slave_addr<<1) | 0x00; // set SLA_W
    6fda:	80 91 a4 05 	lds	r24, 0x05A4
    6fde:	88 0f       	add	r24, r24
    6fe0:	80 93 bb 00 	sts	0x00BB, r24
        		break;
    6fe4:	0a c0       	rjmp	.+20     	; 0x6ffa <__vector_24+0x84>
        		case TWI_READ_STATE:
        			TWI_buffer_pos=0; // point to first byte
    6fe6:	10 92 b2 05 	sts	0x05B2, r1
    6fea:	10 92 b1 05 	sts	0x05B1, r1
        			TWDR = (TWI_target_slave_addr<<1) | 0x01; // set SLA_R
    6fee:	80 91 a4 05 	lds	r24, 0x05A4
    6ff2:	88 0f       	add	r24, r24
    6ff4:	81 60       	ori	r24, 0x01	; 1
    6ff6:	80 93 bb 00 	sts	0x00BB, r24
        		break;
            }
            TWCR = TWI_ACK; // transmit
    6ffa:	85 ec       	ldi	r24, 0xC5	; 197
    6ffc:	80 93 bc 00 	sts	0x00BC, r24
        break;
    7000:	74 c0       	rjmp	.+232    	; 0x70ea <__vector_24+0x174>

        case TWI_SLA_W_sent_ack_received:   
        case TWI_data_sent_ack_received:

            if(TWI_buffer_pos==TWI_write_bytes){
    7002:	20 91 b1 05 	lds	r18, 0x05B1
    7006:	30 91 b2 05 	lds	r19, 0x05B2
    700a:	80 91 7f 05 	lds	r24, 0x057F
    700e:	90 91 80 05 	lds	r25, 0x0580
    7012:	28 17       	cp	r18, r24
    7014:	39 07       	cpc	r19, r25
    7016:	89 f4       	brne	.+34     	; 0x703a <__vector_24+0xc4>
                if(TWI_operation==TWI_OP_WRITE_THEN_READ){
    7018:	80 91 a6 05 	lds	r24, 0x05A6
    701c:	83 30       	cpi	r24, 0x03	; 3
    701e:	39 f4       	brne	.+14     	; 0x702e <__vector_24+0xb8>
                    TWI_master_state=TWI_READ_STATE; // now read from slave
    7020:	82 e0       	ldi	r24, 0x02	; 2
    7022:	80 93 81 05 	sts	0x0581, r24
                    TWCR = TWI_START; // transmit repeated start
    7026:	85 ea       	ldi	r24, 0xA5	; 165
    7028:	80 93 bc 00 	sts	0x00BC, r24
    702c:	5e c0       	rjmp	.+188    	; 0x70ea <__vector_24+0x174>
                }else{
                    TWCR = TWI_STOP; // release the buss
    702e:	85 e9       	ldi	r24, 0x95	; 149
    7030:	80 93 bc 00 	sts	0x00BC, r24

                    // when TWSTO goes low, the stop condition is sent
                    // but this doesn't really matter, because if we start another transfer,
                    // the first interrupt will happen after start has been transmitted
                    // while(TWCR & (1<<TWSTO)); // wait for it
                    TWI_busy=0;
    7034:	10 92 a5 05 	sts	0x05A5, r1
    7038:	58 c0       	rjmp	.+176    	; 0x70ea <__vector_24+0x174>
                }
            }else{ 
                TWDR = TWI_buffer_out[TWI_buffer_pos++]; // load data
    703a:	80 91 b1 05 	lds	r24, 0x05B1
    703e:	90 91 b2 05 	lds	r25, 0x05B2
    7042:	9c 01       	movw	r18, r24
    7044:	2f 5f       	subi	r18, 0xFF	; 255
    7046:	3f 4f       	sbci	r19, 0xFF	; 255
    7048:	30 93 b2 05 	sts	0x05B2, r19
    704c:	20 93 b1 05 	sts	0x05B1, r18
    7050:	fc 01       	movw	r30, r24
    7052:	ed 54       	subi	r30, 0x4D	; 77
    7054:	fa 4f       	sbci	r31, 0xFA	; 250
    7056:	80 81       	ld	r24, Z
    7058:	80 93 bb 00 	sts	0x00BB, r24
                TWCR = TWI_ENABLE; // transmit
    705c:	85 e8       	ldi	r24, 0x85	; 133
    705e:	80 93 bc 00 	sts	0x00BC, r24
    7062:	43 c0       	rjmp	.+134    	; 0x70ea <__vector_24+0x174>
            }
            break;

        case TWI_data_received_ack_returned:
            TWI_buffer_in[TWI_buffer_pos++]=TWDR; // save byte
    7064:	80 91 b1 05 	lds	r24, 0x05B1
    7068:	90 91 b2 05 	lds	r25, 0x05B2
    706c:	9c 01       	movw	r18, r24
    706e:	2f 5f       	subi	r18, 0xFF	; 255
    7070:	3f 4f       	sbci	r19, 0xFF	; 255
    7072:	30 93 b2 05 	sts	0x05B2, r19
    7076:	20 93 b1 05 	sts	0x05B1, r18
    707a:	20 91 bb 00 	lds	r18, 0x00BB
    707e:	fc 01       	movw	r30, r24
    7080:	e9 55       	subi	r30, 0x59	; 89
    7082:	fa 4f       	sbci	r31, 0xFA	; 250
    7084:	20 83       	st	Z, r18

        case TWI_SLA_R_sent_ack_received: 
            if(TWI_buffer_pos==(TWI_read_bytes-1)){
    7086:	20 91 a2 05 	lds	r18, 0x05A2
    708a:	30 91 a3 05 	lds	r19, 0x05A3
    708e:	80 91 b1 05 	lds	r24, 0x05B1
    7092:	90 91 b2 05 	lds	r25, 0x05B2
    7096:	21 50       	subi	r18, 0x01	; 1
    7098:	31 09       	sbc	r19, r1
    709a:	28 17       	cp	r18, r24
    709c:	39 07       	cpc	r19, r25
    709e:	21 f4       	brne	.+8      	; 0x70a8 <__vector_24+0x132>
                TWCR = TWI_NACK; // get last byte then nack
    70a0:	85 e8       	ldi	r24, 0x85	; 133
    70a2:	80 93 bc 00 	sts	0x00BC, r24
    70a6:	21 c0       	rjmp	.+66     	; 0x70ea <__vector_24+0x174>
            }else{
                TWCR = TWI_ACK; // get next byte then ack
    70a8:	85 ec       	ldi	r24, 0xC5	; 197
    70aa:	80 93 bc 00 	sts	0x00BC, r24
    70ae:	1d c0       	rjmp	.+58     	; 0x70ea <__vector_24+0x174>
            }
            break;

        case TWI_data_received_nack_returned:            
            TWI_buffer_in[TWI_buffer_pos++]=TWDR; // save byte
    70b0:	80 91 b1 05 	lds	r24, 0x05B1
    70b4:	90 91 b2 05 	lds	r25, 0x05B2
    70b8:	9c 01       	movw	r18, r24
    70ba:	2f 5f       	subi	r18, 0xFF	; 255
    70bc:	3f 4f       	sbci	r19, 0xFF	; 255
    70be:	30 93 b2 05 	sts	0x05B2, r19
    70c2:	20 93 b1 05 	sts	0x05B1, r18
    70c6:	20 91 bb 00 	lds	r18, 0x00BB
    70ca:	fc 01       	movw	r30, r24
    70cc:	e9 55       	subi	r30, 0x59	; 89
    70ce:	fa 4f       	sbci	r31, 0xFA	; 250
    70d0:	20 83       	st	Z, r18
            TWCR = TWI_STOP; // release the buss
    70d2:	85 e9       	ldi	r24, 0x95	; 149
    70d4:	80 93 bc 00 	sts	0x00BC, r24
            //while(TWCR & (1<<TWSTO)); // wait for it**
            TWI_busy=0;
    70d8:	10 92 a5 05 	sts	0x05A5, r1
            break;
    70dc:	06 c0       	rjmp	.+12     	; 0x70ea <__vector_24+0x174>

        case TWI_data_sent_nack_received:
        case TWI_SLA_R_sent_nack_received:
        case TWI_arbitration_lost:
        default:
            TWCR=TWI_STOP;
    70de:	ec eb       	ldi	r30, 0xBC	; 188
    70e0:	f0 e0       	ldi	r31, 0x00	; 0
    70e2:	85 e9       	ldi	r24, 0x95	; 149
    70e4:	80 83       	st	Z, r24
            // when TWSTO goes low, the stop condition is sent
            // but this doesn't really matter, because if we start another transfer,
            // the first interrupt will happen after start has been transmitted
            // while(TWCR & (1<<TWSTO)); // wait for it***

            TWCR=TWI_START; // try again
    70e6:	85 ea       	ldi	r24, 0xA5	; 165
    70e8:	80 83       	st	Z, r24
            break;
    }
}
    70ea:	ff 91       	pop	r31
    70ec:	ef 91       	pop	r30
    70ee:	9f 91       	pop	r25
    70f0:	8f 91       	pop	r24
    70f2:	3f 91       	pop	r19
    70f4:	2f 91       	pop	r18
    70f6:	0f 90       	pop	r0
    70f8:	0f be       	out	0x3f, r0	; 63
    70fa:	0f 90       	pop	r0
    70fc:	1f 90       	pop	r1
    70fe:	18 95       	reti

00007100 <tools_select>:
{
}


void tools_select( uint8_t index)
{
    7100:	08 95       	ret

00007102 <tools_change>:
  if (sys.state == STATE_CHECK_MODE) { return; }
}


void tools_change()
{
    7102:	08 95       	ret

00007104 <__subsf3>:
    7104:	50 58       	subi	r21, 0x80	; 128

00007106 <__addsf3>:
    7106:	bb 27       	eor	r27, r27
    7108:	aa 27       	eor	r26, r26
    710a:	0e d0       	rcall	.+28     	; 0x7128 <__addsf3x>
    710c:	76 c2       	rjmp	.+1260   	; 0x75fa <__fp_round>
    710e:	3f d2       	rcall	.+1150   	; 0x758e <__fp_pscA>
    7110:	30 f0       	brcs	.+12     	; 0x711e <__addsf3+0x18>
    7112:	44 d2       	rcall	.+1160   	; 0x759c <__fp_pscB>
    7114:	20 f0       	brcs	.+8      	; 0x711e <__addsf3+0x18>
    7116:	31 f4       	brne	.+12     	; 0x7124 <__addsf3+0x1e>
    7118:	9f 3f       	cpi	r25, 0xFF	; 255
    711a:	11 f4       	brne	.+4      	; 0x7120 <__addsf3+0x1a>
    711c:	1e f4       	brtc	.+6      	; 0x7124 <__addsf3+0x1e>
    711e:	0f c2       	rjmp	.+1054   	; 0x753e <__fp_nan>
    7120:	0e f4       	brtc	.+2      	; 0x7124 <__addsf3+0x1e>
    7122:	e0 95       	com	r30
    7124:	e7 fb       	bst	r30, 7
    7126:	dc c1       	rjmp	.+952    	; 0x74e0 <__fp_inf>

00007128 <__addsf3x>:
    7128:	e9 2f       	mov	r30, r25
    712a:	89 d2       	rcall	.+1298   	; 0x763e <__fp_split3>
    712c:	80 f3       	brcs	.-32     	; 0x710e <__addsf3+0x8>
    712e:	ba 17       	cp	r27, r26
    7130:	62 07       	cpc	r22, r18
    7132:	73 07       	cpc	r23, r19
    7134:	84 07       	cpc	r24, r20
    7136:	95 07       	cpc	r25, r21
    7138:	18 f0       	brcs	.+6      	; 0x7140 <__addsf3x+0x18>
    713a:	71 f4       	brne	.+28     	; 0x7158 <__addsf3x+0x30>
    713c:	9e f5       	brtc	.+102    	; 0x71a4 <__addsf3x+0x7c>
    713e:	b8 c2       	rjmp	.+1392   	; 0x76b0 <__fp_zero>
    7140:	0e f4       	brtc	.+2      	; 0x7144 <__addsf3x+0x1c>
    7142:	e0 95       	com	r30
    7144:	0b 2e       	mov	r0, r27
    7146:	ba 2f       	mov	r27, r26
    7148:	a0 2d       	mov	r26, r0
    714a:	0b 01       	movw	r0, r22
    714c:	b9 01       	movw	r22, r18
    714e:	90 01       	movw	r18, r0
    7150:	0c 01       	movw	r0, r24
    7152:	ca 01       	movw	r24, r20
    7154:	a0 01       	movw	r20, r0
    7156:	11 24       	eor	r1, r1
    7158:	ff 27       	eor	r31, r31
    715a:	59 1b       	sub	r21, r25
    715c:	99 f0       	breq	.+38     	; 0x7184 <__addsf3x+0x5c>
    715e:	59 3f       	cpi	r21, 0xF9	; 249
    7160:	50 f4       	brcc	.+20     	; 0x7176 <__addsf3x+0x4e>
    7162:	50 3e       	cpi	r21, 0xE0	; 224
    7164:	68 f1       	brcs	.+90     	; 0x71c0 <__addsf3x+0x98>
    7166:	1a 16       	cp	r1, r26
    7168:	f0 40       	sbci	r31, 0x00	; 0
    716a:	a2 2f       	mov	r26, r18
    716c:	23 2f       	mov	r18, r19
    716e:	34 2f       	mov	r19, r20
    7170:	44 27       	eor	r20, r20
    7172:	58 5f       	subi	r21, 0xF8	; 248
    7174:	f3 cf       	rjmp	.-26     	; 0x715c <__addsf3x+0x34>
    7176:	46 95       	lsr	r20
    7178:	37 95       	ror	r19
    717a:	27 95       	ror	r18
    717c:	a7 95       	ror	r26
    717e:	f0 40       	sbci	r31, 0x00	; 0
    7180:	53 95       	inc	r21
    7182:	c9 f7       	brne	.-14     	; 0x7176 <__addsf3x+0x4e>
    7184:	7e f4       	brtc	.+30     	; 0x71a4 <__addsf3x+0x7c>
    7186:	1f 16       	cp	r1, r31
    7188:	ba 0b       	sbc	r27, r26
    718a:	62 0b       	sbc	r22, r18
    718c:	73 0b       	sbc	r23, r19
    718e:	84 0b       	sbc	r24, r20
    7190:	ba f0       	brmi	.+46     	; 0x71c0 <__addsf3x+0x98>
    7192:	91 50       	subi	r25, 0x01	; 1
    7194:	a1 f0       	breq	.+40     	; 0x71be <__addsf3x+0x96>
    7196:	ff 0f       	add	r31, r31
    7198:	bb 1f       	adc	r27, r27
    719a:	66 1f       	adc	r22, r22
    719c:	77 1f       	adc	r23, r23
    719e:	88 1f       	adc	r24, r24
    71a0:	c2 f7       	brpl	.-16     	; 0x7192 <__addsf3x+0x6a>
    71a2:	0e c0       	rjmp	.+28     	; 0x71c0 <__addsf3x+0x98>
    71a4:	ba 0f       	add	r27, r26
    71a6:	62 1f       	adc	r22, r18
    71a8:	73 1f       	adc	r23, r19
    71aa:	84 1f       	adc	r24, r20
    71ac:	48 f4       	brcc	.+18     	; 0x71c0 <__addsf3x+0x98>
    71ae:	87 95       	ror	r24
    71b0:	77 95       	ror	r23
    71b2:	67 95       	ror	r22
    71b4:	b7 95       	ror	r27
    71b6:	f7 95       	ror	r31
    71b8:	9e 3f       	cpi	r25, 0xFE	; 254
    71ba:	08 f0       	brcs	.+2      	; 0x71be <__addsf3x+0x96>
    71bc:	b3 cf       	rjmp	.-154    	; 0x7124 <__addsf3+0x1e>
    71be:	93 95       	inc	r25
    71c0:	88 0f       	add	r24, r24
    71c2:	08 f0       	brcs	.+2      	; 0x71c6 <__addsf3x+0x9e>
    71c4:	99 27       	eor	r25, r25
    71c6:	ee 0f       	add	r30, r30
    71c8:	97 95       	ror	r25
    71ca:	87 95       	ror	r24
    71cc:	08 95       	ret
    71ce:	df d1       	rcall	.+958    	; 0x758e <__fp_pscA>
    71d0:	58 f0       	brcs	.+22     	; 0x71e8 <__addsf3x+0xc0>
    71d2:	80 e8       	ldi	r24, 0x80	; 128
    71d4:	91 e0       	ldi	r25, 0x01	; 1
    71d6:	09 f4       	brne	.+2      	; 0x71da <__addsf3x+0xb2>
    71d8:	9e ef       	ldi	r25, 0xFE	; 254
    71da:	e0 d1       	rcall	.+960    	; 0x759c <__fp_pscB>
    71dc:	28 f0       	brcs	.+10     	; 0x71e8 <__addsf3x+0xc0>
    71de:	40 e8       	ldi	r20, 0x80	; 128
    71e0:	51 e0       	ldi	r21, 0x01	; 1
    71e2:	59 f4       	brne	.+22     	; 0x71fa <atan2+0xe>
    71e4:	5e ef       	ldi	r21, 0xFE	; 254
    71e6:	09 c0       	rjmp	.+18     	; 0x71fa <atan2+0xe>
    71e8:	aa c1       	rjmp	.+852    	; 0x753e <__fp_nan>
    71ea:	62 c2       	rjmp	.+1220   	; 0x76b0 <__fp_zero>

000071ec <atan2>:
    71ec:	e9 2f       	mov	r30, r25
    71ee:	e0 78       	andi	r30, 0x80	; 128
    71f0:	26 d2       	rcall	.+1100   	; 0x763e <__fp_split3>
    71f2:	68 f3       	brcs	.-38     	; 0x71ce <__addsf3x+0xa6>
    71f4:	09 2e       	mov	r0, r25
    71f6:	05 2a       	or	r0, r21
    71f8:	c1 f3       	breq	.-16     	; 0x71ea <__addsf3x+0xc2>
    71fa:	26 17       	cp	r18, r22
    71fc:	37 07       	cpc	r19, r23
    71fe:	48 07       	cpc	r20, r24
    7200:	59 07       	cpc	r21, r25
    7202:	38 f0       	brcs	.+14     	; 0x7212 <atan2+0x26>
    7204:	0e 2e       	mov	r0, r30
    7206:	07 f8       	bld	r0, 7
    7208:	e0 25       	eor	r30, r0
    720a:	69 f0       	breq	.+26     	; 0x7226 <atan2+0x3a>
    720c:	e0 25       	eor	r30, r0
    720e:	e0 64       	ori	r30, 0x40	; 64
    7210:	0a c0       	rjmp	.+20     	; 0x7226 <atan2+0x3a>
    7212:	ef 63       	ori	r30, 0x3F	; 63
    7214:	07 f8       	bld	r0, 7
    7216:	00 94       	com	r0
    7218:	07 fa       	bst	r0, 7
    721a:	db 01       	movw	r26, r22
    721c:	b9 01       	movw	r22, r18
    721e:	9d 01       	movw	r18, r26
    7220:	dc 01       	movw	r26, r24
    7222:	ca 01       	movw	r24, r20
    7224:	ad 01       	movw	r20, r26
    7226:	ef 93       	push	r30
    7228:	5d d0       	rcall	.+186    	; 0x72e4 <__divsf3_pse>
    722a:	e7 d1       	rcall	.+974    	; 0x75fa <__fp_round>
    722c:	0a d0       	rcall	.+20     	; 0x7242 <atan>
    722e:	5f 91       	pop	r21
    7230:	55 23       	and	r21, r21
    7232:	31 f0       	breq	.+12     	; 0x7240 <atan2+0x54>
    7234:	2b ed       	ldi	r18, 0xDB	; 219
    7236:	3f e0       	ldi	r19, 0x0F	; 15
    7238:	49 e4       	ldi	r20, 0x49	; 73
    723a:	50 fd       	sbrc	r21, 0
    723c:	49 ec       	ldi	r20, 0xC9	; 201
    723e:	63 cf       	rjmp	.-314    	; 0x7106 <__addsf3>
    7240:	08 95       	ret

00007242 <atan>:
    7242:	df 93       	push	r29
    7244:	dd 27       	eor	r29, r29
    7246:	b9 2f       	mov	r27, r25
    7248:	bf 77       	andi	r27, 0x7F	; 127
    724a:	40 e8       	ldi	r20, 0x80	; 128
    724c:	5f e3       	ldi	r21, 0x3F	; 63
    724e:	16 16       	cp	r1, r22
    7250:	17 06       	cpc	r1, r23
    7252:	48 07       	cpc	r20, r24
    7254:	5b 07       	cpc	r21, r27
    7256:	10 f4       	brcc	.+4      	; 0x725c <atan+0x1a>
    7258:	d9 2f       	mov	r29, r25
    725a:	35 d2       	rcall	.+1130   	; 0x76c6 <inverse>
    725c:	9f 93       	push	r25
    725e:	8f 93       	push	r24
    7260:	7f 93       	push	r23
    7262:	6f 93       	push	r22
    7264:	32 d3       	rcall	.+1636   	; 0x78ca <square>
    7266:	e8 ec       	ldi	r30, 0xC8	; 200
    7268:	f2 e0       	ldi	r31, 0x02	; 2
    726a:	6c d1       	rcall	.+728    	; 0x7544 <__fp_powser>
    726c:	c6 d1       	rcall	.+908    	; 0x75fa <__fp_round>
    726e:	2f 91       	pop	r18
    7270:	3f 91       	pop	r19
    7272:	4f 91       	pop	r20
    7274:	5f 91       	pop	r21
    7276:	6a d2       	rcall	.+1236   	; 0x774c <__mulsf3x>
    7278:	dd 23       	and	r29, r29
    727a:	49 f0       	breq	.+18     	; 0x728e <atan+0x4c>
    727c:	90 58       	subi	r25, 0x80	; 128
    727e:	a2 ea       	ldi	r26, 0xA2	; 162
    7280:	2a ed       	ldi	r18, 0xDA	; 218
    7282:	3f e0       	ldi	r19, 0x0F	; 15
    7284:	49 ec       	ldi	r20, 0xC9	; 201
    7286:	5f e3       	ldi	r21, 0x3F	; 63
    7288:	d0 78       	andi	r29, 0x80	; 128
    728a:	5d 27       	eor	r21, r29
    728c:	4d df       	rcall	.-358    	; 0x7128 <__addsf3x>
    728e:	df 91       	pop	r29
    7290:	b4 c1       	rjmp	.+872    	; 0x75fa <__fp_round>

00007292 <ceil>:
    7292:	f7 d1       	rcall	.+1006   	; 0x7682 <__fp_trunc>
    7294:	80 f0       	brcs	.+32     	; 0x72b6 <ceil+0x24>
    7296:	9f 37       	cpi	r25, 0x7F	; 127
    7298:	40 f4       	brcc	.+16     	; 0x72aa <ceil+0x18>
    729a:	91 11       	cpse	r25, r1
    729c:	0e f4       	brtc	.+2      	; 0x72a0 <ceil+0xe>
    729e:	09 c2       	rjmp	.+1042   	; 0x76b2 <__fp_szero>
    72a0:	60 e0       	ldi	r22, 0x00	; 0
    72a2:	70 e0       	ldi	r23, 0x00	; 0
    72a4:	80 e8       	ldi	r24, 0x80	; 128
    72a6:	9f e3       	ldi	r25, 0x3F	; 63
    72a8:	08 95       	ret
    72aa:	26 f0       	brts	.+8      	; 0x72b4 <ceil+0x22>
    72ac:	1b 16       	cp	r1, r27
    72ae:	61 1d       	adc	r22, r1
    72b0:	71 1d       	adc	r23, r1
    72b2:	81 1d       	adc	r24, r1
    72b4:	1b c1       	rjmp	.+566    	; 0x74ec <__fp_mintl>
    72b6:	35 c1       	rjmp	.+618    	; 0x7522 <__fp_mpack>

000072b8 <__cmpsf2>:
    72b8:	ef d0       	rcall	.+478    	; 0x7498 <__fp_cmp>
    72ba:	08 f4       	brcc	.+2      	; 0x72be <__cmpsf2+0x6>
    72bc:	81 e0       	ldi	r24, 0x01	; 1
    72be:	08 95       	ret

000072c0 <cos>:
    72c0:	75 d1       	rcall	.+746    	; 0x75ac <__fp_rempio2>
    72c2:	e3 95       	inc	r30
    72c4:	ab c1       	rjmp	.+854    	; 0x761c <__fp_sinus>

000072c6 <__divsf3>:
    72c6:	0c d0       	rcall	.+24     	; 0x72e0 <__divsf3x>
    72c8:	98 c1       	rjmp	.+816    	; 0x75fa <__fp_round>
    72ca:	68 d1       	rcall	.+720    	; 0x759c <__fp_pscB>
    72cc:	40 f0       	brcs	.+16     	; 0x72de <__divsf3+0x18>
    72ce:	5f d1       	rcall	.+702    	; 0x758e <__fp_pscA>
    72d0:	30 f0       	brcs	.+12     	; 0x72de <__divsf3+0x18>
    72d2:	21 f4       	brne	.+8      	; 0x72dc <__divsf3+0x16>
    72d4:	5f 3f       	cpi	r21, 0xFF	; 255
    72d6:	19 f0       	breq	.+6      	; 0x72de <__divsf3+0x18>
    72d8:	03 c1       	rjmp	.+518    	; 0x74e0 <__fp_inf>
    72da:	51 11       	cpse	r21, r1
    72dc:	ea c1       	rjmp	.+980    	; 0x76b2 <__fp_szero>
    72de:	2f c1       	rjmp	.+606    	; 0x753e <__fp_nan>

000072e0 <__divsf3x>:
    72e0:	ae d1       	rcall	.+860    	; 0x763e <__fp_split3>
    72e2:	98 f3       	brcs	.-26     	; 0x72ca <__divsf3+0x4>

000072e4 <__divsf3_pse>:
    72e4:	99 23       	and	r25, r25
    72e6:	c9 f3       	breq	.-14     	; 0x72da <__divsf3+0x14>
    72e8:	55 23       	and	r21, r21
    72ea:	b1 f3       	breq	.-20     	; 0x72d8 <__divsf3+0x12>
    72ec:	95 1b       	sub	r25, r21
    72ee:	55 0b       	sbc	r21, r21
    72f0:	bb 27       	eor	r27, r27
    72f2:	aa 27       	eor	r26, r26
    72f4:	62 17       	cp	r22, r18
    72f6:	73 07       	cpc	r23, r19
    72f8:	84 07       	cpc	r24, r20
    72fa:	38 f0       	brcs	.+14     	; 0x730a <__divsf3_pse+0x26>
    72fc:	9f 5f       	subi	r25, 0xFF	; 255
    72fe:	5f 4f       	sbci	r21, 0xFF	; 255
    7300:	22 0f       	add	r18, r18
    7302:	33 1f       	adc	r19, r19
    7304:	44 1f       	adc	r20, r20
    7306:	aa 1f       	adc	r26, r26
    7308:	a9 f3       	breq	.-22     	; 0x72f4 <__divsf3_pse+0x10>
    730a:	33 d0       	rcall	.+102    	; 0x7372 <__divsf3_pse+0x8e>
    730c:	0e 2e       	mov	r0, r30
    730e:	3a f0       	brmi	.+14     	; 0x731e <__divsf3_pse+0x3a>
    7310:	e0 e8       	ldi	r30, 0x80	; 128
    7312:	30 d0       	rcall	.+96     	; 0x7374 <__divsf3_pse+0x90>
    7314:	91 50       	subi	r25, 0x01	; 1
    7316:	50 40       	sbci	r21, 0x00	; 0
    7318:	e6 95       	lsr	r30
    731a:	00 1c       	adc	r0, r0
    731c:	ca f7       	brpl	.-14     	; 0x7310 <__divsf3_pse+0x2c>
    731e:	29 d0       	rcall	.+82     	; 0x7372 <__divsf3_pse+0x8e>
    7320:	fe 2f       	mov	r31, r30
    7322:	27 d0       	rcall	.+78     	; 0x7372 <__divsf3_pse+0x8e>
    7324:	66 0f       	add	r22, r22
    7326:	77 1f       	adc	r23, r23
    7328:	88 1f       	adc	r24, r24
    732a:	bb 1f       	adc	r27, r27
    732c:	26 17       	cp	r18, r22
    732e:	37 07       	cpc	r19, r23
    7330:	48 07       	cpc	r20, r24
    7332:	ab 07       	cpc	r26, r27
    7334:	b0 e8       	ldi	r27, 0x80	; 128
    7336:	09 f0       	breq	.+2      	; 0x733a <__divsf3_pse+0x56>
    7338:	bb 0b       	sbc	r27, r27
    733a:	80 2d       	mov	r24, r0
    733c:	bf 01       	movw	r22, r30
    733e:	ff 27       	eor	r31, r31
    7340:	93 58       	subi	r25, 0x83	; 131
    7342:	5f 4f       	sbci	r21, 0xFF	; 255
    7344:	2a f0       	brmi	.+10     	; 0x7350 <__divsf3_pse+0x6c>
    7346:	9e 3f       	cpi	r25, 0xFE	; 254
    7348:	51 05       	cpc	r21, r1
    734a:	68 f0       	brcs	.+26     	; 0x7366 <__divsf3_pse+0x82>
    734c:	c9 c0       	rjmp	.+402    	; 0x74e0 <__fp_inf>
    734e:	b1 c1       	rjmp	.+866    	; 0x76b2 <__fp_szero>
    7350:	5f 3f       	cpi	r21, 0xFF	; 255
    7352:	ec f3       	brlt	.-6      	; 0x734e <__divsf3_pse+0x6a>
    7354:	98 3e       	cpi	r25, 0xE8	; 232
    7356:	dc f3       	brlt	.-10     	; 0x734e <__divsf3_pse+0x6a>
    7358:	86 95       	lsr	r24
    735a:	77 95       	ror	r23
    735c:	67 95       	ror	r22
    735e:	b7 95       	ror	r27
    7360:	f7 95       	ror	r31
    7362:	9f 5f       	subi	r25, 0xFF	; 255
    7364:	c9 f7       	brne	.-14     	; 0x7358 <__divsf3_pse+0x74>
    7366:	88 0f       	add	r24, r24
    7368:	91 1d       	adc	r25, r1
    736a:	96 95       	lsr	r25
    736c:	87 95       	ror	r24
    736e:	97 f9       	bld	r25, 7
    7370:	08 95       	ret
    7372:	e1 e0       	ldi	r30, 0x01	; 1
    7374:	66 0f       	add	r22, r22
    7376:	77 1f       	adc	r23, r23
    7378:	88 1f       	adc	r24, r24
    737a:	bb 1f       	adc	r27, r27
    737c:	62 17       	cp	r22, r18
    737e:	73 07       	cpc	r23, r19
    7380:	84 07       	cpc	r24, r20
    7382:	ba 07       	cpc	r27, r26
    7384:	20 f0       	brcs	.+8      	; 0x738e <__divsf3_pse+0xaa>
    7386:	62 1b       	sub	r22, r18
    7388:	73 0b       	sbc	r23, r19
    738a:	84 0b       	sbc	r24, r20
    738c:	ba 0b       	sbc	r27, r26
    738e:	ee 1f       	adc	r30, r30
    7390:	88 f7       	brcc	.-30     	; 0x7374 <__divsf3_pse+0x90>
    7392:	e0 95       	com	r30
    7394:	08 95       	ret

00007396 <__fixsfsi>:
    7396:	04 d0       	rcall	.+8      	; 0x73a0 <__fixunssfsi>
    7398:	68 94       	set
    739a:	b1 11       	cpse	r27, r1
    739c:	8a c1       	rjmp	.+788    	; 0x76b2 <__fp_szero>
    739e:	08 95       	ret

000073a0 <__fixunssfsi>:
    73a0:	56 d1       	rcall	.+684    	; 0x764e <__fp_splitA>
    73a2:	88 f0       	brcs	.+34     	; 0x73c6 <__fixunssfsi+0x26>
    73a4:	9f 57       	subi	r25, 0x7F	; 127
    73a6:	90 f0       	brcs	.+36     	; 0x73cc <__fixunssfsi+0x2c>
    73a8:	b9 2f       	mov	r27, r25
    73aa:	99 27       	eor	r25, r25
    73ac:	b7 51       	subi	r27, 0x17	; 23
    73ae:	a0 f0       	brcs	.+40     	; 0x73d8 <__fixunssfsi+0x38>
    73b0:	d1 f0       	breq	.+52     	; 0x73e6 <__fixunssfsi+0x46>
    73b2:	66 0f       	add	r22, r22
    73b4:	77 1f       	adc	r23, r23
    73b6:	88 1f       	adc	r24, r24
    73b8:	99 1f       	adc	r25, r25
    73ba:	1a f0       	brmi	.+6      	; 0x73c2 <__fixunssfsi+0x22>
    73bc:	ba 95       	dec	r27
    73be:	c9 f7       	brne	.-14     	; 0x73b2 <__fixunssfsi+0x12>
    73c0:	12 c0       	rjmp	.+36     	; 0x73e6 <__fixunssfsi+0x46>
    73c2:	b1 30       	cpi	r27, 0x01	; 1
    73c4:	81 f0       	breq	.+32     	; 0x73e6 <__fixunssfsi+0x46>
    73c6:	74 d1       	rcall	.+744    	; 0x76b0 <__fp_zero>
    73c8:	b1 e0       	ldi	r27, 0x01	; 1
    73ca:	08 95       	ret
    73cc:	71 c1       	rjmp	.+738    	; 0x76b0 <__fp_zero>
    73ce:	67 2f       	mov	r22, r23
    73d0:	78 2f       	mov	r23, r24
    73d2:	88 27       	eor	r24, r24
    73d4:	b8 5f       	subi	r27, 0xF8	; 248
    73d6:	39 f0       	breq	.+14     	; 0x73e6 <__fixunssfsi+0x46>
    73d8:	b9 3f       	cpi	r27, 0xF9	; 249
    73da:	cc f3       	brlt	.-14     	; 0x73ce <__fixunssfsi+0x2e>
    73dc:	86 95       	lsr	r24
    73de:	77 95       	ror	r23
    73e0:	67 95       	ror	r22
    73e2:	b3 95       	inc	r27
    73e4:	d9 f7       	brne	.-10     	; 0x73dc <__fixunssfsi+0x3c>
    73e6:	3e f4       	brtc	.+14     	; 0x73f6 <__fixunssfsi+0x56>
    73e8:	90 95       	com	r25
    73ea:	80 95       	com	r24
    73ec:	70 95       	com	r23
    73ee:	61 95       	neg	r22
    73f0:	7f 4f       	sbci	r23, 0xFF	; 255
    73f2:	8f 4f       	sbci	r24, 0xFF	; 255
    73f4:	9f 4f       	sbci	r25, 0xFF	; 255
    73f6:	08 95       	ret

000073f8 <__floatunsisf>:
    73f8:	e8 94       	clt
    73fa:	09 c0       	rjmp	.+18     	; 0x740e <__floatsisf+0x12>

000073fc <__floatsisf>:
    73fc:	97 fb       	bst	r25, 7
    73fe:	3e f4       	brtc	.+14     	; 0x740e <__floatsisf+0x12>
    7400:	90 95       	com	r25
    7402:	80 95       	com	r24
    7404:	70 95       	com	r23
    7406:	61 95       	neg	r22
    7408:	7f 4f       	sbci	r23, 0xFF	; 255
    740a:	8f 4f       	sbci	r24, 0xFF	; 255
    740c:	9f 4f       	sbci	r25, 0xFF	; 255
    740e:	99 23       	and	r25, r25
    7410:	a9 f0       	breq	.+42     	; 0x743c <__floatsisf+0x40>
    7412:	f9 2f       	mov	r31, r25
    7414:	96 e9       	ldi	r25, 0x96	; 150
    7416:	bb 27       	eor	r27, r27
    7418:	93 95       	inc	r25
    741a:	f6 95       	lsr	r31
    741c:	87 95       	ror	r24
    741e:	77 95       	ror	r23
    7420:	67 95       	ror	r22
    7422:	b7 95       	ror	r27
    7424:	f1 11       	cpse	r31, r1
    7426:	f8 cf       	rjmp	.-16     	; 0x7418 <__floatsisf+0x1c>
    7428:	fa f4       	brpl	.+62     	; 0x7468 <__floatsisf+0x6c>
    742a:	bb 0f       	add	r27, r27
    742c:	11 f4       	brne	.+4      	; 0x7432 <__floatsisf+0x36>
    742e:	60 ff       	sbrs	r22, 0
    7430:	1b c0       	rjmp	.+54     	; 0x7468 <__floatsisf+0x6c>
    7432:	6f 5f       	subi	r22, 0xFF	; 255
    7434:	7f 4f       	sbci	r23, 0xFF	; 255
    7436:	8f 4f       	sbci	r24, 0xFF	; 255
    7438:	9f 4f       	sbci	r25, 0xFF	; 255
    743a:	16 c0       	rjmp	.+44     	; 0x7468 <__floatsisf+0x6c>
    743c:	88 23       	and	r24, r24
    743e:	11 f0       	breq	.+4      	; 0x7444 <__floatsisf+0x48>
    7440:	96 e9       	ldi	r25, 0x96	; 150
    7442:	11 c0       	rjmp	.+34     	; 0x7466 <__floatsisf+0x6a>
    7444:	77 23       	and	r23, r23
    7446:	21 f0       	breq	.+8      	; 0x7450 <__floatsisf+0x54>
    7448:	9e e8       	ldi	r25, 0x8E	; 142
    744a:	87 2f       	mov	r24, r23
    744c:	76 2f       	mov	r23, r22
    744e:	05 c0       	rjmp	.+10     	; 0x745a <__floatsisf+0x5e>
    7450:	66 23       	and	r22, r22
    7452:	71 f0       	breq	.+28     	; 0x7470 <__floatsisf+0x74>
    7454:	96 e8       	ldi	r25, 0x86	; 134
    7456:	86 2f       	mov	r24, r22
    7458:	70 e0       	ldi	r23, 0x00	; 0
    745a:	60 e0       	ldi	r22, 0x00	; 0
    745c:	2a f0       	brmi	.+10     	; 0x7468 <__floatsisf+0x6c>
    745e:	9a 95       	dec	r25
    7460:	66 0f       	add	r22, r22
    7462:	77 1f       	adc	r23, r23
    7464:	88 1f       	adc	r24, r24
    7466:	da f7       	brpl	.-10     	; 0x745e <__floatsisf+0x62>
    7468:	88 0f       	add	r24, r24
    746a:	96 95       	lsr	r25
    746c:	87 95       	ror	r24
    746e:	97 f9       	bld	r25, 7
    7470:	08 95       	ret

00007472 <floor>:
    7472:	07 d1       	rcall	.+526    	; 0x7682 <__fp_trunc>
    7474:	80 f0       	brcs	.+32     	; 0x7496 <floor+0x24>
    7476:	9f 37       	cpi	r25, 0x7F	; 127
    7478:	40 f4       	brcc	.+16     	; 0x748a <floor+0x18>
    747a:	91 11       	cpse	r25, r1
    747c:	0e f0       	brts	.+2      	; 0x7480 <floor+0xe>
    747e:	19 c1       	rjmp	.+562    	; 0x76b2 <__fp_szero>
    7480:	60 e0       	ldi	r22, 0x00	; 0
    7482:	70 e0       	ldi	r23, 0x00	; 0
    7484:	80 e8       	ldi	r24, 0x80	; 128
    7486:	9f eb       	ldi	r25, 0xBF	; 191
    7488:	08 95       	ret
    748a:	26 f4       	brtc	.+8      	; 0x7494 <floor+0x22>
    748c:	1b 16       	cp	r1, r27
    748e:	61 1d       	adc	r22, r1
    7490:	71 1d       	adc	r23, r1
    7492:	81 1d       	adc	r24, r1
    7494:	2b c0       	rjmp	.+86     	; 0x74ec <__fp_mintl>
    7496:	45 c0       	rjmp	.+138    	; 0x7522 <__fp_mpack>

00007498 <__fp_cmp>:
    7498:	99 0f       	add	r25, r25
    749a:	00 08       	sbc	r0, r0
    749c:	55 0f       	add	r21, r21
    749e:	aa 0b       	sbc	r26, r26
    74a0:	e0 e8       	ldi	r30, 0x80	; 128
    74a2:	fe ef       	ldi	r31, 0xFE	; 254
    74a4:	16 16       	cp	r1, r22
    74a6:	17 06       	cpc	r1, r23
    74a8:	e8 07       	cpc	r30, r24
    74aa:	f9 07       	cpc	r31, r25
    74ac:	c0 f0       	brcs	.+48     	; 0x74de <__fp_cmp+0x46>
    74ae:	12 16       	cp	r1, r18
    74b0:	13 06       	cpc	r1, r19
    74b2:	e4 07       	cpc	r30, r20
    74b4:	f5 07       	cpc	r31, r21
    74b6:	98 f0       	brcs	.+38     	; 0x74de <__fp_cmp+0x46>
    74b8:	62 1b       	sub	r22, r18
    74ba:	73 0b       	sbc	r23, r19
    74bc:	84 0b       	sbc	r24, r20
    74be:	95 0b       	sbc	r25, r21
    74c0:	39 f4       	brne	.+14     	; 0x74d0 <__fp_cmp+0x38>
    74c2:	0a 26       	eor	r0, r26
    74c4:	61 f0       	breq	.+24     	; 0x74de <__fp_cmp+0x46>
    74c6:	23 2b       	or	r18, r19
    74c8:	24 2b       	or	r18, r20
    74ca:	25 2b       	or	r18, r21
    74cc:	21 f4       	brne	.+8      	; 0x74d6 <__fp_cmp+0x3e>
    74ce:	08 95       	ret
    74d0:	0a 26       	eor	r0, r26
    74d2:	09 f4       	brne	.+2      	; 0x74d6 <__fp_cmp+0x3e>
    74d4:	a1 40       	sbci	r26, 0x01	; 1
    74d6:	a6 95       	lsr	r26
    74d8:	8f ef       	ldi	r24, 0xFF	; 255
    74da:	81 1d       	adc	r24, r1
    74dc:	81 1d       	adc	r24, r1
    74de:	08 95       	ret

000074e0 <__fp_inf>:
    74e0:	97 f9       	bld	r25, 7
    74e2:	9f 67       	ori	r25, 0x7F	; 127
    74e4:	80 e8       	ldi	r24, 0x80	; 128
    74e6:	70 e0       	ldi	r23, 0x00	; 0
    74e8:	60 e0       	ldi	r22, 0x00	; 0
    74ea:	08 95       	ret

000074ec <__fp_mintl>:
    74ec:	88 23       	and	r24, r24
    74ee:	71 f4       	brne	.+28     	; 0x750c <__fp_mintl+0x20>
    74f0:	77 23       	and	r23, r23
    74f2:	21 f0       	breq	.+8      	; 0x74fc <__fp_mintl+0x10>
    74f4:	98 50       	subi	r25, 0x08	; 8
    74f6:	87 2b       	or	r24, r23
    74f8:	76 2f       	mov	r23, r22
    74fa:	07 c0       	rjmp	.+14     	; 0x750a <__fp_mintl+0x1e>
    74fc:	66 23       	and	r22, r22
    74fe:	11 f4       	brne	.+4      	; 0x7504 <__fp_mintl+0x18>
    7500:	99 27       	eor	r25, r25
    7502:	0d c0       	rjmp	.+26     	; 0x751e <__fp_mintl+0x32>
    7504:	90 51       	subi	r25, 0x10	; 16
    7506:	86 2b       	or	r24, r22
    7508:	70 e0       	ldi	r23, 0x00	; 0
    750a:	60 e0       	ldi	r22, 0x00	; 0
    750c:	2a f0       	brmi	.+10     	; 0x7518 <__fp_mintl+0x2c>
    750e:	9a 95       	dec	r25
    7510:	66 0f       	add	r22, r22
    7512:	77 1f       	adc	r23, r23
    7514:	88 1f       	adc	r24, r24
    7516:	da f7       	brpl	.-10     	; 0x750e <__fp_mintl+0x22>
    7518:	88 0f       	add	r24, r24
    751a:	96 95       	lsr	r25
    751c:	87 95       	ror	r24
    751e:	97 f9       	bld	r25, 7
    7520:	08 95       	ret

00007522 <__fp_mpack>:
    7522:	9f 3f       	cpi	r25, 0xFF	; 255
    7524:	31 f0       	breq	.+12     	; 0x7532 <__fp_mpack_finite+0xc>

00007526 <__fp_mpack_finite>:
    7526:	91 50       	subi	r25, 0x01	; 1
    7528:	20 f4       	brcc	.+8      	; 0x7532 <__fp_mpack_finite+0xc>
    752a:	87 95       	ror	r24
    752c:	77 95       	ror	r23
    752e:	67 95       	ror	r22
    7530:	b7 95       	ror	r27
    7532:	88 0f       	add	r24, r24
    7534:	91 1d       	adc	r25, r1
    7536:	96 95       	lsr	r25
    7538:	87 95       	ror	r24
    753a:	97 f9       	bld	r25, 7
    753c:	08 95       	ret

0000753e <__fp_nan>:
    753e:	9f ef       	ldi	r25, 0xFF	; 255
    7540:	80 ec       	ldi	r24, 0xC0	; 192
    7542:	08 95       	ret

00007544 <__fp_powser>:
    7544:	df 93       	push	r29
    7546:	cf 93       	push	r28
    7548:	1f 93       	push	r17
    754a:	0f 93       	push	r16
    754c:	ff 92       	push	r15
    754e:	ef 92       	push	r14
    7550:	df 92       	push	r13
    7552:	7b 01       	movw	r14, r22
    7554:	8c 01       	movw	r16, r24
    7556:	68 94       	set
    7558:	05 c0       	rjmp	.+10     	; 0x7564 <__fp_powser+0x20>
    755a:	da 2e       	mov	r13, r26
    755c:	ef 01       	movw	r28, r30
    755e:	f6 d0       	rcall	.+492    	; 0x774c <__mulsf3x>
    7560:	fe 01       	movw	r30, r28
    7562:	e8 94       	clt
    7564:	a5 91       	lpm	r26, Z+
    7566:	25 91       	lpm	r18, Z+
    7568:	35 91       	lpm	r19, Z+
    756a:	45 91       	lpm	r20, Z+
    756c:	55 91       	lpm	r21, Z+
    756e:	ae f3       	brts	.-22     	; 0x755a <__fp_powser+0x16>
    7570:	ef 01       	movw	r28, r30
    7572:	da dd       	rcall	.-1100   	; 0x7128 <__addsf3x>
    7574:	fe 01       	movw	r30, r28
    7576:	97 01       	movw	r18, r14
    7578:	a8 01       	movw	r20, r16
    757a:	da 94       	dec	r13
    757c:	79 f7       	brne	.-34     	; 0x755c <__fp_powser+0x18>
    757e:	df 90       	pop	r13
    7580:	ef 90       	pop	r14
    7582:	ff 90       	pop	r15
    7584:	0f 91       	pop	r16
    7586:	1f 91       	pop	r17
    7588:	cf 91       	pop	r28
    758a:	df 91       	pop	r29
    758c:	08 95       	ret

0000758e <__fp_pscA>:
    758e:	00 24       	eor	r0, r0
    7590:	0a 94       	dec	r0
    7592:	16 16       	cp	r1, r22
    7594:	17 06       	cpc	r1, r23
    7596:	18 06       	cpc	r1, r24
    7598:	09 06       	cpc	r0, r25
    759a:	08 95       	ret

0000759c <__fp_pscB>:
    759c:	00 24       	eor	r0, r0
    759e:	0a 94       	dec	r0
    75a0:	12 16       	cp	r1, r18
    75a2:	13 06       	cpc	r1, r19
    75a4:	14 06       	cpc	r1, r20
    75a6:	05 06       	cpc	r0, r21
    75a8:	08 95       	ret
    75aa:	c9 cf       	rjmp	.-110    	; 0x753e <__fp_nan>

000075ac <__fp_rempio2>:
    75ac:	50 d0       	rcall	.+160    	; 0x764e <__fp_splitA>
    75ae:	e8 f3       	brcs	.-6      	; 0x75aa <__fp_pscB+0xe>
    75b0:	e8 94       	clt
    75b2:	e0 e0       	ldi	r30, 0x00	; 0
    75b4:	bb 27       	eor	r27, r27
    75b6:	9f 57       	subi	r25, 0x7F	; 127
    75b8:	f0 f0       	brcs	.+60     	; 0x75f6 <__fp_rempio2+0x4a>
    75ba:	2a ed       	ldi	r18, 0xDA	; 218
    75bc:	3f e0       	ldi	r19, 0x0F	; 15
    75be:	49 ec       	ldi	r20, 0xC9	; 201
    75c0:	06 c0       	rjmp	.+12     	; 0x75ce <__fp_rempio2+0x22>
    75c2:	ee 0f       	add	r30, r30
    75c4:	bb 0f       	add	r27, r27
    75c6:	66 1f       	adc	r22, r22
    75c8:	77 1f       	adc	r23, r23
    75ca:	88 1f       	adc	r24, r24
    75cc:	28 f0       	brcs	.+10     	; 0x75d8 <__fp_rempio2+0x2c>
    75ce:	b2 3a       	cpi	r27, 0xA2	; 162
    75d0:	62 07       	cpc	r22, r18
    75d2:	73 07       	cpc	r23, r19
    75d4:	84 07       	cpc	r24, r20
    75d6:	28 f0       	brcs	.+10     	; 0x75e2 <__fp_rempio2+0x36>
    75d8:	b2 5a       	subi	r27, 0xA2	; 162
    75da:	62 0b       	sbc	r22, r18
    75dc:	73 0b       	sbc	r23, r19
    75de:	84 0b       	sbc	r24, r20
    75e0:	e3 95       	inc	r30
    75e2:	9a 95       	dec	r25
    75e4:	72 f7       	brpl	.-36     	; 0x75c2 <__fp_rempio2+0x16>
    75e6:	80 38       	cpi	r24, 0x80	; 128
    75e8:	30 f4       	brcc	.+12     	; 0x75f6 <__fp_rempio2+0x4a>
    75ea:	9a 95       	dec	r25
    75ec:	bb 0f       	add	r27, r27
    75ee:	66 1f       	adc	r22, r22
    75f0:	77 1f       	adc	r23, r23
    75f2:	88 1f       	adc	r24, r24
    75f4:	d2 f7       	brpl	.-12     	; 0x75ea <__fp_rempio2+0x3e>
    75f6:	90 48       	sbci	r25, 0x80	; 128
    75f8:	96 cf       	rjmp	.-212    	; 0x7526 <__fp_mpack_finite>

000075fa <__fp_round>:
    75fa:	09 2e       	mov	r0, r25
    75fc:	03 94       	inc	r0
    75fe:	00 0c       	add	r0, r0
    7600:	11 f4       	brne	.+4      	; 0x7606 <__fp_round+0xc>
    7602:	88 23       	and	r24, r24
    7604:	52 f0       	brmi	.+20     	; 0x761a <__fp_round+0x20>
    7606:	bb 0f       	add	r27, r27
    7608:	40 f4       	brcc	.+16     	; 0x761a <__fp_round+0x20>
    760a:	bf 2b       	or	r27, r31
    760c:	11 f4       	brne	.+4      	; 0x7612 <__fp_round+0x18>
    760e:	60 ff       	sbrs	r22, 0
    7610:	04 c0       	rjmp	.+8      	; 0x761a <__fp_round+0x20>
    7612:	6f 5f       	subi	r22, 0xFF	; 255
    7614:	7f 4f       	sbci	r23, 0xFF	; 255
    7616:	8f 4f       	sbci	r24, 0xFF	; 255
    7618:	9f 4f       	sbci	r25, 0xFF	; 255
    761a:	08 95       	ret

0000761c <__fp_sinus>:
    761c:	ef 93       	push	r30
    761e:	e0 ff       	sbrs	r30, 0
    7620:	06 c0       	rjmp	.+12     	; 0x762e <__fp_sinus+0x12>
    7622:	a2 ea       	ldi	r26, 0xA2	; 162
    7624:	2a ed       	ldi	r18, 0xDA	; 218
    7626:	3f e0       	ldi	r19, 0x0F	; 15
    7628:	49 ec       	ldi	r20, 0xC9	; 201
    762a:	5f eb       	ldi	r21, 0xBF	; 191
    762c:	7d dd       	rcall	.-1286   	; 0x7128 <__addsf3x>
    762e:	e5 df       	rcall	.-54     	; 0x75fa <__fp_round>
    7630:	0f 90       	pop	r0
    7632:	03 94       	inc	r0
    7634:	01 fc       	sbrc	r0, 1
    7636:	90 58       	subi	r25, 0x80	; 128
    7638:	e5 ef       	ldi	r30, 0xF5	; 245
    763a:	f2 e0       	ldi	r31, 0x02	; 2
    763c:	57 c1       	rjmp	.+686    	; 0x78ec <__fp_powsodd>

0000763e <__fp_split3>:
    763e:	57 fd       	sbrc	r21, 7
    7640:	90 58       	subi	r25, 0x80	; 128
    7642:	44 0f       	add	r20, r20
    7644:	55 1f       	adc	r21, r21
    7646:	59 f0       	breq	.+22     	; 0x765e <__fp_splitA+0x10>
    7648:	5f 3f       	cpi	r21, 0xFF	; 255
    764a:	71 f0       	breq	.+28     	; 0x7668 <__fp_splitA+0x1a>
    764c:	47 95       	ror	r20

0000764e <__fp_splitA>:
    764e:	88 0f       	add	r24, r24
    7650:	97 fb       	bst	r25, 7
    7652:	99 1f       	adc	r25, r25
    7654:	61 f0       	breq	.+24     	; 0x766e <__fp_splitA+0x20>
    7656:	9f 3f       	cpi	r25, 0xFF	; 255
    7658:	79 f0       	breq	.+30     	; 0x7678 <__fp_splitA+0x2a>
    765a:	87 95       	ror	r24
    765c:	08 95       	ret
    765e:	12 16       	cp	r1, r18
    7660:	13 06       	cpc	r1, r19
    7662:	14 06       	cpc	r1, r20
    7664:	55 1f       	adc	r21, r21
    7666:	f2 cf       	rjmp	.-28     	; 0x764c <__fp_split3+0xe>
    7668:	46 95       	lsr	r20
    766a:	f1 df       	rcall	.-30     	; 0x764e <__fp_splitA>
    766c:	08 c0       	rjmp	.+16     	; 0x767e <__fp_splitA+0x30>
    766e:	16 16       	cp	r1, r22
    7670:	17 06       	cpc	r1, r23
    7672:	18 06       	cpc	r1, r24
    7674:	99 1f       	adc	r25, r25
    7676:	f1 cf       	rjmp	.-30     	; 0x765a <__fp_splitA+0xc>
    7678:	86 95       	lsr	r24
    767a:	71 05       	cpc	r23, r1
    767c:	61 05       	cpc	r22, r1
    767e:	08 94       	sec
    7680:	08 95       	ret

00007682 <__fp_trunc>:
    7682:	e5 df       	rcall	.-54     	; 0x764e <__fp_splitA>
    7684:	a0 f0       	brcs	.+40     	; 0x76ae <__fp_trunc+0x2c>
    7686:	be e7       	ldi	r27, 0x7E	; 126
    7688:	b9 17       	cp	r27, r25
    768a:	88 f4       	brcc	.+34     	; 0x76ae <__fp_trunc+0x2c>
    768c:	bb 27       	eor	r27, r27
    768e:	9f 38       	cpi	r25, 0x8F	; 143
    7690:	60 f4       	brcc	.+24     	; 0x76aa <__fp_trunc+0x28>
    7692:	16 16       	cp	r1, r22
    7694:	b1 1d       	adc	r27, r1
    7696:	67 2f       	mov	r22, r23
    7698:	78 2f       	mov	r23, r24
    769a:	88 27       	eor	r24, r24
    769c:	98 5f       	subi	r25, 0xF8	; 248
    769e:	f7 cf       	rjmp	.-18     	; 0x768e <__fp_trunc+0xc>
    76a0:	86 95       	lsr	r24
    76a2:	77 95       	ror	r23
    76a4:	67 95       	ror	r22
    76a6:	b1 1d       	adc	r27, r1
    76a8:	93 95       	inc	r25
    76aa:	96 39       	cpi	r25, 0x96	; 150
    76ac:	c8 f3       	brcs	.-14     	; 0x76a0 <__fp_trunc+0x1e>
    76ae:	08 95       	ret

000076b0 <__fp_zero>:
    76b0:	e8 94       	clt

000076b2 <__fp_szero>:
    76b2:	bb 27       	eor	r27, r27
    76b4:	66 27       	eor	r22, r22
    76b6:	77 27       	eor	r23, r23
    76b8:	cb 01       	movw	r24, r22
    76ba:	97 f9       	bld	r25, 7
    76bc:	08 95       	ret

000076be <__gesf2>:
    76be:	ec de       	rcall	.-552    	; 0x7498 <__fp_cmp>
    76c0:	08 f4       	brcc	.+2      	; 0x76c4 <__gesf2+0x6>
    76c2:	8f ef       	ldi	r24, 0xFF	; 255
    76c4:	08 95       	ret

000076c6 <inverse>:
    76c6:	9b 01       	movw	r18, r22
    76c8:	ac 01       	movw	r20, r24
    76ca:	60 e0       	ldi	r22, 0x00	; 0
    76cc:	70 e0       	ldi	r23, 0x00	; 0
    76ce:	80 e8       	ldi	r24, 0x80	; 128
    76d0:	9f e3       	ldi	r25, 0x3F	; 63
    76d2:	f9 cd       	rjmp	.-1038   	; 0x72c6 <__divsf3>

000076d4 <lround>:
    76d4:	bc df       	rcall	.-136    	; 0x764e <__fp_splitA>
    76d6:	58 f1       	brcs	.+86     	; 0x772e <lround+0x5a>
    76d8:	9e 57       	subi	r25, 0x7E	; 126
    76da:	58 f1       	brcs	.+86     	; 0x7732 <lround+0x5e>
    76dc:	98 51       	subi	r25, 0x18	; 24
    76de:	a0 f0       	brcs	.+40     	; 0x7708 <lround+0x34>
    76e0:	e9 f0       	breq	.+58     	; 0x771c <lround+0x48>
    76e2:	98 30       	cpi	r25, 0x08	; 8
    76e4:	20 f5       	brcc	.+72     	; 0x772e <lround+0x5a>
    76e6:	09 2e       	mov	r0, r25
    76e8:	99 27       	eor	r25, r25
    76ea:	66 0f       	add	r22, r22
    76ec:	77 1f       	adc	r23, r23
    76ee:	88 1f       	adc	r24, r24
    76f0:	99 1f       	adc	r25, r25
    76f2:	0a 94       	dec	r0
    76f4:	d1 f7       	brne	.-12     	; 0x76ea <lround+0x16>
    76f6:	12 c0       	rjmp	.+36     	; 0x771c <lround+0x48>
    76f8:	06 2e       	mov	r0, r22
    76fa:	67 2f       	mov	r22, r23
    76fc:	78 2f       	mov	r23, r24
    76fe:	88 27       	eor	r24, r24
    7700:	98 5f       	subi	r25, 0xF8	; 248
    7702:	11 f4       	brne	.+4      	; 0x7708 <lround+0x34>
    7704:	00 0c       	add	r0, r0
    7706:	07 c0       	rjmp	.+14     	; 0x7716 <lround+0x42>
    7708:	99 3f       	cpi	r25, 0xF9	; 249
    770a:	b4 f3       	brlt	.-20     	; 0x76f8 <lround+0x24>
    770c:	86 95       	lsr	r24
    770e:	77 95       	ror	r23
    7710:	67 95       	ror	r22
    7712:	93 95       	inc	r25
    7714:	d9 f7       	brne	.-10     	; 0x770c <lround+0x38>
    7716:	61 1d       	adc	r22, r1
    7718:	71 1d       	adc	r23, r1
    771a:	81 1d       	adc	r24, r1
    771c:	3e f4       	brtc	.+14     	; 0x772c <lround+0x58>
    771e:	90 95       	com	r25
    7720:	80 95       	com	r24
    7722:	70 95       	com	r23
    7724:	61 95       	neg	r22
    7726:	7f 4f       	sbci	r23, 0xFF	; 255
    7728:	8f 4f       	sbci	r24, 0xFF	; 255
    772a:	9f 4f       	sbci	r25, 0xFF	; 255
    772c:	08 95       	ret
    772e:	68 94       	set
    7730:	c0 cf       	rjmp	.-128    	; 0x76b2 <__fp_szero>
    7732:	be cf       	rjmp	.-132    	; 0x76b0 <__fp_zero>

00007734 <__mulsf3>:
    7734:	0b d0       	rcall	.+22     	; 0x774c <__mulsf3x>
    7736:	61 cf       	rjmp	.-318    	; 0x75fa <__fp_round>
    7738:	2a df       	rcall	.-428    	; 0x758e <__fp_pscA>
    773a:	28 f0       	brcs	.+10     	; 0x7746 <__mulsf3+0x12>
    773c:	2f df       	rcall	.-418    	; 0x759c <__fp_pscB>
    773e:	18 f0       	brcs	.+6      	; 0x7746 <__mulsf3+0x12>
    7740:	95 23       	and	r25, r21
    7742:	09 f0       	breq	.+2      	; 0x7746 <__mulsf3+0x12>
    7744:	cd ce       	rjmp	.-614    	; 0x74e0 <__fp_inf>
    7746:	fb ce       	rjmp	.-522    	; 0x753e <__fp_nan>
    7748:	11 24       	eor	r1, r1
    774a:	b3 cf       	rjmp	.-154    	; 0x76b2 <__fp_szero>

0000774c <__mulsf3x>:
    774c:	78 df       	rcall	.-272    	; 0x763e <__fp_split3>
    774e:	a0 f3       	brcs	.-24     	; 0x7738 <__mulsf3+0x4>

00007750 <__mulsf3_pse>:
    7750:	95 9f       	mul	r25, r21
    7752:	d1 f3       	breq	.-12     	; 0x7748 <__mulsf3+0x14>
    7754:	95 0f       	add	r25, r21
    7756:	50 e0       	ldi	r21, 0x00	; 0
    7758:	55 1f       	adc	r21, r21
    775a:	62 9f       	mul	r22, r18
    775c:	f0 01       	movw	r30, r0
    775e:	72 9f       	mul	r23, r18
    7760:	bb 27       	eor	r27, r27
    7762:	f0 0d       	add	r31, r0
    7764:	b1 1d       	adc	r27, r1
    7766:	63 9f       	mul	r22, r19
    7768:	aa 27       	eor	r26, r26
    776a:	f0 0d       	add	r31, r0
    776c:	b1 1d       	adc	r27, r1
    776e:	aa 1f       	adc	r26, r26
    7770:	64 9f       	mul	r22, r20
    7772:	66 27       	eor	r22, r22
    7774:	b0 0d       	add	r27, r0
    7776:	a1 1d       	adc	r26, r1
    7778:	66 1f       	adc	r22, r22
    777a:	82 9f       	mul	r24, r18
    777c:	22 27       	eor	r18, r18
    777e:	b0 0d       	add	r27, r0
    7780:	a1 1d       	adc	r26, r1
    7782:	62 1f       	adc	r22, r18
    7784:	73 9f       	mul	r23, r19
    7786:	b0 0d       	add	r27, r0
    7788:	a1 1d       	adc	r26, r1
    778a:	62 1f       	adc	r22, r18
    778c:	83 9f       	mul	r24, r19
    778e:	a0 0d       	add	r26, r0
    7790:	61 1d       	adc	r22, r1
    7792:	22 1f       	adc	r18, r18
    7794:	74 9f       	mul	r23, r20
    7796:	33 27       	eor	r19, r19
    7798:	a0 0d       	add	r26, r0
    779a:	61 1d       	adc	r22, r1
    779c:	23 1f       	adc	r18, r19
    779e:	84 9f       	mul	r24, r20
    77a0:	60 0d       	add	r22, r0
    77a2:	21 1d       	adc	r18, r1
    77a4:	82 2f       	mov	r24, r18
    77a6:	76 2f       	mov	r23, r22
    77a8:	6a 2f       	mov	r22, r26
    77aa:	11 24       	eor	r1, r1
    77ac:	9f 57       	subi	r25, 0x7F	; 127
    77ae:	50 40       	sbci	r21, 0x00	; 0
    77b0:	8a f0       	brmi	.+34     	; 0x77d4 <__mulsf3_pse+0x84>
    77b2:	e1 f0       	breq	.+56     	; 0x77ec <__mulsf3_pse+0x9c>
    77b4:	88 23       	and	r24, r24
    77b6:	4a f0       	brmi	.+18     	; 0x77ca <__mulsf3_pse+0x7a>
    77b8:	ee 0f       	add	r30, r30
    77ba:	ff 1f       	adc	r31, r31
    77bc:	bb 1f       	adc	r27, r27
    77be:	66 1f       	adc	r22, r22
    77c0:	77 1f       	adc	r23, r23
    77c2:	88 1f       	adc	r24, r24
    77c4:	91 50       	subi	r25, 0x01	; 1
    77c6:	50 40       	sbci	r21, 0x00	; 0
    77c8:	a9 f7       	brne	.-22     	; 0x77b4 <__mulsf3_pse+0x64>
    77ca:	9e 3f       	cpi	r25, 0xFE	; 254
    77cc:	51 05       	cpc	r21, r1
    77ce:	70 f0       	brcs	.+28     	; 0x77ec <__mulsf3_pse+0x9c>
    77d0:	87 ce       	rjmp	.-754    	; 0x74e0 <__fp_inf>
    77d2:	6f cf       	rjmp	.-290    	; 0x76b2 <__fp_szero>
    77d4:	5f 3f       	cpi	r21, 0xFF	; 255
    77d6:	ec f3       	brlt	.-6      	; 0x77d2 <__mulsf3_pse+0x82>
    77d8:	98 3e       	cpi	r25, 0xE8	; 232
    77da:	dc f3       	brlt	.-10     	; 0x77d2 <__mulsf3_pse+0x82>
    77dc:	86 95       	lsr	r24
    77de:	77 95       	ror	r23
    77e0:	67 95       	ror	r22
    77e2:	b7 95       	ror	r27
    77e4:	f7 95       	ror	r31
    77e6:	e7 95       	ror	r30
    77e8:	9f 5f       	subi	r25, 0xFF	; 255
    77ea:	c1 f7       	brne	.-16     	; 0x77dc <__mulsf3_pse+0x8c>
    77ec:	fe 2b       	or	r31, r30
    77ee:	88 0f       	add	r24, r24
    77f0:	91 1d       	adc	r25, r1
    77f2:	96 95       	lsr	r25
    77f4:	87 95       	ror	r24
    77f6:	97 f9       	bld	r25, 7
    77f8:	08 95       	ret

000077fa <round>:
    77fa:	29 df       	rcall	.-430    	; 0x764e <__fp_splitA>
    77fc:	e0 f0       	brcs	.+56     	; 0x7836 <round+0x3c>
    77fe:	9e 37       	cpi	r25, 0x7E	; 126
    7800:	d8 f0       	brcs	.+54     	; 0x7838 <round+0x3e>
    7802:	96 39       	cpi	r25, 0x96	; 150
    7804:	b8 f4       	brcc	.+46     	; 0x7834 <round+0x3a>
    7806:	9e 38       	cpi	r25, 0x8E	; 142
    7808:	48 f4       	brcc	.+18     	; 0x781c <round+0x22>
    780a:	67 2f       	mov	r22, r23
    780c:	78 2f       	mov	r23, r24
    780e:	88 27       	eor	r24, r24
    7810:	98 5f       	subi	r25, 0xF8	; 248
    7812:	f9 cf       	rjmp	.-14     	; 0x7806 <round+0xc>
    7814:	86 95       	lsr	r24
    7816:	77 95       	ror	r23
    7818:	67 95       	ror	r22
    781a:	93 95       	inc	r25
    781c:	95 39       	cpi	r25, 0x95	; 149
    781e:	d0 f3       	brcs	.-12     	; 0x7814 <round+0x1a>
    7820:	b6 2f       	mov	r27, r22
    7822:	b1 70       	andi	r27, 0x01	; 1
    7824:	6b 0f       	add	r22, r27
    7826:	71 1d       	adc	r23, r1
    7828:	81 1d       	adc	r24, r1
    782a:	20 f4       	brcc	.+8      	; 0x7834 <round+0x3a>
    782c:	87 95       	ror	r24
    782e:	77 95       	ror	r23
    7830:	67 95       	ror	r22
    7832:	93 95       	inc	r25
    7834:	5b ce       	rjmp	.-842    	; 0x74ec <__fp_mintl>
    7836:	75 ce       	rjmp	.-790    	; 0x7522 <__fp_mpack>
    7838:	3c cf       	rjmp	.-392    	; 0x76b2 <__fp_szero>

0000783a <sin>:
    783a:	9f 93       	push	r25
    783c:	b7 de       	rcall	.-658    	; 0x75ac <__fp_rempio2>
    783e:	0f 90       	pop	r0
    7840:	07 fc       	sbrc	r0, 7
    7842:	ee 5f       	subi	r30, 0xFE	; 254
    7844:	eb ce       	rjmp	.-554    	; 0x761c <__fp_sinus>
    7846:	11 f4       	brne	.+4      	; 0x784c <sin+0x12>
    7848:	0e f4       	brtc	.+2      	; 0x784c <sin+0x12>
    784a:	79 ce       	rjmp	.-782    	; 0x753e <__fp_nan>
    784c:	6a ce       	rjmp	.-812    	; 0x7522 <__fp_mpack>

0000784e <sqrt>:
    784e:	ff de       	rcall	.-514    	; 0x764e <__fp_splitA>
    7850:	d0 f3       	brcs	.-12     	; 0x7846 <sin+0xc>
    7852:	99 23       	and	r25, r25
    7854:	d9 f3       	breq	.-10     	; 0x784c <sin+0x12>
    7856:	ce f3       	brts	.-14     	; 0x784a <sin+0x10>
    7858:	9f 57       	subi	r25, 0x7F	; 127
    785a:	55 0b       	sbc	r21, r21
    785c:	87 ff       	sbrs	r24, 7
    785e:	3f d0       	rcall	.+126    	; 0x78de <__fp_norm2>
    7860:	00 24       	eor	r0, r0
    7862:	a0 e6       	ldi	r26, 0x60	; 96
    7864:	40 ea       	ldi	r20, 0xA0	; 160
    7866:	90 01       	movw	r18, r0
    7868:	80 58       	subi	r24, 0x80	; 128
    786a:	56 95       	lsr	r21
    786c:	97 95       	ror	r25
    786e:	28 f4       	brcc	.+10     	; 0x787a <sqrt+0x2c>
    7870:	80 5c       	subi	r24, 0xC0	; 192
    7872:	66 0f       	add	r22, r22
    7874:	77 1f       	adc	r23, r23
    7876:	88 1f       	adc	r24, r24
    7878:	20 f0       	brcs	.+8      	; 0x7882 <sqrt+0x34>
    787a:	26 17       	cp	r18, r22
    787c:	37 07       	cpc	r19, r23
    787e:	48 07       	cpc	r20, r24
    7880:	30 f4       	brcc	.+12     	; 0x788e <sqrt+0x40>
    7882:	62 1b       	sub	r22, r18
    7884:	73 0b       	sbc	r23, r19
    7886:	84 0b       	sbc	r24, r20
    7888:	20 29       	or	r18, r0
    788a:	31 29       	or	r19, r1
    788c:	4a 2b       	or	r20, r26
    788e:	a6 95       	lsr	r26
    7890:	17 94       	ror	r1
    7892:	07 94       	ror	r0
    7894:	20 25       	eor	r18, r0
    7896:	31 25       	eor	r19, r1
    7898:	4a 27       	eor	r20, r26
    789a:	58 f7       	brcc	.-42     	; 0x7872 <sqrt+0x24>
    789c:	66 0f       	add	r22, r22
    789e:	77 1f       	adc	r23, r23
    78a0:	88 1f       	adc	r24, r24
    78a2:	20 f0       	brcs	.+8      	; 0x78ac <sqrt+0x5e>
    78a4:	26 17       	cp	r18, r22
    78a6:	37 07       	cpc	r19, r23
    78a8:	48 07       	cpc	r20, r24
    78aa:	30 f4       	brcc	.+12     	; 0x78b8 <sqrt+0x6a>
    78ac:	62 0b       	sbc	r22, r18
    78ae:	73 0b       	sbc	r23, r19
    78b0:	84 0b       	sbc	r24, r20
    78b2:	20 0d       	add	r18, r0
    78b4:	31 1d       	adc	r19, r1
    78b6:	41 1d       	adc	r20, r1
    78b8:	a0 95       	com	r26
    78ba:	81 f7       	brne	.-32     	; 0x789c <sqrt+0x4e>
    78bc:	b9 01       	movw	r22, r18
    78be:	84 2f       	mov	r24, r20
    78c0:	91 58       	subi	r25, 0x81	; 129
    78c2:	88 0f       	add	r24, r24
    78c4:	96 95       	lsr	r25
    78c6:	87 95       	ror	r24
    78c8:	08 95       	ret

000078ca <square>:
    78ca:	9b 01       	movw	r18, r22
    78cc:	ac 01       	movw	r20, r24
    78ce:	32 cf       	rjmp	.-412    	; 0x7734 <__mulsf3>

000078d0 <trunc>:
    78d0:	d8 de       	rcall	.-592    	; 0x7682 <__fp_trunc>
    78d2:	20 f0       	brcs	.+8      	; 0x78dc <trunc+0xc>
    78d4:	9f 37       	cpi	r25, 0x7F	; 127
    78d6:	08 f4       	brcc	.+2      	; 0x78da <trunc+0xa>
    78d8:	ec ce       	rjmp	.-552    	; 0x76b2 <__fp_szero>
    78da:	08 ce       	rjmp	.-1008   	; 0x74ec <__fp_mintl>
    78dc:	22 ce       	rjmp	.-956    	; 0x7522 <__fp_mpack>

000078de <__fp_norm2>:
    78de:	91 50       	subi	r25, 0x01	; 1
    78e0:	50 40       	sbci	r21, 0x00	; 0
    78e2:	66 0f       	add	r22, r22
    78e4:	77 1f       	adc	r23, r23
    78e6:	88 1f       	adc	r24, r24
    78e8:	d2 f7       	brpl	.-12     	; 0x78de <__fp_norm2>
    78ea:	08 95       	ret

000078ec <__fp_powsodd>:
    78ec:	9f 93       	push	r25
    78ee:	8f 93       	push	r24
    78f0:	7f 93       	push	r23
    78f2:	6f 93       	push	r22
    78f4:	ff 93       	push	r31
    78f6:	ef 93       	push	r30
    78f8:	9b 01       	movw	r18, r22
    78fa:	ac 01       	movw	r20, r24
    78fc:	1b df       	rcall	.-458    	; 0x7734 <__mulsf3>
    78fe:	ef 91       	pop	r30
    7900:	ff 91       	pop	r31
    7902:	20 de       	rcall	.-960    	; 0x7544 <__fp_powser>
    7904:	2f 91       	pop	r18
    7906:	3f 91       	pop	r19
    7908:	4f 91       	pop	r20
    790a:	5f 91       	pop	r21
    790c:	13 cf       	rjmp	.-474    	; 0x7734 <__mulsf3>

0000790e <__udivmodsi4>:
    790e:	a1 e2       	ldi	r26, 0x21	; 33
    7910:	1a 2e       	mov	r1, r26
    7912:	aa 1b       	sub	r26, r26
    7914:	bb 1b       	sub	r27, r27
    7916:	fd 01       	movw	r30, r26
    7918:	0d c0       	rjmp	.+26     	; 0x7934 <__udivmodsi4_ep>

0000791a <__udivmodsi4_loop>:
    791a:	aa 1f       	adc	r26, r26
    791c:	bb 1f       	adc	r27, r27
    791e:	ee 1f       	adc	r30, r30
    7920:	ff 1f       	adc	r31, r31
    7922:	a2 17       	cp	r26, r18
    7924:	b3 07       	cpc	r27, r19
    7926:	e4 07       	cpc	r30, r20
    7928:	f5 07       	cpc	r31, r21
    792a:	20 f0       	brcs	.+8      	; 0x7934 <__udivmodsi4_ep>
    792c:	a2 1b       	sub	r26, r18
    792e:	b3 0b       	sbc	r27, r19
    7930:	e4 0b       	sbc	r30, r20
    7932:	f5 0b       	sbc	r31, r21

00007934 <__udivmodsi4_ep>:
    7934:	66 1f       	adc	r22, r22
    7936:	77 1f       	adc	r23, r23
    7938:	88 1f       	adc	r24, r24
    793a:	99 1f       	adc	r25, r25
    793c:	1a 94       	dec	r1
    793e:	69 f7       	brne	.-38     	; 0x791a <__udivmodsi4_loop>
    7940:	60 95       	com	r22
    7942:	70 95       	com	r23
    7944:	80 95       	com	r24
    7946:	90 95       	com	r25
    7948:	9b 01       	movw	r18, r22
    794a:	ac 01       	movw	r20, r24
    794c:	bd 01       	movw	r22, r26
    794e:	cf 01       	movw	r24, r30
    7950:	08 95       	ret

00007952 <__tablejump2__>:
    7952:	ee 0f       	add	r30, r30
    7954:	ff 1f       	adc	r31, r31

00007956 <__tablejump__>:
    7956:	05 90       	lpm	r0, Z+
    7958:	f4 91       	lpm	r31, Z
    795a:	e0 2d       	mov	r30, r0
    795c:	09 94       	ijmp

0000795e <_exit>:
    795e:	f8 94       	cli

00007960 <__stop_program>:
    7960:	ff cf       	rjmp	.-2      	; 0x7960 <__stop_program>
